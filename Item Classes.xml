<project wind-frame="28.000000,57.000000,238.000000,587.000000">
<class mod-time="Sun, 18 Jun 2000 22:37:32 PDT" wind-frame="80.000000,190.000000,720.000000,720.000000" list-views-height="0.000000">
<name>
Docs
</name>
<method access="public" mod-time="Sun, 18 Jun 2000 22:37:32 PDT"><![CDATA[
"Change Log"

2000.6.18	Changed NNTPApp::ReadyToRun() so it no longer puts up the about box.
			Also made it set the MIME type when creating the newsrc file.  (A)

2000.5.30	Made NNTPResponse::SpillBuffer() spill the buffer if the buffer only
			contains a partial line, even though this results in the original
			buffer becoming empty.  We actually do receive buffers like this,
			and we need to get the line breaks correct, especially for binaries.
			(2000.5.31.A)

2000.5.2	Made NNTPConnection::Connect() do preemptive authentication.  (A)

			NNTPConnection::Connect() now kicks out properly when the initial
			connection fails.  (B)

2000.4.27	Created Logger, and made NNTPConnection and NNTPResponse support it.
			Made PostArticlesThread use it.  (A)

2000.4.20	Added PrefsDlog::ResizeToPreferredHeight(), and use it for the
			binaries path pref.

			Changed NNTPConnection::GetResponse() to do authentication (using
			"original AUTHINFO").  (Also made SendCommand() save the last
			command so it can be resent.)

			Added "userName" and "password" prefs to the PrefsDlog.  (A)

			In PrefsDlog, consolidated the "Colors" and "Fonts" panels into
			a single "Appearance" panel.

			Made Newsgroup::ReadArticleCache() and GetOneHeaderRange() automatically
			expand the subjects if the "expandSubjectsByDefault" pref is set.

			Made SubjectTreeAdaptor::DrawArticle() draw dates and lines, subject
			to "showDates" and "showLines" prefs.  Various changes to
			SubjectTreeAdaptor and SubjectsView to handle the prefs.

			Added checkboxes for the "showDates" and "showLines" prefs to
			PrefsDlog, with changes to support live checkboxes (although they
			don't revert on a cancel like other live controls).  Also added
			"extra info font" control.  (2000.4.21.A)

			Ported changes to x86.

			Changed the default "extra info" font to a cooler-looking italic
			font.  (2000.4.21.B)

2000.4.18	Fixed ExtractBinariesThread::ExtractMultipartBinary() so it quotes
			the file path it passes to uudecode (as ExtractMultipleBinaries()
			was already doing).

			Changes to ArticleSavingThread::WriteFile() and to
			ExtractBinariesThread so that files that are going to be decoded
			don't get headers or blank lines saved.

			Wrote NewsgroupsView::RemoveSelectedItem().  (A)

2000.4.17	Factored AllGroupsWind out of GroupsListWind.  Factored AllGroupsList
			out of GroupsList.  Various changes to NNTPApp accordingly.

			Added NewGroupsWind and GetNewGroupsThread, and changed NNTPApp
			to use them.

			Fixes to GetGroupsListThread.  (A)

			Changed NNTPApp::ReadyToRun() so it initializes the
			"lastGroupsUpdateTime" pref to zero instead of the current time,
			so groups that came in between the creation of the group list and
			the running of this new version will still get picked up.  (B)

2000.4.15	Changes to ArticleSavingThread so it doesn't waste as many cycles
			updating the progress display.  (B)

			Moved progress update interval handling from ArticleSavingThread to
			Task and made OpenGroupThread use it.

			Made SubjectTreeAdaptor::MouseDown() clear its view's selection
			direction, fixing a bug that sometimes caused the selection to be
			lost when using the shift-up/down-arrow keys.  (C)

			Changed ExtractBinariesThread::GetTempFileName() so the temporary
			files sort at the end of the directory.

2000.4.14	Changed to use Preferences from the Common Classes.

			Factored out WriteFile() from OpenArticleThread and
			SaveArticleThread into the new ArticleSavingThread.

			Added the "binariesPath" pref to the PrefsDlog.

			Added ExtractBinariesThread and made NewsgroupWind call it.
			Included added SubjectsView::InvalidateSubject().
			(2000.4.15.A)

2000.4.8	Ported to Intel.

1999.11.27	Made OpenGroupThread::Action() *always* send the "group" command,
			so it calls Newsgroup::SetAvailableArticles(), so the newsgroup
			knows it has headers it has to download.  (A)

1999.11.1	Changed PostArticlesThread::GetFromHeader() to prefer the "reply-to"
			setting, and to compose the "from" address from both the "pop_name"
			and "pop_host" otherwise.  (A)

1999.10.23	Made NNTPApp::WindowClosing() account for the "saveArticlesPanel"
			when deciding whether to quit.  Not yet tested.  (A)

1999.10.22	Made NNTPApp::ShowSaveArticlesPanel() stuff the subject in the
			file name field.  (A)

1999.9.28	Changed PostArticlesThread::GetFromHeader() to warn if the email
			settings aren't set up and to try to use the reply-to setting if
			the pop-name setting is empty.  (A)

1999.9.25	Made NNTPApp::ShowAbout() show the build date.

			Changed PostArticlesThread::PostArticle() to give a more descriptive
			error message when the server doesn't accept the article.  (A)

1999.9.23	Tweaking of expander triangles.  Changes to tweex in ListableObject,
			and to ListableObject::DrawExpander() and to Draw() and MouseDown()
			methods of SubjectTreeAdaptor and FilterGroup.  (A)

			Added command-shift-key shortcuts to the "View By..." menu items
			in the NewsgroupWind ctor.

			Added Subject::RemoveArticle().

			Added Newsgroup::RemoveReadArticles(), and made NewsgroupWind call
			it on a menu command.  (B)

1999.9.11	Made OpenArticleThread::Action() check if the message-id
			has any slashes in it before trying to use it as the
			message filename.  (A)

1999.9.11	Changed the name of the application to Item.  (A)

			-- CY project file crashed and had to be rebuilt. --

			Changed FileNames to always use "Item" rt "NNTPTest".  (B)

			Changed NNTPApp::ReadyToRun() to automatically open/create a
			"My Newsgroups" file if opened without a file.  (C)

			Changed NNTPApp::ReadyToRun() to put the "My Newsgroups" file
			in "/boot/home" rt in the app's directory (which wasn't working
			anyway).  (D)

			Added "defaultListFont" global to Prefs and made SetupFont() methods
			of NewsgroupsView and SubjectTreeAdaptor use it.

			Bumped NewsgroupWind::DefaultHeight from 400 to 560.  Bumped
			DefaultWidth from 400 to 500.

			Changed FontPrefControl ctor to show the correct default font
			for "listFont".  (E)

			Added NNTPApp::ShowAbout() and made ReadyToRun() and MessageReceived()
			call it.  Made a menu item for it in the NewsrcWind ctor.  (F)

1999.8.26	Changed OpenArticleThread::Action() so it doesn't set the preferred
			application for the article file.  This means each user will have to do
			this using the FileTypes app.  (1999.8.27.A)

1999.5.15	Added NewsgroupWind::HiliteSubjects() and made a menu item for it.  (A)

4/7/99		Changed all three Error::Error() methods so the spacebar can be used
			as a shortcut for the OK button.  (19990408A)

3/8/99		In Filter, changed FilterHeader enum values from Subject and Author
			to BySubject and ByAuthor, to avoid name conflict with the Subject
			class.

			Added NewsgroupWind::KillSubjects(), and made a menu item for it.
			The FiltersWind doesn't get updated, though.  (19990309A)

12/10/98	Made ArticleSet::NumArticlesIn() check if each (intersected) range is
			valid before adding its size into the article count.  This was causing
			the thermometer not to go when getting a groups headers.  (A)

12/9/98		Wrote Error::ErrorString(), which adds NNTP errors to the strerror()
			stuff.  Changed Error::Error()s to use it.

			Moved code from NNTPConnection::SendCommand() to new SendLine().  (A)

			Changed NNTPConnection::Connect() so it no longer takes arguments, but
			gets the server name from the prefs itself.  Changed
			ConnectionPool::GetConnection() appropriately.

			Changed NNTPConnection::SendCommand() to reconnect and try again if
			the connection timed out.  Program crashed on exit when I tested this
			but I couldn't replicate it.  (B)

11/4/98		Changes to NewsgroupsView to use the "listFont" pref.  (A)

			Changes to NewsgroupWind and NewsrcWind to save window positions.  (B)

11/3/98 	Created FontUtils.

			Created FontPrefControl, and added one to PrefsDlog.

			Added ListableTree::AllHeightsChanged().

			Changes to SubjectTreeAdaptor so it uses the "listFont" pref.

			Changed SubjectsView::PrefChanged() to handle the "listFont" pref.  (A)

			Changed SubjectTreeAdaptor vars and SetupFont() so the "articleItemIndent"
			is based on the font size.  (B)

10/29/98	In ScrolledListView, factored code out of TrackRearrangement() into
			TrackInsertionStep().

			Created DragUtils.

			Added Newsgroup::NewsgroupNamed().

			Created TrackGroupDragThread and made new NewsgroupsView::MouseMoved()
			method spawn it.  (A)

10/28/98	Changed Filters::Load() to delete the file if the InitCheck() indicates
			an error.

			Added Task::BumpProgress().

			More work on the groups list, including the window and reading and
			saving to a file.  Changes to GroupsList and GroupName.  Created
			GroupsListWind.  Made NNTPApp keep a "groupsList" and "groupsListWind".
			Added menu item to NewsrcWind.  (A)

			Created GroupsListView.

			Added GroupsList::AttachedToView() and DetachedFromView().

			Changed TasksView to have a candy-stripe equivalent.

			Made GroupsList a BLocker.

			Added GroupsList::AddGroup(), SetResponse(), and Dirtify().

			Created GetGroupsListThread, and made GroupsList constructor call
			it if necessary.  (B)

10/27/98	Made newsgroups rearrangeable in the NewsrcWind.  Added
			NewsgroupsView::CanRearrange() and ItemMoved(), and
			Newsrc::RemoveNewsgroupAt() and AddNewsgroupAt().  (A)

			Added GroupsList and GroupName classes, neither of which is complete.

10/25/98	Made NewsrcWind::Quit() hide the window before killing threads, and
			made Newsrc::NewsgroupChanged() check if the window is hidden before
			trying to lock it and invalidate the changed item.  This is a
			sorta-cheezy way of prevent the deadlock that occurred when quitting
			while a GetGroupStatsThread was active.  (A)

10/19/98	Added Newsrc::AttachedToView() and NewsgroupChanged() (and "view" ivar),
			and made NewsgroupsView constructor call AttachedToView().

			Changed Newsgroup to keep a reference to its Newsrc, changed
			CalcNumUnreadArticles() to notify the Newsrc, and added
			ReadArticlesChanged().

			Made NewsgroupWind::MarkSelected() and OpenArticleThread::Action()
			call Newsgroup::ReadArticlesChanged().  These changes make the
			NewsrcWind reflect changes in the number of read articles.  (A)

10/18/98	Wrote Task, TasksWind, and TasksView.  Disabled ConnectionWind support
			in ConnectionPool and NNTPConnection.  Changed Threads to use Task to
			report progress instead of NNTPConnection, which included changes to
			Newsgroup::ReadHeaders() and GetOneHeaderRange().  (A)

			Got rid of many of the vestiges of the ConnectionsWind.

			Changed Action() methods of GetGroupStatsThread and OpenGroupThread to
			give a better initial progress strings.  (B)

10/17/98	Moved space-key handling code from SubjectsView::KeyDown() to new
			OpenNextUnread() method, and changed it to better handle the case where
			an article is selected in the middle of a subject.

			Made SubjectsView::OpenArticle() refresh the item.  (A)

			Changed PostArticlesThread::PostArticle() to include the header name
			in the "Date" header, which it wasn't before.

			Added NNTPConnection::LocalIPAddr().

			Added PostArticlesThread::GetMessageIDHeader(), making PostArticle()
			use it to generate a Message-ID header if there isn't one.  It turns
			out, however, that neither this nor the date seems to really need to
			be there, since Newscene replaces these headers.  Looks like the
			problem of posting not working before was just due to the bogus date
			header without a header name.  (B)

10/14/98	Fixed PostArticlesThread::PostArticle(), which was not interpreting
			the result of the BFile::ReadAt() call correctly.

			Made NNTPConnection::SendCommand() check for a zero-length command.
			It turns out that a zero-length send() call crashes net_server.

			Posting seems to be working!  Yay!  (Although my posts haven't shown
			up yet...).  (A)

10/13/98	Made SubjectsView store the selection direction.

			Changed SubjectTreeAdaptor::SelectUp() and SelectDown() to be nicer
			when shift-selecting (paying attention to the selection direction).
			Included adding NumSelections() method.  (A)

			Made NNTPApp a ThreadOwner.

			Added TextReader::Position() (included adding "start" ivar).

			Added Autodeleter.

			Made the Error::Error() functions return the result code, which
			allows convenient one-line expression of common "handle error and
			return result" operation.

			Created PostArticlesThread.

			Made NNTPApp handle new 'Post' message, which currently must include
			a list of the files to post in a "refs" field.  (Not debugged)  (B)

10/3/98	Added ColorPrefWind, with changes to ColorPrefControl to use it.  (A)

		Changes to SubjectTreeAdaptor::DrawSubject(), etc., to show the number of
		unread articles.  (B)

9/28/98	Changed PrefsChangeClient::PrefChanged() to take a string_slice instead of a
		char*, and changed Preferences::PrefChanged() to pass it that way.

		Added Preferences::GetColorPref() and SetColorPref().

		Created ColorPrefWatcher.

		Created ListColors and made NewsgroupsView::DrawItem() and
		SubjectTreeAdaptor::SetupColors() and Draw() to use it.  (A)

		Fixed Preferences::SetColorPref(), which was screwing up when converting
		the rgb_color to an int32.

		Created ColorPrefControl.

		Changed NewsgroupsView and SubjectsView to respond to changes in list color
		prefs.

		Renamed PrefsDlog::LayoutItems() to LayoutItemsIn() and added ResizeBox().

		Changed PrefsDlog to add the list colors prefs.  (B)

		Make PrefsDlog::Save() save the hilited, bgnd, and text list colors, which
		it didn't before.

		Added "Show Preferences" menu item to the "Newsgroups" menu in NewsgroupWind.

9/27/98	-- WHILE WORKING, THE CASTLE YANKEE PROJECT GOT CORRUPTED AND HAD TO BE REBUILT --

		Created PrefsDlog, with changes to NNTPApp and NewsrcWind to call it from
		a menu command.  It doesn't actually set the prefs yet, though.  (A)

		Added PrefsDlog::QuitRequested() and Save(), which verify and save the
		settings.

		Changed ConnectionPool::MaxConnections() to use the "maxConnections" pref.  (B)

9/25/98	Changed SavedArticleThread so it takes a message specifying several articles
		to save.  Moved most of the code from the old Action() to new SaveMessage()
		private method.  Appropriate changes to NNTPApp::AppendArticles().  This makes
		saving multiple articles work.  (A)

		Changed NNTPApp::ShowAppendArticlesPanel() and AppendArticles() to store
		the "savedArticlesDir" pref as a string rather than an entry_ref.  (B)

		Changes to NNTPApp and NewsgroupWind to support saving articles to a new
		file.  NNTPApp got new ShowSaveArticlesPanel() and SaveArticles() methods.  (C)

9/21/98	Fixed a bug in SaveArticleThread::Action(), which was accidentally sending
		the command twice (!).

		Changed NNTPApp::AppendArticles() and ShowAppendArticlesPanel() to save and
		restore the panel position and size.

		Changed NNTPApp::ShowAppendArticlesPanel() to set the title of the panel.  (A)

9/20/98	Added LineEndType.

		Added ConnectionGetter.

		Declared many member functions of string_slice to be "const".

		Created ParseUtils, moving ParseHeader() there from OpenArticleThread.

		Created SaveArticleThread.  (A)

		Added Preferences::GetRefPref() and SetRefPref().

		Added Subject::SetupSaveArticles().

		Added ShowAppendArticlesPanel() to NNTPApp, with changes to WindowClosing()
		and MessageReceived().

		Changes to NewsgroupWind to add and implement the "Append To..." menu item.
		Works fine for single-article selections, but for multiple articles you'll
		get multiple threads trying to write to the same file...gotta fix that.  (B)

9/18/98	Added AATreeListView::IndexOf() and NumObjects(), which both just provide
		handy access to the tree's functions of the same names.

		Added ScrollDown() and ScrollUp() virtual methods to ListableObject, and
		rewrote the relevant portions of AATreeListView::KeyDown().

		Added SubjectTreeAdaptor::SelectDown(), SelectUp(), and SelectLast().  (A)

		Changed SubjectTreeAdaptor::SelectDown() and SelectUp() to skip to the
		next/previous subject line if the option key is down.

		Lightened up the background color of AddGroupDlog and ServerDlog, to get
		it to match BeOS dialogs better.  (B)

		Made SubjectTreeAdaptor::SelectLast() scroll to the selection.

9/16/98	Changed OpenGroupThread::Action() to read the article cache *before*
		trying to get a connection.

		Changed NNTPConnection, moving actual connection code out of constructor
		into new Connect() method, with corresponding changes to
		ConnectionPool::GetConnection().

		Changed ConnectionPool::GetConnection() to put up a message in the
		ConnectionsWind as the connection opens.  (A)

		Changed NewsgroupWind constructor and MessageReceived() to add
		"Select All" menu item.

		Changed SubjectsView::KeyDown() to add 'A' key shortcut ("Select All").

		Changed Newsgroup::GetOneHeaderRange() to be slightly more efficient when
		adding a new subject to the tree (it no longer adds it to the filter tree,
		removes it, and then adds it back).

		Changed SubjectFilterAdaptor (in SubjectFilterTree) so it takes the subject
		into account if the filter score and date are the same, so it doesn't
		confused two subjects which would otherwise be considered the same.

		Changed ConnectionsView constructor to set the the view color to
		B_TRANSPARENT_32_BIT.  Since the view touches all pixels anyway, it doesn't
		need the background cleared on update, and this makes it flash less.

		Changed SubjectTreeAdaptor::SetupColors() to use an explicit white
		"bgndColor" instead of the view color for the unhilited, unfiltered
		background color.

		Changed the SubjectsView constructor to set the view color to
		B_TRANSPARENT_32_BIT.  Changed SubjectTreeAdaptor::Draw() to clear the
		expander area and the article indent area.  This reduces flashiness--
		somewhat.  (B)

9/15/98	Added to SubjectView::KeyDown() to make the spacebar work more like
		it does in MT-Newswatcher.  Included adding OpenArticle() private method.  (A)

		Changed OpenArticleThread::Action() to pass the "spacebarCanClose" field
		of the B_REFS_RECEIVED message to the viewer app.  (B)

		Added 'W' key shortcut to SubjectView::KeyDown().

9/14/98	Added Filter::EditString(), moving the code from MouseDown().

		Added FilterGroup::EditFilterString().

		Changed FiltersView::MessageReceived() to start editing the string of
		the new filter when one is added.  (A)

		Created SubjectsView and made NewsgroupWind use it.  SubjectsView::KeyDown()
		so far handles the left and right arrow keys.  (B)

		Made SubjectsView::KeyDown() handle 'M' and 'U' keys for marking and
		unmarking articles.

		Add progress support to NNTPConnection.

		Created ConnectionsWind and ConnectionsView.

		Made ConnectionPool create and handle the ConnectionsWind.

		Made GetGroupStatsThread report progress.

		Made OpenGroupThread and Newsgroup::ReadHeaders() report progress.  This
		definitely needs work.

		Added ArticleSet::NumArticles() and NumArticlesIn().

		Changes to Newsgroup::ReadHeaders() and GetOneHeaderRange() to make progress
		updating much better.

		Changed ConnectionsWind constructor to put the window in the bottom-right
		corner of the screen.  (C)

		Changed ConnectionsWind::NumConnectionsChanged() to hide and show the window.
		Changes to ConnectionPool to send it a message rt calling it directly, to
		avoid deadlocks.

		Added ConnectionPool::HavePool().

		Made NNTPApp::WindowClosing() account for the ConnectionsWind.

		Rewrote ConnectionsWind::Draw() to draw the progress bars in two halves,
		so text can remain antialiased.  (Also rewrote AttachedToWindow() so it no
		longer turns off anti-aliasing.)

		Changed ConnectionsWind constructor to set the B_NOT_CLOSABLE flag, since
		closing the window can cause a crash currently.

		Made ConnectionsWind::NumConnectionsChanged() to resize the window.  Also
		added FrameMoved() to update the new "windBottom" and "growsUp" ivars.

		Changed ConnectionsWind constructor and destructor to save and restore
		window position & size.  (D)

		Changed ConnectionPool::GetConnection() to get rid of the connection and
		return NULL if the connection couldn't open.  Still have a problem with
		the app not quitting.

		Changed ConnectionsWind constructor to immediately hide the window after
		showing it, so it doesn't pop up until something happens.  Can't just leave
		it hidden because it takes that first Show() call to start up the message
		loop.  (E)

9/13/98	In Filter, moved "actionStrings" and "headerStrings" static variables from
		Draw() to the class.  Made MouseDown() use them.

		Added support for saving the filters:  Added Filter::WriteToFile() and
		Filters::Save() and WriteFilterGroup().

		Added reading filters:  Filters::Load(), Filter::ReadFrom() and IndexFor().

		Added "Show Filters" menu item to NewsgroupsWind.  Changed constructor
		and added NNTPApp::ReadyToRun().

		Added "Newsgroups" menu to NewsrcWind.  Changes to constructor.  (A)

9/12/98	Created AddGroupDlog.

		Changes to FiltersView and FiltersWind to support adding groups.  (Still a
		test version.)  (A)

		Made AATreeListView::ItemDisplayChanged() update the scrollbar and invalidate
		the view.

		Made FiltersView::MessageReceived() handle adding a new filter.  (Still a
		test version.)  (B)

9/10/98	Added string_slice::containsCI().

		Added Article::SetFilterScore().

		Created FilterGroup and Filter.

		Created DamnListableObject to work around the fact that Castle Yankee
		doesn't support operator overloading and ListableObject requires it.

		Created Filters, FiltersView, and FiltersWind.

		Fixed ListableTree::YAtIndex(), which would sometimes try to read the
		"displayHeight" field of "nullNode", which doesn't have such a field.
		Same for IndexForY() and YForObject().

		Filled in the new objects to the point where some testing can take place.
		This backup is of a test version.  (A)

		Added string editing to FiltersView, including additions to
		Filter::MouseDown().  (Still a test version.)  (B)

		Changed FiltersWind constructor and destructor to save and restore the
		window position.

		Changed SubjectTreeAdaptor::SetupColors(), DrawSubject(), and DrawArticle()
		to pay attention to filtering.

		Wrote FilterGroup::ApplyFilters().

		Changed Newsgroup::ReadArticleCache() and GetOneHeaderRange() to do
		filtering.

		Changed SubjectFilterAdaptor::operator<() to sort the filter scores in
		descending order.

		Changed SubjectTreeAdaptor::Draw() and tweex so selected or hilited
		articles have the background indented.  (Still a test version.)  (C)

9/9/98	Made opening a newsgroup "live"; that is, the window comes up right away
		and the subjects fill in as the user watches (and potentially starts reading
		articles).  Changes included:  Added SubjectTree::AdaptorFor() and Remove().
		Added NewsgroupWind::SubjectChanged() and NumSubjectsChanged().  Changes to
		Newsgroup::ReadArticleCache() and GetOneHeaderRange() to lock and update the
		window.  Changed OpenGroupThread::Action() to do things in the right order.

		Changed Newsgroup::GetOneHeaderRange() to get rid of the "maxHeadersToRead"
		stuff.  (A)

		Changed NewsgroupsView::DrawItem() so that if the number of articles is
		greater than 9999, it just shows the thousands ("k").

		Changed ScrolledListView::KeyDown() to open the selected item when the
		spacebar is hit.

		Changed AATreeListView::KeyDown() to fix operation of up and down arrow keys
		when nothing is selected (it crashed before).

		Changed AATreeListView::Draw() to always set the low color to white before
		clearing blank space at the bottom of the list.  (B)

9/8/98	Added "selected" ivar and accessor methods to Subject.

		Made AATreeListView::MouseDown() call ListableTree::ObjectChanged() and
		check for height change.

		Added ListableObject::DrawExpander() and TrackExpander().

		Changes to SubjectTreeAdaptor to support expansion.  (A)

		Added AATreeListView::ItemDisplayChanged();

		Changes to SubjectTreeAdaptor, especially MouseDown(), to support
		multiple selections.

		Rewrote SubjectTreeAdaptor::Open() (moving some code to the new private
		method OpenArticle()) to handle article selection.  (B)

		Added AATree::UpdateAllObjects().

		Added "selected" and accessors to Article.

		Changes to SubjectTreeAdaptor to save article selection state in
		Article.  (C)

		Made marking and unmarking of articles work (again).  Added
		Subject::MarkSelected() and NewsgroupWind::MarkSelected(), and
		changed NewsgroupWind::MessageReceived.  (D)

9/7/98	Added selection stuff to ListableObject, and changed ListableTreeNode to
		keep a count of selected items, not just a boolean indicating if there is
		one.

		Added AATree::ObjectChanged() (and it's private counterpart, ObjectChangedIn()).

		Added selection operations to ListableTree and AATreeListView.

		Wrote rudimentary SubjectTreeAdaptor::MouseDown().  (A)

		Added SubjectTreeAdaptor::Open(), plus whatever other changes were needed
		to make opening work...

		Added AATree::IndexOf().

		Moved DisplayHeight() virtual method from OrderedObject to ListableObject.

		Made AATreeListView::KeyDown() handle up and down arrows.  Included adding
		ScrollToSelection() method.

		Fixed string_slice::operator<(), which was returning the wrong thing when
		the other slice was shorter (but otherwise identical) than "this".  (B)

		Fixed AATree::InsertObject(), which was making an AATreeNode instead of
		calling MakeNode().  Boy I'm surprised it worked at all before!

		Fixed AATree::ObjectChangedIn(), which was touching every node instead of
		just the ones on the path to the object.  (C)

		Added AATreeListView::SetTree() and Tree().

		Added NewsgroupWind::MenusBeginning().

9/6/98	Added display capability to OrderedObject and AATree (not yet tested).  (A)

		Added AATree::YForObject().

		Created AATreeListView (not yet tested).  (B)

		Rewrote SubjectTreeAdaptor, making it a subclass of ListableObject and
		making it its own module (it was in the .h preamble of SubjectTree before).

		Added SubjectTree() and FilterTree() access methods to Newsgroup.

		Changes to NewsgroupWind (on a semi-experimental basis) to use AATreeListView.

		Fixed displayHeight updating in AATree::InsertNodeAt(), which had been
		using "newNode->displayHeight" instead of "newNode->object->DisplayHeight()".
		That failed whenever the newNode got promoted, thereby making its total
		displayHeight greater than its object's displayHeight.  (C)

		Moved all the display stuff from AATree, OrderedObject, AATreeNode to
		ListableTree, ListableObject, ListableTreeNode, with appropriate changes
		to AATree to allow subclassing of this type.  (D)

9/5/98	Fixed ArticleSet::AddRange() to merge adjacent ranges.

		Added ArticleSet::MakeEmpty() and Incorporate().

		Changed Newsgroup::GetOneHeaderRange() to mark expired articles as read,
		and to delete responses with no headers rather than adding them to
		"headersResponses".  (A)

9/3/98	Beefed up error reporting in NNTPConnection, and in
		ConnectionPool::GetConnection().

		Changed Error module to display error codes as strings.

		Fixed NNTPResponse::SpillBuffer() to work correctly when the first
		buffer is at the end of the line.

		Fixed NNTPConnection::ReadBuffer() to correctly handle zero-length
		reads.

		Changed NNTPConnection constructor to pay attention to the connection
		response.

		Changed ConnectionPool::MaxConnections() to return 4, the apparent max
		on my server.  (A)

		Made Thread::ThreadStarter() delete the thread when it's finished, fixing
		a memory leak.  I thought I'd done this before!

		Created OwnedThread and ThreadOwner.

		Made NewsrcWind a ThreadOwner, and GetGroupStatsThread an OwnedThread.

		Made OpenGroupThread an OwnedThread, changing
		NewsgroupsView::OpenSelectedItem() to invoke it properly.  Changed Action()
		to check for stop request, but the big work is in Newsgroup::ReadHeaders().

		Rewrote ThreadOwner::KillOwnedThreads() to work better:  first it tells
		all the threads to stop, then it waits for them, instead of waiting for
		each to die before telling the next to stop.  There's still a slight
		race condition there though.  I didn't get to test this yet because I
		suddenly can't connect to my ISP.  (B)

		Added "stopRequested" arg to Newsgroup::ReadHeaders(), and made
		OpenGroupThread::Action() pass it.  This makes quitting much quicker.

		Added FileNames module, and made Prefs use it.

		Added TextReader module.

		Header caching done:  Added WriteArticleCache() and ReadArticleCache()
		methods to Newsgroup, with approriate changes to OpenGroupThread::Action()
		and Newsgroup::Close().  (C)

		Added menu to NewsgroupWind with Mark and Unmark items.  Changes to
		BaseListItem, SubjectListItem, ArticleListItem, Newsgroup.  (D)

		Changed NewsgroupWind constructor so the list allows multiple selections,
		and changed MessageReceived() to handle marking/unmarking a multiple
		selection.  (E)

9/2/98	Added ScrolledListView, copying it from Castle Yankee.  (A)

		Created Newsrc, including writing Read() but not Save().

		Beefed up Newsgroups:  Added "readArticles".  Replaced "firstArticle"/
		"lastArticle" pair with "availableArticles" IntRange.  Changed "groupName"
		from a string_slice to a qstring.  Added NumUnreadArticles() and
		CalcNumUnreadArticles().

		Added operator&() to IntRange.  (B)

		Created NewsgroupsView and NewsrcWind.

		Created Error module.

		Created OpenNewsrcThread.

		Added qstring(int) constructor.

		Changed ScrolledListView::KeyDown() to properly handle up-arrow when the
		first item is selected.  (C)

		Added ScrolledListView::InvalidateItem() and
		NewsrcWind::InvalidateNewsgroupAt().

		Made OpenNewsrcThread::Action() read the group stats.  But this is the
		wrong place for it--what if the window is closed while it's still going?

		Debugging and fleshing-out of the above.  (D)

		Created GetStatsThread, moving code there from OpenNewsrcThread.  Made
		NewsrcWind use it.  (E)

		Added Newsgroup::HaveAvailableArticlesInfo().

		Changed OpenGroupThread to take a Newsgroup object instead of just the
		group's name, and to use Error.

		Changed NewsgroupWind destructor so it doesn't delete the newsgroup.

		Made Newsgroup::SetReadArticles() mark expired articles as read, just as
		SetAvailableArticles() does.  (F)

		Made Newsgroup know its current window, made NewsgroupWind tell it,
		made NewsgroupsView::OpenSelectedItem() check it.

		Added Newsgroup::Close(), and made NewsgroupWind destructor call it.

		Made Newsgroup destructor close its window if one is open.  (G)

		Added IntRange::Size().

		Rewrote Newsgroup::ReadHeaders() to actually read the headers for unread
		articles.  Included changing "headerRespnse" ivar (an NNTPResponse) to
		"headersResponses" (a BList if NNTPResponses), and adding GetOneHeaderRange()
		private method.

		Fixed NNTPResponse::IsFinalBuffer() to handle the case where the final
		line of a multiline response is the only line in its buffer.

		Changed Open() virtual method of BaseListItem and subclasses to take
		a Newsgroup rt a string_slice with the newsgroup's name.

		Added Newsgroup::ArticleRead() and made OpenArticleThread call it.

		Made Article constructor initialize "read".  (H)

		Added Newsrc::Save() and made destructor call it.

		Wrote the real version of OpenArticleThread::ExtractMessageID().  Included
		adding ParseHeader() private method.

		Fixed a bug in Newsrc::ParseLine(), which wasn't getting the articleSet
		correctly (it was starting it with the colon).  (I)

		Changed OpenArticleThread::Action() to use the Error module.

9/1/98	Changed NewsgroupWind constructor to select the first item in the list.

		Added support for getting items by index to AATree.  (A)

		Added asInt() methods to qstring and string_slice.

		Added AddRange(), RemoveRange(), AddArticles(), and AsString() methods to
		ArticleSet.

		Added "date" field to Article and "minArticleDate" field to Subject.

		In Article and Subject, changed everything called "filterValue" to
		"filterScore".

		Created SubjectFilterTree.

		Made MakeAdaptor() virtual method of SubjectTree and subclasses return
		a SubjectTreeAdaptor instead of an OrderedObject.

		Added NumSubjects() and SubjectAt() methods to SubjectTree.

		Added "filterTree" to Newsgroup, and made ReadHeaders() build it and
		FillList() use it.  (B)

8/30/98	Added DeleteNode() method to AATree.

		Created ArticleSet and its associated classes, IntRange and IntRangeTree.  (A)

		Debugging of AATree::DeleteNode().  Swapping the lastNode with the
		deleted node is intractable due to all the pointers/references.  A new
		approach is needed.  (B)

		Okay, redid that (actually, there was a bug I found that meant maybe I
		could have made it work as it was, but it's good that it's cleaner now).
		Node instead of users/subclasses of AATree having to make subclasses of
		AATreeNode, they make a subclass OrderedObject and store objects of that
		type.  Adaptors can be used, as they are for SubjectTree & subclasses.  (C)

		Created ServerDlog and made changes to NNTPApp to use it.

8/29/98	Wrote ConnectionPool.  (And tested it.)  (B)

		In qstring, added various operators taking a string_slice as an argument.

		Started work on OpenGroupThread, changing Main to test it.  (C)

		Added Newsgroup::ReadHeaders().  This is just a test version for now
		(since we can't yet tell it the set of articles to get), but it does do
		the XOVER and build up the subjects and articles.  (D)

		Created NNTPApp and changed Main to use that.

		Created NewsgroupWind, along with its BListItem descendents, and made
		OpenGroupThread open it.

		Added qstring operator+=(int).  (E)

		Added OpenArticleThread, and made (new) NewsgroupWind::MessageReceived()
		(indirectly) use it.  (F)

		Added SubjectListItem::Open().

		Changed BaseListItem::Open() and subclasses versions to return a bool
		which indicates whether to select the next item in the list.  Made
		NewsgroupWind::MessageReceived() do that.  (G)

		Made DrawItem() methods of SubjectListItem and ArticleListItem display
		a mark indicating if the articles are read.  (H)

8/28/98	Finished and debugged NNTPConnection & NNTPResponse.  Test app talks to
		the server just fine!

		Created Subject, Article, and Newsgroup classes (but they're incomplete).
		Same with ConnectionPool.

		Created AATree, but it doesn't support all operations yet.  Created
		SubjectTree and SubjectSubjectTree subclasses.

8/27/98	Began project with work on NNTPConnection and NNTPResponse.
]]></method>

</class>


<class mod-time="Fri, 14 Apr 2000 18:09:37 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
"Main"
</name>
</class>


<class mod-time="Sat, 08 Apr 2000 08:39:07 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Main
</name>
<cppIncludes><![CDATA[
#include "NNTPApp.h"
#include "NNTPConnection.h"
#include "NNTPResponse.h"
#include "SubjectSubjectTree.h"
#include "Subject.h"
#include "ConnectionPool.h"
#include "OpenGroupThread.h"
#include "ArticleSet.h"
#include "Prefs.h"
#include <stdio.h>

extern void ArticleSetTest();
extern void PrintArticleSet(ArticleSet* set);
extern void PrintResponseData(NNTPResponse* response);
extern void SubjectTest(NNTPResponse* response);
extern void ContainsCITest();
extern void TestContains(const char* container, const char* contained);

int main()
{
//***	Prefs()->SetStringPref("nntpServer", "news.95net.com");
/***
	OpenGroupThread* thread = new OpenGroupThread("rec.audio.pro");
	thread->Go();

	thread->WaitFor();
***/

//*** test
/***
	ArticleSetTest();
	return 0;
***/

	// run the app
	new NNTPApp();
	be_app->Run();
	delete be_app;

	// clean up
	ConnectionPool::DeletePool();
	Preferences::DeletePreferences();
}


void ArticleSetTest()
{
	ArticleSet set;

	set.AddArticle(1);
	PrintArticleSet(&set);
	set.AddArticle(3);
	PrintArticleSet(&set);
	set.AddArticle(5);
	PrintArticleSet(&set);
	set.AddArticle(7);
	PrintArticleSet(&set);
	set.AddArticle(11);
	PrintArticleSet(&set);
	set.AddArticle(13);
	PrintArticleSet(&set);
	set.AddArticle(4);
	PrintArticleSet(&set);
	set.AddArticle(6);
	PrintArticleSet(&set);
	set.AddArticle(8);
	PrintArticleSet(&set);
	set.AddArticle(10);
	PrintArticleSet(&set);
	set.AddArticle(12);
	set.AddArticles("1-7,34,53-68,149");
	PrintArticleSet(&set);
	bool hasArticle = set.ContainsArticle(3);
	hasArticle = set.ContainsArticle(7);
	hasArticle = set.ContainsArticle(6);
}

void PrintArticleSet(ArticleSet* set)
{
	qstring* str = set->AsString();
	printf("%s\n", str->c_str());
	delete str;
/***
	bool needsComma = false;
	int numRanges = set->NumRanges();
	for (int i=0; i<numRanges; i++) {
		IntRange range = set->RangeAt(i);
		if (needsComma)
			printf(",");
		needsComma = true;
		if (range.min == range.max)
			printf("%d", range.min);
		else
			printf("%d-%d", range.min, range.max);
		}
	printf("\n");
***/
}


#ifdef NOT_ANYMORE
static void OldTest()
{
	NNTPResponse* response;
	char cmdStr[256];

	// open connection
//***	NNTPConnection* connection = new NNTPConnection("news.95net.com");
	Prefs()->SetStringPref("nntpServer", "news.95net.com");
	NNTPConnection* connection = ConnectionPool::GetPool()->GetConnection();

	// get the group
	connection->SendCommand("group rec.audio.pro");
	printf("Sent GROUP.  Response: %d\n", connection->GetResponse(&response));
	int numArticles = response->NextIntField();
	int firstArticle = response->NextIntField();
	int lastArticle = response->NextIntField();
	printf("\tNum: %d, First: %d, Last: %d\n", numArticles, firstArticle, lastArticle);
	delete response;

	// XOVER for last ten articles
	sprintf(cmdStr, "xover %d-%d", lastArticle-60, lastArticle);
	connection->SendCommand(cmdStr);
	int result = connection->GetResponse(&response);
	printf("Sent XOVER.  Response: %d\n", result);
	if (result == 224) {
/***
		PrintResponseData(response);
		printf("\n");
		response->Reset();
***/
		printf("==================================\n");
		SubjectTest(response);
		printf("==================================\n");
		delete response;
		}

	// read the last article
/***
	sprintf(cmdStr, "article %d", lastArticle);	// 242316 was one with a problem, now fixed
	connection->SendCommand(cmdStr);
	result = connection->GetResponse(&response);
	printf("Sent ARTICLE.  Response: %d\n", result);
	if (result == 220) {
		PrintResponseData(response);
		delete response;
		}
***/

	// get & use a second connection
	NNTPConnection* connection2 = ConnectionPool::GetPool()->GetConnection();
	connection2->SendCommand("group soc.history.war.world-war-ii");
	printf("Sent GROUP.  Response: %d\n", connection2->GetResponse(&response));
	numArticles = response->NextIntField();
	firstArticle = response->NextIntField();
	lastArticle = response->NextIntField();
	printf("\tNum: %d, First: %d, Last: %d\n", numArticles, firstArticle, lastArticle);
	delete response;

	// close connection
	ConnectionPool::GetPool()->ReleaseConnection(connection);
	ConnectionPool::GetPool()->ReleaseConnection(connection2);
	ConnectionPool::DeletePool();
/***
	connection->SendCommand("quit");
	printf("Sent QUIT.  Response: %d\n", connection->GetResponse());
	delete connection;
***/
}
#endif


void PrintResponseData(NNTPResponse* response)
{
	if (response == NULL)
		return;

	response->NextLine();

	while (!response->AtEOF()) {
		string_slice line = response->NextLine();
		fwrite(line.begin(), line.length(), 1, stdout);
		printf("\n");
		}
}



	static void WriteSubjectSubject(Subject* subject, void* data)
	{
		string_slice subj = subject->GetSubject();
		fwrite(subj.begin(), subj.length(), 1, stdout);
		printf("\n");
	}

void SubjectTest(NNTPResponse* response)
{
	SubjectSubjectTree	subjectTree;

	response->NextLine();

	// get the subjects
	while (!response->AtEOF()) {
		// get the subject from the XOVER response
		response->NextTabField();	// skip articleNo
		string_slice subject = response->NextTabField();
		response->NextLine();
		if (subject.length() == 0)
			continue;

		// trim "Re:"
		const char* p = subject.begin();
		const char* stopper = subject.end();
		while (p < stopper) {
			// skip whitespace
			for (; p < stopper; p++) {
				if (*p != ' ' && *p != '\t')
					break;
				}
			// check for "Re"
			if (p > stopper - 3)
				break;
			if ((*p == 'R' || *p == 'r') && (p[1] == 'e' || p[1] == 'E') && p[2] == ':')
				p += 3;
			else
				break;
			}
		subject = string_slice(p, subject.end());

		// add to the subjects if it's not already there
		if (subjectTree.Find(subject) == NULL)
			subjectTree.Insert(new Subject(subject));
		}

	// write the subjects
	subjectTree.Walk(WriteSubjectSubject, NULL);
}


void ContainsCITest()
{
	TestContains("Gabe Wiener", "wiener");
	TestContains("Gabe Wiener", "weiner");
	TestContains("Gabe Wiener", "gabe");
	TestContains("Gabe Wiener", "garb");
}


void TestContains(const char* container, const char* contained)
{
	printf("\"%s\" contains \"%s\": %s\n", container, contained,
	       (string_slice(container).containsCI(string_slice(contained)) ? "true" : "false"));
}

]]></cppIncludes>
</class>


<class mod-time="Sun, 18 Jun 2000 22:20:42 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
NNTPApp
</name>
<superclasses>
public BApplication, public ThreadOwner
</superclasses>
<hIncludes><![CDATA[
#include "ThreadOwner.h"
#include <Application.h>

class Filters;
class AllGroupsList;
class GroupsList;
class FiltersWind;
class GroupsListWind;
class PrefsDlog;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Filters.h"
#include "AllGroupsList.h"
#include "FiltersWind.h"
#include "AllGroupsWind.h"
#include "NewGroupsWind.h"
#include "PrefsDlog.h"
#include "OpenNewsrcThread.h"
#include "OpenGroupThread.h"
#include "SaveArticleThread.h"
#include "PostArticlesThread.h"
#include "GetNewGroupsThread.h"
#include "ServerDlog.h"
#include "TasksWind.h"
#include "Messages.h"
#include "Prefs.h"
#include <Entry.h>
#include <Message.h>
#include <File.h>
#include <FilePanel.h>
#include <Screen.h>
#include <Alert.h>
#include <Path.h>
#include <NodeInfo.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Mon, 17 Apr 2000 19:37:49 PDT"><![CDATA[
NNTPApp()
	: BApplication("application/x-vnd.Folta-NNTPTest"),
	  allGroupsList(NULL), newGroupsList(NULL), haveOpenedFile(false),
	  filtersWind(NULL), allGroupsWind(NULL), newGroupsWind(NULL), prefsWind(NULL),
	  appendArticlesPanel(NULL), saveArticlesPanel(NULL)
{
	// set up the filters
	filters = new Filters();
}
]]></method>

<method access="public" mod-time="Mon, 17 Apr 2000 19:33:54 PDT"><![CDATA[
~NNTPApp()
{
	delete filters;
	delete allGroupsList;
	delete newGroupsList;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"BApplication virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void RefsReceived(BMessage* message)
{
	if (!SetupServer()) {
		Quit();
		return;
		}

	entry_ref ref;
	for (int i=0; ; i++) {
		if (message->FindRef("refs", i, &ref) != B_NO_ERROR)
			break;
		OpenNewsrcThread* thread = new OpenNewsrcThread(&ref);
		thread->Go();
		}

	haveOpenedFile = true;
}
]]></method>

<method access="public" mod-time="Sun, 18 Jun 2000 22:20:42 PDT"><![CDATA[
void ReadyToRun()
{
	// setup server
	if (!SetupServer()) {
		Quit();
		return;
		}

	// open "My Newsgroups"
	if (!haveOpenedFile) {
		// open default "My Newsgroups" file
		static const char* newsrcPath = "/boot/home/My Newsgroups";
		// open the file in order to create it if it doesn't exist
		BEntry newsrcEntry(newsrcPath);
		if (!newsrcEntry.Exists()) {
			BFile newsrcFile(&newsrcEntry, B_READ_WRITE | B_CREATE_FILE);
			// set the MIME type
			BNode node(&newsrcEntry);
			BNodeInfo nodeInfo(&node);
			nodeInfo.SetType("text/x-newsrc");
			}
		// open the file in a window
		entry_ref newsrcRef;
		newsrcEntry.GetRef(&newsrcRef);
		OpenNewsrcThread* thread = new OpenNewsrcThread(&newsrcRef);
		thread->Go();
		}

	// check for new groups
	int32 lastGroupsUpdateTime = Prefs()->GetInt32Pref("lastGroupsUpdateTime");
	if (lastGroupsUpdateTime != 0) {
		GetNewGroupsThread* newGroupsThread = new GetNewGroupsThread();
		newGroupsThread->Go();
		}
	else {
		// otherwise, get the full groups list
		// Set "lastGroupsUpdateTime" just in case there was an old version,
		// cause if we don't, it'll never get set and the allGroupsList will
		// be read on startup every time.  We set it to zero to make sure
		// any new groups created since the full group list was created will
		// show up.
		Prefs()->SetInt32Pref("lastGroupsUpdateTime", 0);
		GetAllGroupsList();
		}

//*** test
//*** OpenFiltersWind();

//*** test
/***
	OpenGroupThread* thread = new OpenGroupThread("rec.audio.pro");
	thread->Go();
***/
}
]]></method>

<method access="public" mod-time="Mon, 17 Apr 2000 18:28:15 PDT"><![CDATA[
void MessageReceived(BMessage* message)
{
	switch (message->what) {
		case ShowFiltersMessage:
			OpenFiltersWind();
			break;

		case ShowGroupsListMessage:
			OpenAllGroupsWind();
			break;

		case ShowPrefsMessage:
			OpenPrefsWind();
			break;

		case ShowAboutMessage:
			ShowAbout();
			break;

		case AppendArticlesMessage:
			AppendArticles(message);
			break;

		case SaveArticlesMessage:
			SaveArticles(message);
			break;

		case PostArticlesMessage:
			PostArticles(message);
			break;

		default:
			BApplication::MessageReceived(message);
			break;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void OpenFiltersWind()
{
	if (filtersWind)
		filtersWind->Activate();
	else
		filtersWind = new FiltersWind();
}
]]></method>

<method access="public" mod-time="Mon, 17 Apr 2000 18:28:04 PDT"><![CDATA[
void OpenAllGroupsWind()
{
	if (allGroupsWind)
		allGroupsWind->Activate();
	else
		allGroupsWind = new AllGroupsWind();
}
]]></method>

<method access="public" mod-time="Mon, 17 Apr 2000 19:38:28 PDT"><![CDATA[
void OpenNewGroupsWind()
{
	if (newGroupsWind)
		newGroupsWind->Activate();
	else
		newGroupsWind = new NewGroupsWind();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void OpenPrefsWind()
{
	if (prefsWind)
		prefsWind->Activate();
	else
		prefsWind = new PrefsDlog();
}
]]></method>

<method access="public" mod-time="Mon, 17 Apr 2000 18:28:45 PDT"><![CDATA[
void WindowClosing(BWindow* wind)
{
	// manage owned windows
	if (wind == filtersWind)
		filtersWind = NULL;
	else if (wind == allGroupsWind)
		allGroupsWind = NULL;
	else if (wind == prefsWind)
		prefsWind = NULL;
	else if (appendArticlesPanel != NULL && wind == appendArticlesPanel->Window())
		appendArticlesPanel = NULL;
	else if (saveArticlesPanel != NULL && wind == saveArticlesPanel->Window())
		saveArticlesPanel = NULL;

	// quit if all windows are closed
	int numWindows = CountWindows();
	if (TasksWind::HaveTasksWind())
		numWindows -= 1;	// ignore tasks window
	if (appendArticlesPanel)
		numWindows -= 1;	// ignore appendArticlesPanel
	if (saveArticlesPanel)
		numWindows -= 1;	// ignore saveArticlesPanel
	if (numWindows <= 1)
		Quit();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ShowAppendArticlesPanel(BMessage* message)
{
	// create the panel if it doesn't yet exist
	if (appendArticlesPanel == NULL) {
		// make the panel, having it show the saved directory
/***
		entry_ref* appendDir = Prefs()->GetRefPref("savedArticlesDir");
		appendArticlesPanel =
			new BFilePanel(B_OPEN_PANEL, NULL, appendDir, B_FILE_NODE, false);
***/
		appendArticlesPanel =
			new BFilePanel(B_OPEN_PANEL, NULL, NULL, B_FILE_NODE, false);
		const char* savedArticlesDirPath = Prefs()->GetStringPref("savedArticlesDir");
		if (savedArticlesDirPath)
			appendArticlesPanel->SetPanelDirectory(savedArticlesDirPath);

		// restore to saved position
		BWindow* panelWind = appendArticlesPanel->Window();
		BRect savedFrame = Prefs()->GetRectPref("savedArticlesPanelFrame");
		if (savedFrame.IsValid()) {
			if (BScreen(panelWind).Frame().Contains(savedFrame)) {
				panelWind->MoveTo(savedFrame.LeftTop());
				panelWind->ResizeTo(savedFrame.Width(), savedFrame.Height());
				}
			}

		// set the title
		panelWind->SetTitle("Append Article To:");
		}

	// set it up and show it
	message->what = AppendArticlesMessage;
	appendArticlesPanel->SetMessage(message);
	appendArticlesPanel->Show();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ShowSaveArticlesPanel(BMessage* message)
{
	// create the panel if it doesn't yet exist
	if (saveArticlesPanel == NULL) {
		// make the panel, having it show the saved directory
		saveArticlesPanel =
			new BFilePanel(B_SAVE_PANEL, NULL, NULL, B_FILE_NODE, false);
		const char* savedArticlesDirPath = Prefs()->GetStringPref("savedArticlesDir");
		if (savedArticlesDirPath)
			saveArticlesPanel->SetPanelDirectory(savedArticlesDirPath);

		// restore to saved position
		BWindow* panelWind = saveArticlesPanel->Window();
		BRect savedFrame = Prefs()->GetRectPref("savedArticlesPanelFrame");
		if (savedFrame.IsValid()) {
			if (BScreen(panelWind).Frame().Contains(savedFrame)) {
				panelWind->MoveTo(savedFrame.LeftTop());
				panelWind->ResizeTo(savedFrame.Width(), savedFrame.Height());
				}
			}

		// set the title
		panelWind->SetTitle("Save Article To:");
		}

	// set it up and show it
	saveArticlesPanel->SetSaveText(message->FindString("subjects"));
	message->what = SaveArticlesMessage;
	saveArticlesPanel->SetMessage(message);
	saveArticlesPanel->Show();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ShowAbout()
{
	static const char* aboutText =
		"Item\nA newsreader\n© 1999 Steve Folta\nBuild date: ";

	qstring msg = aboutText;
	msg += __DATE__ " " __TIME__;
	BAlert* alert = new BAlert("About Item", msg.c_str(), "OK");
	alert->Go();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Access"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Filters* GetFilters()
{
	return filters;
}
]]></method>

<method access="public" mod-time="Mon, 17 Apr 2000 18:29:30 PDT"><![CDATA[
AllGroupsList* GetAllGroupsList()
{
	if (allGroupsList == NULL)
		allGroupsList = new AllGroupsList();
	return allGroupsList;
}
]]></method>

<method access="public" mod-time="Mon, 17 Apr 2000 19:29:07 PDT"><![CDATA[
GroupsList* GetNewGroupsList()
{
	if (newGroupsList == NULL)
		newGroupsList = new GroupsList();
	return newGroupsList;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool SetupServer()
{
	if (Prefs()->GetStringPref("nntpServer")[0] == 0) {
		ServerDlog* serverDlog = new ServerDlog();
		return serverDlog->Go();
		}
	else
		return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AppendArticles(BMessage* message)
{
	// get the data out of the message
	entry_ref ref;
	status_t result = message->FindRef("refs", &ref);
	if (result != B_NO_ERROR)
		return;

	// take this opportunity to set the "savedArticlesDir" and
	// "savedArticlesPanelFrame" prefs
	BEntry entry(&ref);
	entry.GetParent(&entry);
/***
	entry_ref dirRef;
	entry.GetRef(&dirRef);
	Prefs()->SetRefPref("savedArticlesDir", &dirRef);
***/
	BPath dirPath;
	entry.GetPath(&dirPath);
	Prefs()->SetStringPref("savedArticlesDir", dirPath.Path());
	if (appendArticlesPanel)
		Prefs()->SetRectPref("savedArticlesPanelFrame", appendArticlesPanel->Window()->Frame());

	// spawn threads to do the work
	(new SaveArticleThread(message))->Go();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SaveArticles(BMessage* message)
{
	// get the data out of the message
	entry_ref dirRef;
	status_t result = message->FindRef("directory", &dirRef);
	if (result != B_NO_ERROR)
		return;
	BDirectory dir(&dirRef);
	BEntry entry(&dir, message->FindString("name"));
	entry_ref ref;
	entry.GetRef(&ref);

	// add the "refs" entry to the message
	message->AddRef("refs", &ref);

	// create the file, delete existing data, set the MIME type
	{
		BFile file(&ref, B_READ_WRITE | B_CREATE_FILE | B_ERASE_FILE);
		BNodeInfo(&file).SetType("text/plain");
	}

	// take this opportunity to set the "savedArticlesDir" and
	// "savedArticlesPanelFrame" prefs
	BEntry dirEntry(&dirRef);
	BPath dirPath;
	dirEntry.GetPath(&dirPath);
	Prefs()->SetStringPref("savedArticlesDir", dirPath.Path());
	if (saveArticlesPanel)
		Prefs()->SetRectPref("savedArticlesPanelFrame", saveArticlesPanel->Window()->Frame());

	// spawn threads to do the work
	(new SaveArticleThread(message))->Go();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void PostArticles(BMessage* message)
{
	status_t result;

	// file the list of file refs
	BList* fileRefs = new BList();
	for (int i=0; ; i++) {
		entry_ref ref;
		result = message->FindRef("refs", i, &ref);
		if (result != B_NO_ERROR)
			break;
		fileRefs->AddItem(new entry_ref(ref));
		}
	if (fileRefs->CountItems() == 0)
		return;

	// post
	StartThread(new PostArticlesThread(fileRefs));
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Filters* filters;
]]></variable>

<variable access="protected" mod-time="Mon, 17 Apr 2000 18:26:16 PDT"><![CDATA[
AllGroupsList* allGroupsList;
]]></variable>

<variable access="protected" mod-time="Mon, 17 Apr 2000 19:28:43 PDT"><![CDATA[
GroupsList* newGroupsList;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool haveOpenedFile;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
FiltersWind* filtersWind;
]]></variable>

<variable access="protected" mod-time="Mon, 17 Apr 2000 18:28:22 PDT"><![CDATA[
GroupsListWind* allGroupsWind;
]]></variable>

<variable access="protected" mod-time="Mon, 17 Apr 2000 19:37:38 PDT"><![CDATA[
GroupsListWind* newGroupsWind;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
PrefsDlog* prefsWind;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BFilePanel* appendArticlesPanel;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BFilePanel* saveArticlesPanel;
]]></variable>

</class>


<class mod-time="Sat, 08 Apr 2000 09:02:46 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Newsrc
</name>
<hIncludes><![CDATA[
#include "string_slice.h"
#include <SupportDefs.h>

class Newsgroup;
class NewsgroupsView;
class BFile;
class BList;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Newsgroup.h"
#include "ArticleSet.h"
#include "NewsgroupsView.h"
#include <stdio.h>
#include <File.h>
#include <List.h>
#include <Window.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Newsrc(BFile* fileIn)	// takes ownership of "file"
	: file(fileIn)
{
	newsgroups = new BList();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~Newsrc()
{
	Save();

	delete file;

	// delete the newsgroups
	int numGroups = newsgroups->CountItems();
	for (int i=0; i<numGroups; i++)
		delete (Newsgroup*) newsgroups->ItemAt(i);
	delete newsgroups;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Read()
{
	// sanity clause
	if (file == NULL || file->InitCheck() != B_NO_ERROR)
		return;

	// read the file into memory
	off_t fileSize;
	file->GetSize(&fileSize);
	char* fileText = new char[fileSize];
	file->ReadAt(0, fileText, fileSize);

	// read the file, line-by-line
	const char* p = fileText;
	const char* stopper = fileText + fileSize;
	while (p < stopper) {
		// get the line
		const char* lineStart = p;
		while (p < stopper && *p != '\n' && *p != '\r')
			p++;
		string_slice line(lineStart, p);
		if (p < stopper)
			p++;	// skip EOL
		// skip empty lines
		if (line.length() <= 0)
			continue;

		// parse the line
		string_slice groupName, articleSetStr;
		ParseLine(line, &groupName, &articleSetStr);
		if (groupName.length() <= 0)
			continue;

		// add the newsgroup
		Newsgroup* newsgroup = new Newsgroup(groupName, this);
		if (articleSetStr.length() > 0) {
			ArticleSet* readArticles = new ArticleSet();
			readArticles->AddArticles(articleSetStr);
			newsgroup->SetReadArticles(readArticles);
			}
		newsgroups->AddItem(newsgroup);
		}

	// clean up
	delete fileText;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Save()
{
	file->Seek(0, SEEK_SET);
	string_slice separator = ": ";
	string_slice lineEnd = "\r";	// for Mac-compatibility

	// write out the newsgroups
	int numNewsgroups = newsgroups->CountItems();
	for (int i=0; i<numNewsgroups; i++) {
		Newsgroup* newsgroup = (Newsgroup*) newsgroups->ItemAt(i);

		// name
		string_slice name = newsgroup->Name();
		file->Write(name.begin(), name.length());

		// separator
		file->Write(separator.begin(), separator.length());

		// articles
		ArticleSet* readArticles = newsgroup->ReadArticles();
		qstring* readArticlesStr = readArticles->AsString();
		file->Write(readArticlesStr->data(), readArticlesStr->length());
		delete readArticlesStr;

		// EOL
		file->Write(lineEnd.begin(), lineEnd.length());
		}

	// finish the file
	file->SetSize(file->Position());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void NewsgroupChanged(Newsgroup* newsgroup)
{
	int index = newsgroups->IndexOf(newsgroup);
	if (index >= 0 && view) {
		BWindow* wind = view->Window();
		if (!wind->IsHidden() && wind->Lock()) {
			view->InvalidateItem(index);
			wind->Unlock();
			}
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AttachedToView(NewsgroupsView* viewIn)
{
	view = viewIn;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Access"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int NumNewsgroups()
{
	return newsgroups->CountItems();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Newsgroup* NewsgroupAt(int index)
{
	return (Newsgroup*) newsgroups->ItemAt(index);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Newsgroup* RemoveNewsgroupAt(int index)
{
	Newsgroup* newsgroup = (Newsgroup*) newsgroups->RemoveItem(index);
	newsgroup->SetNewsrc(NULL);
	return newsgroup;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AddNewsgroupAt(Newsgroup* newsgroup, int index)
{
	newsgroups->AddItem(newsgroup, index);
	newsgroup->SetNewsrc(this);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Newsgroup* NewsgroupNamed(string_slice groupName)
{
	int numGroups = newsgroups->CountItems();
	for (int i=0; i<numGroups; i++) {
		Newsgroup* group = (Newsgroup*) newsgroups->ItemAt(i);
		if (groupName == group->Name())
			return group;
		}
	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ParseLine(string_slice line, string_slice* groupName, string_slice* articleSet)
{
	*articleSet = string_slice();	// until we find it

	// find the group name
	const char* p = line.begin();
	const char* stopper = line.end();
	bool foundGroupName = false;
	for (; p < stopper; p++) {
		char c = *p;
		if (c == ' ' || c == '\t') {
			// not a real newsrc line
			break;
			}
		if (c == ':') {
			// found the end of the name
			*groupName = string_slice(line.begin(), p);
			foundGroupName = true;
			break;
			}
		}
	if (!foundGroupName) {
		*groupName = string_slice();
		return;
		}
	p++;	// skip ':'

	// skip whitespace
	while (p < stopper && (*p == ' ' || *p == '\t'))
		p++;

	// trim trailing whitespace and set up the articleSet
	const char* articleSetStart = p;
	p = stopper - 1;
	for (; p >= articleSetStart; --p) {
		char c = *p;
		if (c != ' ' || c != '\t')
			break;
		}
	*articleSet = string_slice(articleSetStart, p + 1);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BFile* file;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BList* newsgroups;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
NewsgroupsView* view;
]]></variable>

</class>


<class mod-time="Fri, 21 Apr 2000 00:14:36 PDT" wind-frame="132.000000,96.000000,772.000000,626.000000" list-views-height="0.000000">
<name>
Newsgroup
</name>
<hIncludes><![CDATA[
#include "string_slice.h"
#include "qstring.h"
#include "IntRange.h"
#include <parsedate.h>
#include <SupportDefs.h>

class Newsrc;
class SubjectSubjectTree;
class SubjectFilterTree;
class ArticleSet;
class NNTPConnection;
class NNTPResponse;
class Subject;
class ListableTree;
class NewsgroupWind;
class Task;
class BFile;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "SubjectSubjectTree.h"
#include "SubjectFilterTree.h"
#include "ArticleSet.h"
#include "Subject.h"
#include "Article.h"
#include "NNTPConnection.h"
#include "NNTPResponse.h"
#include "TextReader.h"
#include "NewsgroupWind.h"
#include "Filters.h"
#include "FilterGroup.h"
#include "Task.h"
#include "NNTPApp.h"
#include "Newsrc.h"
#include "Prefs.h"
#include "FileNames.h"
#include <stdio.h>
#include <File.h>
#include <NodeInfo.h>
#include <Path.h>
#include <Directory.h>
#include <FindDirectory.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Newsgroup(string_slice groupNameIn, Newsrc* newsrcIn)
	: groupName(groupNameIn), newsrc(newsrcIn),
	  numUnreadArticles(0), cachedHeaderInfo(NULL), wind(NULL)
{
	readArticles = new ArticleSet();
	subjectTree = new SubjectSubjectTree();
	filterTree = new SubjectFilterTree();
	headersResponses = new BList();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~Newsgroup()
{
	if (wind)
		wind->Close();
	Close();
	delete readArticles;
	delete subjectTree;
	delete filterTree;
	delete headersResponses;
	delete cachedHeaderInfo;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetAvailableArticles(int firstArticle, int lastArticle)
{
	availableArticles = IntRange(firstArticle, lastArticle);

	// mark expired articles as read
	IntRange expiredArticles(1, firstArticle - 1);
	if (expiredArticles.IsValid())
		readArticles->AddRange(expiredArticles);

	CalcNumUnreadArticles();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetReadArticles(ArticleSet* newReadArticles)	// assumes ownership
{
	delete readArticles;
	readArticles = newReadArticles;

	// mark expired articles as read also
	IntRange expiredArticles(1, availableArticles.min - 1);
	if (expiredArticles.IsValid())
		readArticles->AddRange(expiredArticles);

	CalcNumUnreadArticles();
}
]]></method>

<method access="public" mod-time="Thu, 20 Apr 2000 23:26:52 PDT"><![CDATA[
status_t ReadHeaders(NNTPConnection* connection, ArticleSet* cachedArticles, Task* task,
                     volatile bool &stopRequested)	// takes ownership of "cachedArticles"
{
	status_t result = B_NO_ERROR;

	// copy "readArticles" into "cachedArticles", using that as the set of unneeded articles
	ArticleSet* unneededArticles;
	if (cachedArticles) {
		// use "cachedArticles" as "unneededArticles"
		unneededArticles = cachedArticles;
		// copy "readArticles" into it
		unneededArticles->Incorporate(readArticles);
		}
	else
		unneededArticles = readArticles;	// use "readArticles" directly
	task->SetProgressMax(availableArticles.Size() - unneededArticles->NumArticlesIn(availableArticles));

	IntRange lastReadRange(-1, -1);
	int numRanges = unneededArticles->NumRanges();
	for (int i=0; i<numRanges; i++) {
		if (stopRequested)
			break;
		IntRange readRange = unneededArticles->RangeAt(i);

		// unread range is between readRanges
		IntRange unreadRange(lastReadRange.max + 1, readRange.min - 1);

		// read the range
		IntRange unreadAvailable = unreadRange & availableArticles;
		if (unreadAvailable.IsValid()) {
			result = GetOneHeaderRange(connection, unreadAvailable, task);
			if (result != B_NO_ERROR)
				goto exit;
			}

		lastReadRange = readRange;
		}
	// handle last unread range
	{
	IntRange lastUnreadRange(lastReadRange.max + 1, availableArticles.max);
	IntRange lastUnreadAvailable = lastUnreadRange & availableArticles;
	if (lastUnreadAvailable.IsValid() && !stopRequested) {
		result = GetOneHeaderRange(connection, lastUnreadAvailable, task);
		if (result != B_NO_ERROR)
			goto exit;
		}
	}

exit:
	if (unneededArticles != readArticles)
		delete unneededArticles;
	return B_NO_ERROR;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ArticleRead(int articleNo)
{
	readArticles->AddArticle(articleNo);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ArticleUnread(int articleNo)
{
	readArticles->RemoveArticle(articleNo);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ReadArticlesChanged()
{
	CalcNumUnreadArticles();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Close()
{
	int i;

	// write the article cache, but only if headers have been loaded
	if (subjectTree->NumSubjects() > 0)
		WriteArticleCache();

	// delete all subjects
	int numSubjects = subjectTree->NumSubjects();
	for (i=0; i<numSubjects; i++)
		delete subjectTree->SubjectAt(i);

	// clear indexes
	subjectTree->DeleteAllObjects();
	filterTree->DeleteAllObjects();
	// delete responses
	int numResponses = headersResponses->CountItems();
	for (int i=0; i<numResponses; i++)
		delete (NNTPResponse*) headersResponses->ItemAt(i);
	headersResponses->MakeEmpty();
	// delete cached header info
	delete cachedHeaderInfo;
	cachedHeaderInfo = NULL;
}
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 09:10:45 PDT"><![CDATA[
void WriteArticleCache()
{
	string_slice eol("\n");
	string_slice tab("\t");

	// open the file
	BFile* file = OpenHeaderCacheFile(B_READ_WRITE | B_CREATE_FILE | B_ERASE_FILE);
	if (file == NULL || file->InitCheck() != B_NO_ERROR)
		return;
	BNodeInfo(file).SetType("text/plain");

	// write all the unread subjects/articles out
	int numSubjects = subjectTree->NumSubjects();
	for (int subjIdx=0; subjIdx<numSubjects; subjIdx++) {
		Subject* subject = subjectTree->SubjectAt(subjIdx);
		if (subject->AllRead())
			continue;

		// write the subject
		string_slice subjectStr = subject->GetSubject();
		file->Write(subjectStr.begin(), subjectStr.length());
		file->Write(eol.begin(), eol.length());

		// write the unread articles
		int numArticles = subject->NumArticles();
		for (int articleIdx=0; articleIdx<numArticles; articleIdx++) {
			Article* article = subject->ArticleAt(articleIdx);
			if (article->IsRead())
				continue;

			// write "\t<articleNo>\t<author>\t<date>\t<lines>"
			file->Write(tab.begin(), tab.length());
			// articleNo
			qstring articleNo(article->ArticleNo());
			file->Write(articleNo.data(), articleNo.length());
			file->Write(tab.begin(), tab.length());
			// author
			string_slice author = article->Author();
			file->Write(author.begin(), author.length());
			file->Write(tab.begin(), tab.length());
			// date
			time_t articleDate = article->Date();
			string_slice date = ctime(&articleDate);
			date.resize(date.length() - 1);	// trim off the trailing '\n'
			file->Write(date.begin(), date.length());
			file->Write(tab.begin(), tab.length());
			// lines
			qstring lines(article->Lines());
			file->Write(lines.data(), lines.length());
			// EOL
			file->Write(eol.begin(), eol.length());
			}
		}

	delete file;
}
]]></method>

<method access="public" mod-time="Thu, 20 Apr 2000 23:25:27 PDT"><![CDATA[
ArticleSet* ReadArticleCache()
{
	// lock
	if (wind)
		wind->Lock();

	// get info
	bool expandSubjects = Prefs()->GetBoolPref("expandSubjectsByDefault");

	// open the file
	BFile* file = OpenHeaderCacheFile(B_READ_ONLY);
	if (file == NULL || file->InitCheck() != B_NO_ERROR) {
		if (wind)
			wind->Unlock();
		return NULL;
		}

	// read it into memory
	off_t fileSize = 0;
	file->GetSize(&fileSize);
	cachedHeaderInfo = new char[fileSize];
	file->ReadAt(0, cachedHeaderInfo, fileSize);
	delete file;

	// read in the headers
	ArticleSet* cachedArticles = new ArticleSet();
	TextReader reader(string_slice(cachedHeaderInfo, cachedHeaderInfo + fileSize));
	Subject* curSubject = NULL;
	Filters* filters = ((NNTPApp*) be_app)->GetFilters();
	for (; !reader.AtEOF(); reader.NextLine()) {
		// if it's a subject line, set up new subject
		string_slice subject = reader.NextTabField();
		if (subject.length() > 0) {
			// finish old subject
			if (curSubject) {
				if (curSubject->NumArticles() > 0)
					subjectTree->Insert(curSubject);
				else
					delete curSubject;
				}
			// start new subject
			curSubject = new Subject(subject);
			if (expandSubjects)
				curSubject->SetExpanded(true);
			}

		// otherwise it's an article line
		else if (curSubject != NULL) {
			// make the article, but only if it's not read
			int articleNo = qstring(reader.NextTabField()).asInt();
			if (readArticles->ContainsArticle(articleNo))
				continue;
			string_slice author = reader.NextTabField();
			time_t date = SliceToDate(reader.NextTabField());
			int lines = qstring(reader.NextTabField()).asInt();
			Article* article = new Article(articleNo, author, date, lines);

			// filter the article, and add or delete it
			filters->GetGlobalFilters()->ApplyFilters(article, curSubject->GetSubject());
			FilterGroup* filterGroup = filters->GetFilterGroup(groupName);
			if (filterGroup)
				filterGroup->ApplyFilters(article, curSubject->GetSubject());
			if (!article->IsRead()) {
				curSubject->AddArticle(article);
				cachedArticles->AddArticle(articleNo);
				}
			else {
				readArticles->AddArticle(articleNo);
				delete article;
				}
			}
		}
	// finish final subject
	if (curSubject) {
		if (curSubject->NumArticles() > 0)
			subjectTree->Insert(curSubject);
		else
			delete curSubject;
		}

	// build the filterTree
	int numSubjects = subjectTree->NumObjects();
	for (int i=0; i<numSubjects; i++)
		filterTree->Insert(subjectTree->SubjectAt(i));

	// refresh & unlock
	if (wind) {
		wind->NumSubjectsChanged();
		wind->Unlock();
		}

	return cachedArticles;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void RemoveReadArticles()
{
	int numSubjects = subjectTree->NumSubjects();
	for (int i=0; i<numSubjects; ) {
		Subject* subject = subjectTree->SubjectAt(i);
		int numArticles = subject->NumArticles();
		int numUnread = subject->NumUnreadArticles();
		if (numUnread == 0) {
			// all are read--remove the whole subject
			if (wind)
				wind->Lock();
			subjectTree->Remove(subject);
			filterTree->Remove(subject);
			if (wind)
				wind->NumSubjectsChanged();
			if (wind)
				wind->Unlock();
			// adjust the loop
			numSubjects -= 1;
			}
		else if (numUnread != numArticles) {
			// some are read; remove them (including a re-filter)
			if (wind)
				wind->Lock();
			filterTree->Remove(subject);
			int numArticles = subject->NumArticles();
			for (int articleIndex = 0; articleIndex < numArticles; ) {
				Article* article = subject->ArticleAt(articleIndex);
				if (article->IsRead()) {
					subject->RemoveArticle(article);
					numArticles -= 1;
					}
				else
					++articleIndex;
				}
			filterTree->Insert(subject);
			if (wind)
				wind->SubjectChanged(subject);
			if (wind)
				wind->Unlock();
			// go to the next one
			++i;
			}
		else
			++i;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Access"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice Name()
{
	return groupName;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int NumUnreadArticles()
{
	return numUnreadArticles;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool HaveAvailableArticlesInfo()
{
	return availableArticles.IsValid();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ArticleSet* ReadArticles()
{
	return readArticles;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ListableTree* SubjectTree()
{
	return subjectTree;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ListableTree* FilterTree()
{
	return filterTree;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AttachedToWindow(NewsgroupWind* window)
{
	wind = window;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
NewsgroupWind* Window()
{
	return wind;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetNewsrc(Newsrc* newNewsrc)
{
	newsrc = newNewsrc;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Thu, 20 Apr 2000 23:27:42 PDT"><![CDATA[
status_t GetOneHeaderRange(NNTPConnection* connection, IntRange range, Task* task)
{
	NNTPResponse* response;
	bool expandSubjects = Prefs()->GetBoolPref("expandSubjectsByDefault");

	// send the XOVER command
	char cmd[256];
	sprintf(cmd, "xover %d-%d", range.min, range.max);
	status_t result = connection->SendCommand(cmd);
	if (result != B_NO_ERROR)
		return result;
	result = connection->GetResponse(&response);
	if (result != 224)
		return result;
	response->NextLine();

	// add the subjects and articles
	ArticleSet expiredArticles;
	expiredArticles.AddRange(range);
	bool gotHeaders = false;
	Filters* filters = ((NNTPApp*) be_app)->GetFilters();
	int curProgress = task->CurProgress();
	while (!response->AtEOF()) {
		// get the subject from the XOVER response
		int articleNo = response->NextIntTabField();
		string_slice subject = response->NextTabField();
		string_slice author = response->NextTabField();
		time_t date = SliceToDate(response->NextTabField());
		response->NextTabField();	// skip message-id
		response->NextTabField();	// skip references
		response->NextTabField();	// skip byte count
		int numLines = response->NextIntTabField();
		response->NextLine();
		if (subject.length() == 0)
			continue;

		// trim "Re:"
		subject = TrimSubject(subject);

		// lock
		if (wind)
			wind->Lock();

		// create and filter the article
		Article* article = new Article(articleNo, author, date, numLines);
		filters->GetGlobalFilters()->ApplyFilters(article, subject);
		FilterGroup* filterGroup = filters->GetFilterGroup(groupName);
		if (filterGroup)
			filterGroup->ApplyFilters(article, subject);

		// delete the article if killed by filter
		if (article->IsRead()) {
			delete article;
			readArticles->AddArticle(articleNo);
			}

		// otherwise add it in
		else {
			// add to the subject trees if it's not already there
			Subject* subjectObj = subjectTree->Find(subject);
			if (subjectObj == NULL) {
				subjectObj = new Subject(subject);
				if (expandSubjects)
					subjectObj->SetExpanded(true);
				subjectObj->AddArticle(article);
				subjectTree->Insert(subjectObj);
				filterTree->Insert(subjectObj);
				if (wind)
					wind->NumSubjectsChanged();
				}

			// otherwise add the article; it may move the subject in the filterTree
			else {
				filterTree->Remove(subjectObj);
				subjectObj->AddArticle(article);
				filterTree->Insert(subjectObj);
				if (wind)
					wind->SubjectChanged(subjectObj);
				}

			// refresh display
/*** no longer needed?  since we do it if not adding a new subject?
			if (wind)
				wind->SubjectChanged(subjectObj);
***/

			// indicate that we need to keep the response
			gotHeaders = true;
			}

		// mark as not expired
		expiredArticles.RemoveArticle(articleNo);

		// update progress
		curProgress += 1;
		if (task->IsReadyForUpdate())
			task->SetProgress(curProgress);

		// unlock
		if (wind)
			wind->Unlock();
		}
	task->SetProgress(curProgress);

	// add to the "headersResponses"
	if (gotHeaders)
		headersResponses->AddItem(response);
	else
		delete response;

	// mark expired articles as read
	readArticles->Incorporate(&expiredArticles);

	return B_NO_ERROR;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice TrimSubject(string_slice subject)
{
	const char* p = subject.begin();
	const char* stopper = subject.end();
	while (p < stopper) {
		// skip whitespace
		for (; p < stopper; p++) {
			if (*p != ' ' && *p != '\t')
				break;
			}
		// check for "Re"
		if (p > stopper - 3)
			break;
		if ((*p == 'R' || *p == 'r') && (p[1] == 'e' || p[1] == 'E') && p[2] == ':')
			p += 3;
		else
			break;
		}
	return string_slice(p, subject.end());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
time_t SliceToDate(string_slice strIn)
{
	char str[256];
	strIn.copy(str);
	str[strIn.length()] = 0;
	return parsedate(str, -1);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void CalcNumUnreadArticles()
{
	numUnreadArticles = 0;

	// count intersection of available and unread articles
	IntRange lastReadRange(-1, -1);
	int numRanges = readArticles->NumRanges();
	for (int i=0; i<numRanges; i++) {
		IntRange readRange = readArticles->RangeAt(i);

		// unread range is between readRanges
		IntRange unreadRange(lastReadRange.max + 1, readRange.min - 1);

		// add intersection
		IntRange unreadAvailable = unreadRange & availableArticles;
		if (unreadAvailable.IsValid())
			numUnreadArticles += unreadAvailable.max - unreadAvailable.min + 1;

		lastReadRange = readRange;
		}
	// handle last unread range
	IntRange lastUnreadRange(lastReadRange.max + 1, availableArticles.max);
	IntRange lastUnreadAvailable = lastUnreadRange & availableArticles;
	if (lastUnreadAvailable.IsValid())
		numUnreadArticles += lastUnreadAvailable.max - lastUnreadAvailable.min + 1;

	// display
	newsrc->NewsgroupChanged(this);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BFile* OpenHeaderCacheFile(uint32 openMode)
{
	status_t err;

	// figure out where to put it
	BPath path;
	err = find_directory(B_USER_SETTINGS_DIRECTORY, &path, true);
	if (err != B_NO_ERROR)
		return NULL;
	path.Append(FileNames::cacheFolderName);
	err = create_directory(path.Path(), 0777);
	if (err != B_NO_ERROR)
		return NULL;
	path.Append(qstring(groupName).c_str());

	// open the file
	return new BFile(path.Path(), openMode);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Testing & Debugging"
]]></method>

<method access="protected" mod-time="Sat, 08 Apr 2000 09:47:18 PDT"><![CDATA[
static void WriteSubject(Subject* subject, void* data)
{
	// write the subject
	string_slice subj = subject->GetSubject();
	fwrite(subj.begin(), subj.length(), 1, stdout);
	printf("\n");

	// write the articles
	int numArticles = subject->NumArticles();
	for (int i=0; i<numArticles; i++) {
		Article* article = subject->ArticleAt(i);
		printf("\t%d\t", article->ArticleNo());
		string_slice author = article->Author();
		fwrite(author.begin(), author.length(), 1, stdout);
		printf("\t%d\n", article->Lines());
		}
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
qstring groupName;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Newsrc* newsrc;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
IntRange availableArticles;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ArticleSet* readArticles;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int numUnreadArticles;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
SubjectSubjectTree* subjectTree;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
SubjectFilterTree* filterTree;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BList* headersResponses;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
char* cachedHeaderInfo;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
NewsgroupWind* wind;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const unsigned int maxHeaders = 10000;
]]></variable>

</class>


<class mod-time="Sat, 15 Apr 2000 00:44:41 PDT" wind-frame="126.000000,76.000000,766.000000,606.000000" list-views-height="0.000000">
<name>
Subject
</name>
<hIncludes><![CDATA[
#include "string_slice.h"
#include <List.h>

class Article;
class Newsgroup;
class BMessage;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Article.h"
#include "Newsgroup.h"
#include "ExtractBinariesThread.h"
#include <Message.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Subject(string_slice subjectIn)
	: subject(subjectIn), filterScore(0), minArticleNo(0),
	  expanded(false), selected(false)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AddArticle(Article* article)
{
	articles.AddItem(article);

	// update "filterValue" and "minArticleNo"
	if (articles.CountItems() == 1) {
		filterScore = article->FilterScore();
		minArticleNo = article->ArticleNo();
		minArticleDate = article->Date();
		}
	else {
		float newFilterScore = article->FilterScore();
		if (newFilterScore > filterScore)
			filterScore = newFilterScore;
		int articleNo = article->ArticleNo();
		if (articleNo < minArticleNo)
			minArticleNo = articleNo;
		time_t date = article->Date();
		if (date < minArticleDate)
			minArticleDate = date;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void RemoveArticle(Article* article)
{
	articles.RemoveItem(article);

	// update "filterValue", "minArticleNo", "minArticleDate"
	Article* curArticle;
	int numArticles = NumArticles();
	if (numArticles == 0) {
		filterScore = 0;
		minArticleNo = 0;
		minArticleDate = 0;
		}
	else {
		curArticle = ArticleAt(0);
		filterScore = curArticle->FilterScore();
		minArticleNo = curArticle->ArticleNo();
		minArticleDate = curArticle->Date();
		}
	for (int i=1; i<numArticles; i++) {
		curArticle = ArticleAt(i);
		float newFilterScore = curArticle->FilterScore();
		if (newFilterScore > filterScore)
			newFilterScore = filterScore;
		int articleNo = curArticle->ArticleNo();
		if (articleNo < minArticleNo)
			minArticleNo = articleNo;
		time_t date = curArticle->Date();
		if (date < minArticleDate)
			minArticleDate = date;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetupSaveArticles(BMessage* message)
{
	qstring subjectStr(subject);

	// add selected articles
	int numArticles = NumArticles();
	bool hadSelectedArticle = false;
	for (int i=0; i<numArticles; i++) {
		Article* article = ArticleAt(i);
		if (!article->Selected() && !selected)
			continue;
		message->AddInt32("articleNos", article->ArticleNo());
		message->AddString("subjects", subjectStr.c_str());
		hadSelectedArticle = true;
		}
}
]]></method>

<method access="public" mod-time="Sat, 15 Apr 2000 00:44:41 PDT"><![CDATA[
void SetupExtractBinaries(BList* list)
{
	// add selected articles
	int numArticles = NumArticles();
	for (int i=0; i<numArticles; i++) {
		Article* article = ArticleAt(i);
		if (!article->Selected() && !selected)
			continue;
		BinaryArticleSpec* newSpec = new BinaryArticleSpec(this, article);
		list->AddItem(newSpec);
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Access"
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 08:32:54 PDT"><![CDATA[
string_slice GetSubject()
{
	return subject;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline float FilterScore()
{
	return filterScore;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline int MinArticleNo()
{
	return minArticleNo;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline time_t MinArticleDate()
{
	return minArticleDate;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int NumArticles()
{
	return articles.CountItems();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int NumUnreadArticles()
{
	int numArticles = articles.CountItems();
	int numUnread = 0;
	for (int i=0; i<numArticles; i++) {
		Article* article = (Article*) articles.ItemAt(i);
		if (!article->IsRead())
			numUnread += 1;
		}
	return numUnread;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Article* ArticleAt(int index)
{
	return (Article*) articles.ItemAt(index);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Article* FirstUnreadArticle()
{
	int numArticles = articles.CountItems();
	for (int i=0; i<numArticles; i++) {
		Article* article = (Article*) articles.ItemAt(i);
		if (!article->IsRead())
			return article;
		}
	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool AllRead()
{
	int numArticles = articles.CountItems();
	for (int i=0; i<numArticles; i++) {
		Article* article = (Article*) articles.ItemAt(i);
		if (!article->IsRead())
			return false;
		}
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool AllUnread()
{
	int numArticles = articles.CountItems();
	for (int i=0; i<numArticles; i++) {
		Article* article = (Article*) articles.ItemAt(i);
		if (article->IsRead())
			return false;
		}
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool Expanded()
{
	return expanded;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetExpanded(bool newExpanded)
{
	expanded = newExpanded;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool Selected()
{
	return selected;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetSelected(bool newSelected)
{
	selected = newSelected;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MarkSelected(bool marked, Newsgroup* newsgroup)
{
	int i;
	Article* article;

	int numArticles = NumArticles();

	// if whole subject is selected, mark all articles
	if (selected) {
		for (i=0; i<numArticles; i++) {
			article = ArticleAt(i);
			article->SetRead(marked);
			if (marked)
				newsgroup->ArticleRead(article->ArticleNo());
			else
				newsgroup->ArticleUnread(article->ArticleNo());
			}
		}

	// otherwise, just mark selected articles
	else {
		for (i=0; i<numArticles; i++) {
			article = ArticleAt(i);
			if (article->Selected()) {
				article->SetRead(marked);
				if (marked)
					newsgroup->ArticleRead(article->ArticleNo());
				else
					newsgroup->ArticleUnread(article->ArticleNo());
				}
			}
		}
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice subject;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BList articles;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
float filterScore;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int minArticleNo;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
time_t minArticleDate;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool expanded;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool selected;
]]></variable>

</class>


<class mod-time="Sat, 08 Apr 2000 09:49:28 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Article
</name>
<hIncludes><![CDATA[
#include "string_slice.h"
#include <time.h>
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Article(int articleNoIn, string_slice authorIn, time_t dateIn, int linesIn,
        int filterScoreIn = 0)
	: articleNo(articleNoIn), author(authorIn), date(dateIn), lines(linesIn),
	  filterScore(filterScoreIn), read(false), selected(false)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Access"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline int ArticleNo()
{
	return articleNo;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline string_slice Author()
{
	return author;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline time_t Date()
{
	return date;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline int Lines()
{
	return lines;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline float FilterScore()
{
	return filterScore;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetFilterScore(float newFilterScore)
{
	filterScore = newFilterScore;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline bool IsRead()
{
	return read;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline void SetRead(bool newRead)
{
	read = newRead;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool Selected()
{
	return selected;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetSelected(bool newSelected)
{
	selected = newSelected;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int articleNo;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice author;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
time_t date;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int lines;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
float filterScore;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool read;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool selected;
]]></variable>

</class>


<class mod-time="Fri, 14 Apr 2000 18:09:30 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
"Trees"
</name>
</class>


<class mod-time="Sat, 08 Apr 2000 09:53:29 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
AATree
</name>
<hIncludes><![CDATA[

class OrderedObject;
class AATreeNode;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "OrderedObject.h"
#include "AATreeNode.h"

class NullNode : public AATreeNode {
public:
	NullNode()
		: AATreeNode(NULL) { level = size = 0; left = right = this; }
	bool	operator<(const AATreeNode& otherNode) { return false; }
	bool	operator==(const AATreeNode& otherNode) { return false; }
};
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
AATree()
{
	nullNode = new NullNode();
	root = nullNode;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual ~AATree()
{
	FreeTree(root);
	delete nullNode;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void InsertObject(OrderedObject* object)
{
	AATreeNode* newNode = MakeNode(object);
	newNode->left = newNode->right = nullNode;
	InsertNodeAt(newNode, root);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
OrderedObject* RemoveObject(OrderedObject* compareObject)
{
	deleteNode = nullNode;
	return RemoveNodeFrom(compareObject, &root);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
OrderedObject* FindObject(OrderedObject* object)
{
	AATreeNode* curNode = root;
	while (curNode != nullNode && *object != *curNode->object)
		curNode = (*object < *curNode->object ? curNode->left : curNode->right);
	return (curNode == nullNode ? NULL : curNode->object);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void WalkObjects(void (*f)(OrderedObject* object, void* data), void* data)
{
	WalkNodesAt(f, data, root);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
unsigned int NumObjects()
{
	if (root == NULL)
		return 0;
	else
		return root->size;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
OrderedObject* ObjectAt(unsigned int index)
{
	index += 1;		// convert from zero-based to one-based
	AATreeNode* node = root;
	while (node != nullNode) {
		unsigned int leftSize = node->left->size;
		if (index <= leftSize)
			node = node->left;
		else if (index == leftSize + 1)
			return node->object;
		else {
			index -= leftSize + 1;
			node = node->right;
			}
		}
	// didn't find it
	return NULL;
}
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 09:53:29 PDT"><![CDATA[
unsigned int IndexOf(OrderedObject* object)
{
	int index = 0;
	AATreeNode* curNode = root;
	while (curNode != nullNode) {
		if (*object == *curNode->object)
			return index + curNode->left->size;
		else if (*object < *curNode->object)
			curNode = curNode->left;
		else {
			index += curNode->left->size + 1;
			curNode = curNode->right;
			}
		}
	return (unsigned int) -1;	// didn't find it
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DeleteAllObjects()
{
	WalkObjects(DeleteObject, NULL);
	FreeTree(root);
	root = nullNode;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ObjectChanged(OrderedObject* object)
{
	ObjectChangedIn(root, object);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void UpdateAllObjects()
{
	UpdateAllObjectsIn(root);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Virtual"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual AATreeNode* MakeNode(OrderedObject* object)
{
	return new AATreeNode(object);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void AdjustNode(AATreeNode* node)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void InsertNodeAt(AATreeNode* newNode, AATreeNode*& atNode)
{
	if (atNode == nullNode)
		atNode = newNode;
	else if (*newNode->object < *atNode->object) {
		InsertNodeAt(newNode, atNode->left);
		atNode->size++;
		AdjustNode(atNode);
		}
	else {
		InsertNodeAt(newNode, atNode->right);
		atNode->size++;
		AdjustNode(atNode);
		}

	Skew(atNode);
	Split(atNode);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
OrderedObject* RemoveNodeFrom(OrderedObject* compareObject, AATreeNode** nodeHolder)
{
	AATreeNode* node = *nodeHolder;
	if (node == nullNode)
		return NULL;

	OrderedObject* removedObject = NULL;

	// search down the tree and set lastNode and deleteNode
	lastNode = node;
	if (*compareObject < *node->object)
		removedObject = RemoveNodeFrom(compareObject, &node->left);
	else {
		deleteNode = node;
		removedObject = RemoveNodeFrom(compareObject, &node->right);
		}

	// remove if at bottom of the tree and the node is present
	if (node == lastNode) {
		// swap this node in for the deleted node
		if (deleteNode != nullNode && *compareObject == *deleteNode->object) {
			// swap in to deleted node
			removedObject = deleteNode->object;
			deleteNode->object = node->object;
			// splice out this node
			*nodeHolder = node->right;
			// delete the node
			delete node;
			}
		else {
			// mark as not found
			// (not actually necessary)
			deleteNode = nullNode;
			lastNode = NULL;
			}
		}

	// otherwise we're not at the bottom, so rebalance
	else {
		node = *nodeHolder;		// in case things got moved around
		// adjust size
		if (removedObject) {
			--node->size;
			AdjustNode(node);
			}
		// rebalance
		if (node->left->level < node->level - 1 ||
				node->right->level < node->level - 1) {
			if (node->right->level > --node->level)
				node->right->level = node->level;
			Skew(*nodeHolder);
			node = *nodeHolder;
			Skew(node->right);
			Skew(node->right->right);
			Split(*nodeHolder);
			node = *nodeHolder;
			Split(node->right);
			}
		}

	return removedObject;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Skew(AATreeNode*& node)
{
	if (node->left->level == node->level && node != nullNode) {
		// (had to check for nullNode because of size adjustment; otherwise
		// this all works okay even on nullNode)
		// rotate with left child
		AATreeNode* childNode = node->left;
		node->left = childNode->right;
		childNode->right = node;
		// hoist the child node up
		node = childNode;
		// adjust sizes & display heights
		childNode = node->right;
		childNode->size = childNode->left->size + childNode->right->size + 1;
		AdjustNode(childNode);
		node->size = node->left->size + node->right->size + 1;
		AdjustNode(node);
/***
		childNode->displayHeight =
			childNode->left->displayHeight + childNode->right->displayHeight +
			(childNode->object ? childNode->object->DisplayHeight() : 0);
		node->displayHeight =
			node->left->displayHeight + node->right->displayHeight +
			(node->object ? node->object->DisplayHeight() : 0);
***/
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Split(AATreeNode*& node)
{
	if (node->right->right->level == node->level && node != nullNode) {
		// (had to check for nullNode because of size adjustment; otherwise
		// this all works okay even on nullNode)
		// rotate with right child
		AATreeNode* childNode = node->right;
		node->right = childNode->left;
		childNode->left = node;
		// hoist the child
		node = childNode;
		node->level++;
		// adjust the sizes & displayHeights
		childNode = node->left;
		childNode->size = childNode->left->size + childNode->right->size + 1;
		node->size = node->left->size + node->right->size + 1;
		AdjustNode(childNode);
		AdjustNode(node);
/***
		childNode->displayHeight =
			childNode->left->displayHeight + childNode->right->displayHeight +
			(childNode->object ? childNode->object->DisplayHeight() : 0);
		node->displayHeight =
			node->left->displayHeight + node->right->displayHeight +
			(node->object ? node->object->DisplayHeight() : 0);
***/
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void FreeTree(AATreeNode* node)
{
	if (node != nullNode) {
		FreeTree(node->right);
		FreeTree(node->left);
		delete node;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void WalkNodesAt(void (*f)(OrderedObject* object, void* data), void* data, AATreeNode* node)
{
	if (node != nullNode) {
		WalkNodesAt(f, data, node->left);
		f(node->object, data);
		WalkNodesAt(f, data, node->right);
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ObjectChangedIn(AATreeNode* node, OrderedObject* object)
{
	if (node == nullNode)
		return;
	if (*object < *node->object)
		ObjectChangedIn(node->left, object);
	else if (*object != *node->object)
		ObjectChangedIn(node->right, object);
	AdjustNode(node);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void UpdateAllObjectsIn(AATreeNode* node)
{
	if (node == nullNode)
		return;
	UpdateAllObjectsIn(node->left);
	UpdateAllObjectsIn(node->right);
	AdjustNode(node);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static void DeleteObject(OrderedObject* object, void* data)
{
	delete object;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance Variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
AATreeNode* root;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
AATreeNode* nullNode;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Removal ivars"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
AATreeNode* deleteNode;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
AATreeNode* lastNode;
]]></variable>

</class>


<class mod-time="Sat, 08 Apr 2000 09:52:22 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
AATreeNode
</name>
<hIncludes><![CDATA[
#include <SupportDefs.h>
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 09:52:22 PDT"><![CDATA[
inline AATreeNode(OrderedObject* objectIn)
	: left(NULL), right(NULL), level(1), size(1), object(objectIn)
{
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
AATreeNode* left;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
AATreeNode* right;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int level;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
unsigned int size;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
OrderedObject* object;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
OrderedObject
</name>
<hIncludes><![CDATA[
class OrderedObject {
public:
	virtual bool	operator<(const OrderedObject& otherObject) = 0;
	virtual bool	operator==(const OrderedObject& otherObject) = 0;

	bool	operator!=(const OrderedObject& otherObject)
				{ return !(*this == otherObject); }
};
]]></hIncludes>
</class>


<class mod-time="Sat, 08 Apr 2000 09:04:43 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
ListableObject
</name>
<superclasses>
public OrderedObject
</superclasses>
<hIncludes><![CDATA[
#include "OrderedObject.h"
#include <SupportDefs.h>
#include <GraphicsDefs.h>
#include <Rect.h>

class AATreeListView;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "AATreeListView.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ListableObject()
	: selected(false)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Pure virtual"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual int DisplayHeight()
{
	/** pure virtual **/
	return 0;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void Draw(BRect rect, AATreeListView* view)
{
	/** pure virtual **/
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void MouseDown(BPoint where, BRect rect, int clicks, int modifiers, AATreeListView* view)
{
	/** pure virtual **/
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void Open(AATreeListView* view)
{
	/** pure virtual **/
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Overrideable Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual bool Selected()
{
	return selected;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void SetSelected(bool newSelected)
{
	selected = newSelected;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void SelectDown(uint32 modifiers, AATreeListView* view)
{
	int index = view->IndexOf(this);
	if ((modifiers & B_SHIFT_KEY) == 0)
		view->DeselectAll();
	view->Select(index < view->NumObjects() - 1 ? index + 1 : index);
	view->ScrollToSelection();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void SelectUp(uint32 modifiers, AATreeListView* view)
{
	int index = view->IndexOf(this);
	if ((modifiers & B_SHIFT_KEY) == 0)
		view->DeselectAll();
	view->Select(index > 0 ? index - 1 : 0);
	view->ScrollToSelection();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Helpers for subclasses"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DrawExpander(BView* view, BPoint bottomLeft, bool expanded, bool tracking = false)
{
	view->PushState();

	// figure out the points of the triangle
	BPoint triangle[3];
	if (!expanded) {
		triangle[0] = bottomLeft;
		triangle[1].x = bottomLeft.x;
		triangle[1].y = bottomLeft.y - expanderHeight;
		triangle[2].x = bottomLeft.x + expanderWidth;
		triangle[2].y = bottomLeft.y - expanderHeight / 2;
		}
	else {
//***		float top = bottomLeft.y - expanderHeight + expanderWidth / 2;
		float top = bottomLeft.y - expanderWidth;
		triangle[0].x = bottomLeft.x;
		triangle[0].y = top;
		triangle[1].x = bottomLeft.x + expanderHeight;
		triangle[1].y = top;
		triangle[2].x = bottomLeft.x + expanderHeight / 2;
		triangle[2].y = top + expanderWidth;
		}

	// draw
	if (!tracking) {
		view->SetHighColor(expanderColor);
		view->FillTriangle(triangle[0], triangle[1], triangle[2]);
		view->SetHighColor(expanderTrimColor);
		view->StrokeTriangle(triangle[0], triangle[1], triangle[2]);
		}
	else {
		view->SetHighColor(expanderTrimColor);
		view->FillTriangle(triangle[0], triangle[1], triangle[2]);
		}

	view->PopState();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool TrackExpander(BView* view, BPoint bottomLeft, bool expanded)
{
	// start draw
	DrawExpander(view, bottomLeft, expanded, true);
	view->Sync();

	BRect expanderRect(bottomLeft.x, bottomLeft.y - expanderHeight,
	                   bottomLeft.x + expanderHeight, bottomLeft.y);
	BPoint mousePoint, lastMouse(-1, -1);
	uint32 buttons;
	bool curFlipped = true;
	while (true) {
		view->GetMouse(&mousePoint, &buttons);
		if (buttons == 0)
			break;
		if (mousePoint == lastMouse) {
			snooze(20000);
			continue;
			}
		bool flipped = expanderRect.Contains(mousePoint);
		if (flipped != curFlipped) {
			DrawExpander(view, bottomLeft, expanded, flipped);
			view->Sync();
			}
		lastMouse = mousePoint;
		curFlipped = flipped;
		}

	// don't bother to clean up draw, as the whole item'll have to be redrawn anyway

	return curFlipped ^ expanded;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool selected;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float expanderHeight = 7;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float expanderWidth = 4;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const rgb_color expanderColor = { 128, 128, 128, 0 };
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const rgb_color expanderTrimColor = { 128, 128, 255, 0 };
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
DamnListableObject
</name>
<hIncludes><![CDATA[
#include "ListableObject.h"

// stupid hack because Castle Yankee doesn't support operator overloading

class DamnListableObject : public ListableObject {
public:
	bool	operator<(const OrderedObject& otherObject)
				{ return this->isLessThan(otherObject); }
	bool	operator==(const OrderedObject& otherObject)
				{ return this->isEqualTo(otherObject); }

	// pure virtual
	virtual bool	isLessThan(const OrderedObject& otherObject) = 0;
	virtual bool	isEqualTo(const OrderedObject& otherObject) = 0;	
};
]]></hIncludes>
</class>


<class mod-time="Sat, 08 Apr 2000 09:55:05 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
ListableTree
</name>
<superclasses>
public AATree
</superclasses>
<hIncludes><![CDATA[
#include "AATree.h"

class ListableObject;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "AATree.h"
#include "ListableObject.h"
#include "ListableTreeNode.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ListableTree()
	: AATree()
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations--Height"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int DisplayHeight()
{
	return ((ListableTreeNode*) root)->displayHeight;
}
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 09:54:37 PDT"><![CDATA[
int IndexForY(int y)
{
	int index = 0;
	AATreeNode* node = root;
	while (node != nullNode) {
		unsigned int leftHeight =
			(node->left == nullNode ? 0 :
			 ((ListableTreeNode*) node->left)->displayHeight);
		if ((unsigned int) y < leftHeight)
			node = node->left;
		else {
			y -= leftHeight;
			index += node->left->size;
			int objectHeight = ((ListableObject*) node->object)->DisplayHeight();
			if (y < objectHeight)
				return index;
			else {
				y -= objectHeight;
				index += 1;
				node = node->right;
				}
			}
		}
	// didn't find it
	return -1;
}
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 09:55:05 PDT"><![CDATA[
int YAtIndex(int index)
{
	int y = 0;
	AATreeNode* node = root;
	while (node != nullNode) {
		unsigned int leftSize = node->left->size;
		if ((unsigned int) index < leftSize)
			node = node->left;
		else {
			index -= leftSize;
			if (node->left != nullNode)
				y += ((ListableTreeNode*) node->left)->displayHeight;
			if (index == 0)
				return y;
			else {
				index -= 1;
				y += ((ListableObject*) node->object)->DisplayHeight();
				node = node->right;
				}
			}
		}
	return -1;	// didn't find it
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int YForObject(OrderedObject* object)
{
	int y = 0;
	AATreeNode* node = root;
	while (node != nullNode) {
		if (*object < *node->object)
			node = node->left;
		else {
			if (node->left != nullNode)
				y += ((ListableTreeNode*) node->left)->displayHeight;
			if (*object == *node->object)
				return y;
			else {
				y += ((ListableObject*) node->object)->DisplayHeight();
				node = node->right;
				}
			}
		}
	return -1;	// didn't find it
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations--Selection"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int NumSelections()
{
	if (root == nullNode)
		return 0;
	return ((ListableTreeNode*) root)->numSelections;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ListableObject* SelectedObjectAt(int index)
{
	ListableTreeNode* node = (ListableTreeNode*) root;
	while (node != nullNode) {
		ListableTreeNode* leftNode = (ListableTreeNode*) node->left;
		int leftSelections = (leftNode == nullNode ? 0 : leftNode->numSelections);
		if (index < leftSelections)
			node = leftNode;
		else {
			if (leftNode != nullNode)
				index -= leftNode->numSelections;
			bool selected = ((ListableObject*) node->object)->Selected();
			if (index == 0 && selected)
				return (ListableObject*) node->object;
			else {
				index -= selected;
				node = (ListableTreeNode*) node->right;
				}
			}
		}
	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ListableObject* FirstSelectedObject()
{
	return SelectedObjectAt(0);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ListableObject* LastSelectedObject()
{
	return SelectedObjectAt(NumSelections() - 1);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SelectObject(ListableObject* object)
{
	object->SetSelected(true);
	ObjectChanged(object);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DeselectObject(ListableObject* object)
{
	object->SetSelected(false);
	ObjectChanged(object);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Select(int index)
{
	SelectObject((ListableObject*) ObjectAt(index));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Deselect(int index)
{
	DeselectObject((ListableObject*) ObjectAt(index));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SelectAllObjects()
{
	SelectAllAt(root);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DeselectAllObjects()
{
	DeselectAllAt(root);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AllHeightsChanged()
{
	AdjustAllAt(root);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"AATree virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
AATreeNode* MakeNode(OrderedObject* object)
{
	return new ListableTreeNode((ListableObject*) object);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void AdjustNode(AATreeNode* nodeIn)
{
	ListableTreeNode* node = (ListableTreeNode*) nodeIn;
	ListableTreeNode* left = (ListableTreeNode*) node->left;
	ListableTreeNode* right = (ListableTreeNode*) node->right;

	ListableObject* object = (ListableObject*) node->object;
	node->displayHeight = object->DisplayHeight();
	node->numSelections = object->Selected();
	if (left != nullNode) {
		node->displayHeight += left->displayHeight;
		node->numSelections += left->numSelections;
		}
	if (right != nullNode) {
		node->displayHeight += right->displayHeight;
		node->numSelections += right->numSelections;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SelectAllAt(AATreeNode* nodeIn)
{
	if (nodeIn == nullNode)
		return;

	ListableTreeNode* node = (ListableTreeNode*) nodeIn;
	if (node->left != nullNode) {
		ListableTreeNode* leftNode = (ListableTreeNode*) node->left;
		if (leftNode->numSelections < leftNode->size)
			SelectAllAt(leftNode);
		}
	if (node->right != nullNode) {
		ListableTreeNode* rightNode = (ListableTreeNode*) node->right;
		if (rightNode->numSelections < rightNode->size)
			SelectAllAt(rightNode);
		}
	((ListableObject*) node->object)->SetSelected(true);
	AdjustNode(node);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DeselectAllAt(AATreeNode* nodeIn)
{
	if (nodeIn == nullNode)
		return;

	ListableTreeNode* node = (ListableTreeNode*) nodeIn;
	if (node->left != nullNode && ((ListableTreeNode*) node->left)->numSelections > 0)
		DeselectAllAt(node->left);
	if (node->right != nullNode && ((ListableTreeNode*) node->right)->numSelections > 0)
		DeselectAllAt(node->right);
	((ListableObject*) node->object)->SetSelected(false);
	AdjustNode(node);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AdjustAllAt(AATreeNode* nodeIn)
{
	if (nodeIn == nullNode)
		return;

	ListableTreeNode* node = (ListableTreeNode*) nodeIn;
	if (node->left != nullNode)
		AdjustAllAt(node->left);
	if (node->right != nullNode)
		AdjustAllAt(node->right);
	AdjustNode(node);
}
]]></method>

</class>


<class mod-time="Sat, 08 Apr 2000 09:56:06 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
ListableTreeNode
</name>
<superclasses>
public AATreeNode
</superclasses>
<hIncludes><![CDATA[
#include "AATreeNode.h"

class ListableObject;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "ListableObject.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline ListableTreeNode(ListableObject* object)
	: AATreeNode(object), displayHeight(object->DisplayHeight()), numSelections(0)
{
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int displayHeight;
]]></variable>

<variable access="public" mod-time="Sat, 08 Apr 2000 09:56:06 PDT"><![CDATA[
unsigned int numSelections;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
SubjectTree
</name>
<superclasses>
public ListableTree
</superclasses>
<hIncludes><![CDATA[
#include "ListableTree.h"
#include "OrderedObject.h"
#include "SubjectTreeAdaptor.h"

class Subject;

/***
class SubjectTreeAdaptor : public OrderedObject {
public:
	SubjectTreeAdaptor(Subject* subjectIn)
		: subject(subjectIn) {}

	Subject* subject;
};
***/
]]></hIncludes>
<cppIncludes><![CDATA[

struct WalkParams {
	void	(*f)(Subject* subject, void* data);
	void*	data;

	WalkParams(void (*fIn)(Subject* subject, void* data), void* dataIn)
		: f(fIn), data(dataIn) {}
};
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual ~SubjectTree()
{
	DeleteAllObjects();		// will only delete the adaptors, not the Subjects
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Insert(Subject* subject)
{
	InsertObject(MakeAdaptor(subject));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Remove(Subject* subject)
{
	RemoveObject(AdaptorFor(subject));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Walk(void (*f)(Subject* subject, void* data), void* data)
{
	WalkParams params(f, data);
	WalkObjects(NodeWalker, &params);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline unsigned int NumSubjects()
{
	return NumObjects();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Subject* SubjectAt(unsigned int index)
{
	return ((SubjectTreeAdaptor*) ObjectAt(index))->subject;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Subject* SelectedSubjectAt(int index)
{
	return ((SubjectTreeAdaptor*) SelectedObjectAt(index))->subject;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual SubjectTreeAdaptor* AdaptorFor(Subject* subject)
{
	/** pure virtual **/
	SubjectTreeAdaptor* searchAdaptor = MakeAdaptor(subject);
	SubjectTreeAdaptor* foundAdaptor = (SubjectTreeAdaptor*) FindObject(searchAdaptor);
	delete searchAdaptor;
	return foundAdaptor;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Pure Virtual"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual SubjectTreeAdaptor* MakeAdaptor(Subject* subject)
{
	/** pure virtual **/
	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Static Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static void NodeWalker(OrderedObject* object, void* data)
{
	WalkParams* params = (WalkParams*) data;
	params->f(((SubjectTreeAdaptor*) object)->subject, params->data);
}
]]></method>

</class>


<class mod-time="Fri, 21 Apr 2000 01:55:48 PDT" wind-frame="117.000000,109.000000,757.000000,639.000000" list-views-height="0.000000">
<name>
SubjectTreeAdaptor
</name>
<superclasses>
public ListableObject
</superclasses>
<hIncludes><![CDATA[
#include "ListableObject.h"

class Subject;
class Article;
class Newsgroup;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Subject.h"
#include "Article.h"
#include "AATreeListView.h"
#include "SubjectsView.h"
#include "ListableTree.h"
#include "OpenArticleThread.h"
#include "NewsgroupWind.h"
#include "FontUtils.h"
#include "ListColors.h"
#include "Prefs.h"
#include "qstring.h"
#include "Messages.h"
#include <stdio.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline SubjectTreeAdaptor(Subject* subjectIn)
	: subject(subjectIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"ListableObject virtuals"
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 09:57:24 PDT"><![CDATA[
int DisplayHeight()
{
	SetupFont();

	if (subject->Expanded())
		return (int) (itemHeight + subject->NumArticles() * itemHeight);
	else
		return (int) itemHeight;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool Selected()
{
	if (subject->Selected())
		return true;
	else {
		int numArticles = subject->NumArticles();
		for (int i=0; i<numArticles; i++) {
			if (subject->ArticleAt(i)->Selected())
				return true;
			}
		}
	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetSelected(bool newSelected)
{
	subject->SetSelected(newSelected);
	if (!newSelected)
		DeselectAllArticles();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Draw(BRect rect, AATreeListView* view)
{
	/***/
	float subjectHeight = itemHeight;
	float articleHeight = itemHeight;

	// clear the expander area
	BRect expanderRect = rect;
	expanderRect.right = rect.left + itemLeft - 1;
	view->SetLowColor(ListColors::bgndColor);
	view->FillRect(expanderRect, B_SOLID_LOW);

	SetupFont();
	view->SetFont(&font);

	// draw the expander
	if (subject->NumArticles() > 1) {
		BPoint expanderStart(rect.left + expanderLeft, rect.top + subjectHeight - baseline - 1);
		DrawExpander(view, expanderStart, subject->Expanded());
		}

	// draw the subject
	BRect itemRect = rect;
	itemRect.left += itemLeft;
	itemRect.bottom = itemRect.top + subjectHeight - 1;
	DrawSubject(itemRect, view);

	// draw the articles
	if (subject->Expanded()) {
		// clear the sliver to the left of the sub-items
		BRect clearRect = rect;
		clearRect.top += subjectHeight;
		clearRect.left += itemLeft;
		clearRect.right = clearRect.left + articleItemIndent - 1;
		view->SetLowColor(ListColors::bgndColor);
		view->FillRect(clearRect, B_SOLID_LOW);
		// draw the articles
		itemRect.left += articleItemIndent;
		itemRect.top = itemRect.bottom + 1;
		itemRect.bottom = itemRect.top + articleHeight - 1;
		int numArticles = subject->NumArticles();
		for (int i=0; i<numArticles; i++) {
			DrawArticle(i, itemRect, view);
			// bump itemRect
			itemRect.top = itemRect.bottom + 1;
			itemRect.bottom = itemRect.top + articleHeight - 1;
			}
		}
}
]]></method>

<method access="public" mod-time="Sat, 15 Apr 2000 10:08:17 PDT"><![CDATA[
void MouseDown(BPoint where, BRect rect, int clicks, int modifiers, AATreeListView* view)
{
	/***/
	float subjectHeight = itemHeight;
	float articleHeight = itemHeight;

	// expander
	BRect expanderRect = rect;
	expanderRect.left += expanderLeft;
	expanderRect.right = rect.left + itemLeft;
	if (expanderRect.Contains(where)) {
		BPoint expanderStart(rect.left + expanderLeft, rect.top + subjectHeight - baseline - 1);
		subject->SetExpanded(TrackExpander(view, expanderStart, subject->Expanded()));
		view->Invalidate();
		}

	// double-click opens
	else if (clicks > 1)
		view->OpenSelections();

	// command key reverses sense of selection
	else if ((modifiers & B_COMMAND_KEY) != 0) {
		if (where.y < rect.top + subjectHeight) {
			// toggle selection of subject
			subject->SetSelected(!subject->Selected());
			}
		else {
			// toggle selection of article
			int whichArticle = (int) ((where.y - rect.top - subjectHeight) / articleHeight);
			Article* article = subject->ArticleAt(whichArticle);
			article->SetSelected(!article->Selected());
			}
		view->InvalidateItem(this);
		}

	// select this, or an article
	else {
		view->DeselectAll();
		if (where.y < rect.top + subjectHeight) {
			// select subject
			view->SelectItem(this);
			}
		else {
			// select an article
			int whichArticle = (int) ((where.y - rect.top - subjectHeight) / articleHeight);
			subject->ArticleAt(whichArticle)->SetSelected(true);
			view->InvalidateItem(this);
			}
		((SubjectsView*) view)->SetSelectDirection(None);
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Open(AATreeListView* view)
{
	Article* article;

	Newsgroup* newsgroup = ((NewsgroupWind*) view->Window())->GetNewsgroup();

	// open selected articles if there are any
	bool haveSelectedArticle = false;
	int numArticles = subject->NumArticles();
	for (int i=0; i<numArticles; i++) {
		article = subject->ArticleAt(i);
		if (article->Selected()) {
			OpenArticle(article, newsgroup);
			haveSelectedArticle = true;
			}
		}

	// otherwise open the first unread article
	if (!haveSelectedArticle) {
		article = subject->FirstUnreadArticle();
		if (article == NULL)
			article = subject->ArticleAt(0);
		OpenArticle(article, newsgroup);
		}

	view->InvalidateItem(this);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SelectDown(uint32 modifiers, AATreeListView* viewIn)
{
	SubjectsView* view = (SubjectsView*) viewIn;
	if ((modifiers & B_SHIFT_KEY) != 0 && view->SelectDirection() == Up) {
		// deselect downwards
		// first get the first selected adaptor, since we're the last
		SubjectTreeAdaptor* firstSelectedAdaptor =
			(SubjectTreeAdaptor*) view->SelectionAt(0);
		Subject* firstSelectedSubject = firstSelectedAdaptor->subject;
		// find first selected article
		int numArticles = firstSelectedSubject->NumArticles();
		int firstSelected = 0;
		for (; firstSelected < numArticles; firstSelected++) {
			if (firstSelectedSubject->ArticleAt(firstSelected)->Selected())
				break;
			}
		// deselect
		if (firstSelected >= numArticles)
			firstSelectedSubject->SetSelected(false);
		else
			firstSelectedSubject->ArticleAt(firstSelected)->SetSelected(false);
		view->ItemDisplayChanged(firstSelectedAdaptor);
		// adjust selection direction
		if (view->NumSelections() == 1 &&
				((SubjectTreeAdaptor*) view->SelectionAt(0))->NumSelections() == 1)
			view->SetSelectDirection(None);
		}
	else if (!subject->Expanded() || (modifiers & B_OPTION_KEY) != 0) {
		ListableObject::SelectDown(modifiers, view);
		view->SetSelectDirection((modifiers & B_SHIFT_KEY) == 0 ? None : Down);
		}
	else {
		// find the last selected article
		int lastSelected = -1;
		int numArticles = subject->NumArticles();
		for (int i=numArticles-1; i>=0; --i) {
			if (subject->ArticleAt(i)->Selected()) {
				lastSelected = i;
				break;
				}
			}
		// select
		if (lastSelected >= numArticles - 1)
			ListableObject::SelectDown(modifiers, view);
		else {
			if ((modifiers & B_SHIFT_KEY) == 0)
				view->DeselectAll();
			subject->ArticleAt(lastSelected + 1)->SetSelected(true);
			view->ItemDisplayChanged(this);
			view->SetSelectDirection((modifiers & B_SHIFT_KEY) == 0 ? None : Down);
			}
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SelectUp(uint32 modifiers, AATreeListView* viewIn)
{
	SubjectsView* view = (SubjectsView*) viewIn;
	if ((modifiers & B_SHIFT_KEY) != 0 && view->SelectDirection() == Down) {
		// deselect upwards
		// first get the last selected adaptor, since we're the first
		SubjectTreeAdaptor* lastSelectedAdaptor =
			(SubjectTreeAdaptor*) view->SelectionAt(view->NumSelections() - 1);
		Subject* lastSelectedSubject = lastSelectedAdaptor->subject;
		// find last selected article
		int lastSelected = lastSelectedSubject->NumArticles() - 1;
		for (; lastSelected >= 0; --lastSelected) {
			if (lastSelectedSubject->ArticleAt(lastSelected)->Selected())
				break;
			}
		// deselect
		if (lastSelected < 0)
			lastSelectedSubject->SetSelected(false);
		else
			lastSelectedSubject->ArticleAt(lastSelected)->SetSelected(false);
		view->ItemDisplayChanged(lastSelectedAdaptor);
		// adjust selection direction
		if (view->NumSelections() == 1 &&
				((SubjectTreeAdaptor*) view->SelectionAt(0))->NumSelections() == 1)
			view->SetSelectDirection(None);
		}
	else if ((modifiers & B_OPTION_KEY) != 0) {
		// skips to (previous) subject line
		if (subject->Selected())
			ListableObject::SelectUp(modifiers, view);
		else {
			view->DeselectAll();
			view->SelectItem(this);
			}
		view->SetSelectDirection(None);
		}
	else if (!subject->Expanded() || subject->Selected()) {
		int index = view->IndexOf(this);
		if (index > 0) {
			if ((modifiers & B_SHIFT_KEY) == 0)
				view->DeselectAll();
			((SubjectTreeAdaptor*) view->Tree()->ObjectAt(index - 1))->SelectLast(view);
			}
		else
			ListableObject::SelectUp(modifiers, view);
		view->SetSelectDirection((modifiers & B_SHIFT_KEY) == 0 ? None : Up);
		}
	else {
		// find the first selected article
		int firstSelected = -1;
		int numArticles = subject->NumArticles();
		for (int i=0; i<numArticles; i++) {
			if (subject->ArticleAt(i)->Selected()) {
				firstSelected = i;
				break;
				}
			}
			// at this point "firstSelected" is guaranteed to have been found:
			// if there were no selected articles, the subject line is selected
			// (or SelectUp() wouldn't have been called), which would have been
			// handled above
		// select
		if ((modifiers & B_SHIFT_KEY) == 0)
			view->DeselectAll();
		if (firstSelected == 0) {
			// first item is selected; select the subject line
			subject->SetSelected(true);
			}
		else {
			// select previous article
			subject->ArticleAt(firstSelected - 1)->SetSelected(true);
			}
		view->ItemDisplayChanged(this);
		view->SetSelectDirection((modifiers & B_SHIFT_KEY) == 0 ? None : Up);
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SelectLast(AATreeListView* view)
{
	if (!subject->Expanded())
		view->SelectItem(this);
	else {
		// select the last article
		subject->ArticleAt(subject->NumArticles() - 1)->SetSelected(true);
		view->ItemDisplayChanged(this);
		}
	view->ScrollToSelection();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static void FontChanged()
{
	// uncache info
	itemHeight = 0;
}
]]></method>

<method access="public" mod-time="Fri, 21 Apr 2000 00:48:10 PDT"><![CDATA[
static void ExtraInfoDisplayChanged()
{
	showLines = Prefs()->GetBoolPref("showLines");
	showDates = Prefs()->GetBoolPref("showDates");
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Access"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int NumSelections()
{
	int numSelections = 0;
	if (subject->Selected())
		numSelections += 1;
	int numArticles = subject->NumArticles();
	for (int i=0; i<numArticles; i++) {
		if (subject->ArticleAt(i)->Selected())
			numSelections += 1;
		}
	return numSelections;
}
]]></method>

<method access="public" mod-time="Fri, 21 Apr 2000 00:49:46 PDT"><![CDATA[
static bool HasExtraInfo()
{
	return (showLines || showDates);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 10:00:10 PDT"><![CDATA[
void DrawSubject(BRect itemRect, BView* view)
{
	// setup
	SetupColors(view, itemRect, subject->Selected(), subject->FilterScore());

	// draw the mark
	int numArticles = subject->NumArticles();
	if (subject->AllRead()) {
		BPoint markStart(itemRect.left + numArticlesRight - view->StringWidth("√"),
		                 itemRect.bottom - baseline);
		view->DrawString("√", markStart);
		}
	else if (numArticles > 1) {
		int numUnread = subject->NumUnreadArticles();
		if (numUnread > 99)
			numUnread = 99;
		view->PushState();
		view->SetHighColor(ListColors::numArticlesColor);
		qstring numArticlesStr(numUnread);
		BPoint numArticlesStart(itemRect.left + numArticlesRight
		                        	- view->StringWidth(numArticlesStr.c_str()),
		                        itemRect.bottom - baseline);
		view->DrawString(numArticlesStr.c_str(), numArticlesStart);
		view->PopState();
		}

	// draw subject
	string_slice str = subject->GetSubject();
	view->DrawString(str.begin(), str.length(),
	                 BPoint(itemRect.left + subjectLeft, itemRect.bottom - baseline));
}
]]></method>

<method access="public" mod-time="Fri, 21 Apr 2000 00:46:15 PDT"><![CDATA[
void DrawArticle(int whichArticle, BRect itemRect, BView* view)
{
	// setup
	Article* article = subject->ArticleAt(whichArticle);
	SetupColors(view, itemRect, article->Selected(), article->FilterScore());
	float y = itemRect.bottom - baseline;

	// draw the mark
	if (article->IsRead()) {
		BPoint markStart(itemRect.left + articleMarkLeft, y);
		view->DrawString("√", markStart);
		}

	// draw author
	string_slice author = article->Author();
	view->DrawString(author.begin(), author.length(),
	                 BPoint(itemRect.left + articleLeft, y));

	// draw extra info
	if (showLines || showDates) {
		view->PushState();
		view->SetFont(&extraInfoFont);
		char str[64];
		float x = itemRect.right - itemRight;

		// lines
		if (showLines) {
			int count = article->Lines();
			char unit = 0;
			if (count >= 1000) {
				count /= 1000;
				unit = 'k';
				}
			sprintf(str, "%d%c", count, unit);
			view->DrawString(str, BPoint(x - extraInfoFont.StringWidth(str), y));
			x -= linesWidth;
			}

		// date
		if (showDates) {
			time_t date = article->Date();
			strftime(str, 64, "%Y.%m.%d", gmtime(&date));
			view->DrawString(str, BPoint(x - extraInfoFont.StringWidth(str), y));
			view->PopState();
			}
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetupColors(BView* view, BRect itemRect, bool selected, float filterScore)
{
	// clear background
	if (selected)
		view->SetLowColor(ListColors::selectedBgndColor);
	else
		view->SetLowColor(filterScore > 0 ? ListColors::hilitedBgndColor :
		                  ListColors::bgndColor);
	view->FillRect(itemRect, B_SOLID_LOW);

	// set up to draw
	view->SetHighColor(ListColors::textColor);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DeselectAllArticles()
{
	int numArticles = subject->NumArticles();
	for (int i=0; i<numArticles; i++)
		subject->ArticleAt(i)->SetSelected(false);
}
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 10:00:30 PDT"><![CDATA[
void OpenArticle(Article* article, Newsgroup* newsgroup)
{
	article->SetRead(true);
	OpenArticleThread* thread =
		new OpenArticleThread(newsgroup, article->ArticleNo(),
		                      subject->GetSubject(), article->Lines());
	thread->Go();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private Static"
]]></method>

<method access="public" mod-time="Fri, 21 Apr 2000 01:49:33 PDT"><![CDATA[
static void SetupFont()
{
	if (itemHeight != 0)
		return;

	// main info
	FontUtils::StringToFont(Prefs()->GetStringPref("listFont", defaultListFont), &font);
	font_height fontInfo;
	font.GetHeight(&fontInfo);
	itemHeight = ceil(fontInfo.ascent + fontInfo.descent + fontInfo.leading);
	articleItemIndent = articleItemIndentEms * font.StringWidth("m");

	// extra info
	FontUtils::StringToFont(Prefs()->GetStringPref("extraInfoFont", defaultExtraInfoFont),
	                        &extraInfoFont);
	extraInfoFont.GetHeight(&fontInfo);
	float extraInfoHeight = ceil(fontInfo.ascent + fontInfo.descent + fontInfo.leading);
	if (extraInfoHeight > itemHeight)
		itemHeight = extraInfoHeight;
	linesWidth = extraInfoFont.StringWidth(" 000");
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Subject* subject;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Class variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static float itemHeight = 0;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static BFont font;
]]></variable>

<variable access="protected" mod-time="Fri, 21 Apr 2000 00:11:29 PDT"><![CDATA[
static BFont extraInfoFont;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static float articleItemIndent;
]]></variable>

<variable access="protected" mod-time="Fri, 21 Apr 2000 00:17:45 PDT"><![CDATA[
static float linesWidth;
]]></variable>

<variable access="protected" mod-time="Fri, 21 Apr 2000 00:44:56 PDT"><![CDATA[
static bool showLines;
]]></variable>

<variable access="protected" mod-time="Fri, 21 Apr 2000 00:45:12 PDT"><![CDATA[
static bool showDates;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private Static"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float expanderLeft = 3;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float itemLeft = 10;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float numArticlesRight = 14;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float subjectLeft = 17;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float articleItemIndentEms = 2;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float articleMarkLeft = 4;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float articleLeft = 12;
]]></variable>

<variable access="protected" mod-time="Fri, 21 Apr 2000 00:32:08 PDT"><![CDATA[
static const float itemRight = 4;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float baseline = 3;
]]></variable>

</class>


<class mod-time="Sat, 08 Apr 2000 10:02:19 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
SubjectSubjectTree
</name>
<superclasses>
public SubjectTree
</superclasses>
<hIncludes><![CDATA[
#include "SubjectTree.h"
#include "string_slice.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Subject.h"

class SubjectSubjectAdaptor : public SubjectTreeAdaptor {
public:
	SubjectSubjectAdaptor(Subject* subjectIn)
		: SubjectTreeAdaptor(subjectIn) {}
	bool	operator==(const OrderedObject& otherObject)
	    		{ return subject->GetSubject() == ((SubjectSubjectAdaptor*) &otherObject)->subject->GetSubject(); }
	bool	operator<(const OrderedObject& otherObject)
	    		{ return subject->GetSubject() < ((SubjectSubjectAdaptor*) &otherObject)->subject->GetSubject(); }
};


class SubjectSearchAdaptor : public OrderedObject {
public:
	SubjectSearchAdaptor(string_slice subjectIn)
		: subject(subjectIn) {}
	bool	operator==(const OrderedObject& otherObject)
	    		{ return subject == ((SubjectSubjectAdaptor*) &otherObject)->subject->GetSubject(); }
	bool	operator<(const OrderedObject& otherObject)
	    		{ return subject < ((SubjectSubjectAdaptor*) &otherObject)->subject->GetSubject(); }

protected:
	string_slice	subject;
};
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"SubjectTree virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
SubjectTreeAdaptor* MakeAdaptor(Subject* subject)
{
	return new SubjectSubjectAdaptor(subject);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 10:02:19 PDT"><![CDATA[
Subject* Find(string_slice subject)
{
	SubjectSearchAdaptor adaptor(subject);
	OrderedObject* foundObj = FindObject(&adaptor);
	return (foundObj ? ((SubjectSubjectAdaptor*) foundObj)->subject : NULL);
}
]]></method>

</class>


<class mod-time="Sat, 08 Apr 2000 10:03:10 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
SubjectFilterTree
</name>
<superclasses>
public SubjectTree
</superclasses>
<hIncludes><![CDATA[
#include "SubjectTree.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Subject.h"

class SubjectFilterAdaptor : public SubjectTreeAdaptor {
public:
	SubjectFilterAdaptor(Subject* subjectIn)
		: SubjectTreeAdaptor(subjectIn) {}
	bool	operator==(const OrderedObject& otherObject);
	bool	operator<(const OrderedObject& otherObject);
};

bool SubjectFilterAdaptor::operator==(const OrderedObject& otherObject)
{
	Subject* otherSubject = ((SubjectFilterAdaptor*) &otherObject)->subject;
	if (subject->FilterScore() != otherSubject->FilterScore())
		return false;
	else if (subject->MinArticleDate() != otherSubject->MinArticleDate())
		return false;
	else
		return (subject->GetSubject() == otherSubject->GetSubject());
}

bool SubjectFilterAdaptor::operator<(const OrderedObject& otherObject)
{
	Subject* otherSubject = ((SubjectFilterAdaptor*) &otherObject)->subject;
	if (subject->FilterScore() != otherSubject->FilterScore())
		// descending order
		return (subject->FilterScore() > otherSubject->FilterScore());
	else if (subject->MinArticleDate() != otherSubject->MinArticleDate())
		return (subject->MinArticleDate() < otherSubject->MinArticleDate());
	else
		return (subject->GetSubject() < otherSubject->GetSubject());
}

]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"SubjectTree virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
SubjectTreeAdaptor* MakeAdaptor(Subject* subject)
{
	return new SubjectFilterAdaptor(subject);
}
]]></method>

</class>


<class mod-time="Sat, 08 Apr 2000 10:06:06 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
AATreeListView
</name>
<superclasses>
public BView
</superclasses>
<hIncludes><![CDATA[
#include <View.h>

class ListableTree;
class ListableObject;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "ListableTree.h"
#include "ListableObject.h"
#include <Window.h>
#include <Message.h>
#include <Application.h>
#include <ScrollBar.h>
#include <ScrollView.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
AATreeListView(BRect frame, ListableTree* treeIn, const char* name = NULL,
               uint32 resizingMode = B_FOLLOW_ALL_SIDES,
               uint32 flags = 0)
	: BView(frame, name, resizingMode, flags | B_WILL_DRAW | B_FRAME_EVENTS | B_NAVIGABLE),
	  tree(treeIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Hooks"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetTree(ListableTree* newTree)
{
	tree = newTree;
	UpdateScrollBar();
	Invalidate();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ListableTree* Tree()
{
	return tree;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void InvalidateItem(ListableObject* item)
{
	BRect rect = Bounds();
	rect.top = tree->YForObject(item);
	rect.bottom = rect.top + item->DisplayHeight();
	Invalidate(rect);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void SelectItem(ListableObject* item)
{
	tree->SelectObject(item);
	InvalidateItem(item);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void DeselectItem(ListableObject* item)
{
	tree->DeselectObject(item);
	InvalidateItem(item);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void SelectAll()
{
	tree->SelectAllObjects();
	Invalidate();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void DeselectAll()
{
	// since we may not have a backing bitmap, we're gonna avoid all unnecessary
	// invalidation
	int numSelections = tree->NumSelections();
	if (numSelections == 0)
		return;
	ListableObject* singleItem = NULL;
	if (tree->NumSelections() == 1)
		singleItem = tree->SelectedObjectAt(0);

	tree->DeselectAllObjects();

	if (singleItem)
		InvalidateItem(singleItem);
	else
		Invalidate();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Select(int index)
{
	SelectItem((ListableObject*) tree->ObjectAt(index));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Deselect(int index)
{
	DeselectItem((ListableObject*) tree->ObjectAt(index));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SelectFirst()
{
	SelectItem((ListableObject*) tree->ObjectAt(0));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int NumSelections()
{
	return tree->NumSelections();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ListableObject* SelectionAt(int index)
{
	return tree->SelectedObjectAt(index);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void OpenSelections()
{
	int numSelections = tree->NumSelections();
	for (int i=0; i<numSelections; i++)
		tree->SelectedObjectAt(i)->Open(this);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ScrollToSelection()
{
	// see if a selected item is already visible
	ListableObject* firstItem = tree->FirstSelectedObject();
	if (firstItem == NULL)
		return;
	ListableObject* lastItem = tree->LastSelectedObject();
	BRect bounds = Bounds();
	int firstY = tree->YForObject(firstItem);
	if (firstY >= bounds.top &&
			tree->YForObject(lastItem) + lastItem->DisplayHeight() - 1 <= bounds.bottom)
		return;

	// scroll
	ScrollTo(0, firstY);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int IndexOf(ListableObject* object)
{
	return tree->IndexOf(object);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int NumObjects()
{
	return tree->NumObjects();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"BView virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Draw(BRect updateRect)
{
	// figure out which items we're drawing
	int firstItem = tree->IndexForY(updateRect.top);
	if (firstItem < 0)
		firstItem = 0;
	int32 lastItem = tree->IndexForY(updateRect.bottom);
	int32 numItems = tree->NumObjects();
	if (lastItem < 0 || lastItem >= numItems)
		lastItem = numItems - 1;

	// draw
	BRect itemRect = Bounds();
	itemRect.top = tree->YAtIndex(firstItem);
	for (int32 i=firstItem; i <= lastItem; i++) {
		// draw item
		ListableObject* item = dynamic_cast<ListableObject*>(tree->ObjectAt(i));
		if (item == NULL)
			continue;
		itemRect.bottom = itemRect.top + item->DisplayHeight() - 1;
		item->Draw(itemRect, this);

		// bump itemRect
		itemRect.top = itemRect.bottom + 1;
		}

	// clear any left-over area
	if (itemRect.top < updateRect.bottom) {
		rgb_color whiteColor = { 255, 255, 255, 0 };
		SetLowColor(whiteColor);
		itemRect.bottom = updateRect.bottom;
		FillRect(itemRect, B_SOLID_LOW);
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MouseDown(BPoint point)
{
	if (!IsFocus())
		MakeFocus();

	int oldHeight = tree->DisplayHeight();

	// tell the object
	int index = tree->IndexForY(point.y);
	if (index < 0)
		return;
	ListableObject* item = dynamic_cast<ListableObject*>(tree->ObjectAt(index));
	if (item == NULL)
		return;
	BRect itemRect = Bounds();
	itemRect.top = tree->YAtIndex(index);
	itemRect.bottom = itemRect.top + item->DisplayHeight() - 1;
	BMessage* message = Window()->CurrentMessage();
	int clicks = message->FindInt32("clicks");
	int modifiers = message->FindInt32("modifiers");
	item->MouseDown(point, itemRect, clicks, modifiers, this);
	// might have changed expansion or selection, so readjust the tree
	tree->ObjectChanged(item);
	if (tree->DisplayHeight() != oldHeight)
		UpdateScrollBar();
}
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 10:05:15 PDT"><![CDATA[
void KeyDown(const char *bytes, int32 numBytes)
{
	uint32 modifiers;

	switch (bytes[0]) {
		case B_ENTER:
		case ' ':
			OpenSelections();
			break;

		case B_UP_ARROW:
			{
			ListableObject* firstSelected = tree->FirstSelectedObject();
			if (firstSelected) {
				modifiers = Window()->CurrentMessage()->FindInt32("modifiers");
				firstSelected->SelectUp(modifiers, this);
				}
			else if (tree->NumObjects() > 0) {
				Select(tree->NumObjects() - 1);
				ScrollToSelection();
				}
			}
			break;

		case B_DOWN_ARROW:
			{
			ListableObject* lastSelected = tree->LastSelectedObject();
			if (lastSelected) {
				modifiers = Window()->CurrentMessage()->FindInt32("modifiers");
				lastSelected->SelectDown(modifiers, this);
				}
			else if (tree->NumObjects() > 0) {
				Select(0);
				ScrollToSelection();
				}
			}
			break;

		case B_PAGE_UP:
			{
			float visibleHeight = Bounds().Height() + 1;
			ScrollBy(0, -(visibleHeight - SmallStepSize));
			}
			break;

		case B_PAGE_DOWN:
			{
			float visibleHeight = Bounds().Height() + 1;
			ScrollBy(0, visibleHeight - SmallStepSize);
			}
			break;

		case B_HOME:
			ScrollTo(0, 0);
			break;

		case B_END:
			{
			float visibleHeight = Bounds().Height();
			ScrollTo(0, tree->DisplayHeight() - visibleHeight);
			}
			break;

		case B_BACKSPACE:
		case B_DELETE:
/***
			if (selection >= 0)
				RemoveSelectedItem(selection);
***/
			break;

		default:
			BView::KeyDown(bytes, numBytes);
			break;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MouseMoved(BPoint point, uint32 transit, const BMessage *message)
{
	if (transit == B_ENTERED_VIEW || message == NULL)
		be_app->SetCursor(B_HAND_CURSOR);
	// don't bother calling inherited, since we know it does nothing
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void TargetedByScrollView(BScrollView* scrollerIn)
{
	scroller = scrollerIn;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AttachedToWindow()
{
	UpdateScrollBar();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void FrameResized(float width, float height)
{
	UpdateScrollBar();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"For Users"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void NumItemsChanged()
{
	UpdateScrollBar();
	Invalidate();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ItemDisplayChanged(ListableObject* item)
{
	tree->ObjectChanged(item);
	UpdateScrollBar();
	Invalidate();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void UpdateScrollBar()
{
	// sanity clause
	if (scroller == NULL)
		return;

	BScrollBar* scrollBar = scroller->ScrollBar(B_VERTICAL);
	float visibleHeight = Bounds().Height() + 1;
	float dataHeight = tree->DisplayHeight();
	float scrollMax = dataHeight - visibleHeight;
	if (scrollMax < 0)
		scrollMax = 0;
	scrollBar->SetRange(0, scrollMax);
	scrollBar->SetSteps(SmallStepSize, visibleHeight - SmallStepSize);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ListableTree* tree;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BScrollView* scroller;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float SmallStepSize = 12;
]]></variable>

</class>


<class mod-time="Fri, 14 Apr 2000 18:09:22 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
"NewsrcWind"
</name>
</class>


<class mod-time="Sat, 08 Apr 2000 10:47:13 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
NewsrcWind
</name>
<superclasses>
public BWindow, public ThreadOwner
</superclasses>
<hIncludes><![CDATA[
#include <Window.h>
#include "ThreadOwner.h"
#include "string_slice.h"

class Newsrc;
class NewsgroupsView;
class GetGroupStatsThread;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "NewsgroupsView.h"
#include "GetGroupStatsThread.h"
#include "NNTPApp.h"
#include "Prefs.h"
#include "qstring.h"
#include "Messages.h"
#include <MenuBar.h>
#include <Menu.h>
#include <MenuItem.h>
#include <ScrollView.h>
#include <ScrollBar.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
NewsrcWind(Newsrc* newsrc, string_slice fileName)	// assumes ownership
	: BWindow(BRect(0, 0, defaultWidth, defaultHeight), qstring(fileName).c_str(),
	          B_DOCUMENT_WINDOW, 0)
{
	// menu bar
	BMenuBar* menuBar = new BMenuBar(BRect(0, 0, 0, 0), "");
	BMenu* newsgroupMenu = new BMenu("Newsgroups");
	BMenuItem* filtersItem =
		new BMenuItem("Show Filters", new BMessage(ShowFiltersMessage), 'F');
	filtersItem->SetTarget(be_app_messenger);
	newsgroupMenu->AddItem(filtersItem);
	BMenuItem* groupsListItem =
		new BMenuItem("Show All Newsgroups", new BMessage(ShowGroupsListMessage));
	groupsListItem->SetTarget(be_app_messenger);
	newsgroupMenu->AddItem(groupsListItem);
	BMenuItem* prefsItem =
		new BMenuItem("Show Preferences", new BMessage(ShowPrefsMessage), ';');
	prefsItem->SetTarget(be_app_messenger);
	newsgroupMenu->AddItem(prefsItem);
	BMenuItem* aboutItem =
		new BMenuItem("About Item...", new BMessage(ShowAboutMessage));
	aboutItem->SetTarget(be_app_messenger);
	newsgroupMenu->AddItem(aboutItem);
	menuBar->AddItem(newsgroupMenu);
	AddChild(menuBar);

	// make the listView
	BRect listViewFrame(0, menuBar->Frame().Height() + 1,
	                    defaultWidth - B_V_SCROLL_BAR_WIDTH, defaultHeight);
	listView = new NewsgroupsView(listViewFrame, newsrc);

	// make the scrollView
	BScrollView* scrollView =
		new BScrollView("", listView, B_FOLLOW_ALL_SIDES, 0, false, true, B_NO_BORDER);
	AddChild(scrollView);

	// place it on the screen
	MoveTo(defaultLeft, defaultTop);
	BRect savedFrame = Prefs()->GetRectPref("newsrcWind.frame");
	if (savedFrame.IsValid()) {
		MoveTo(savedFrame.LeftTop());
		ResizeTo(savedFrame.Width(), savedFrame.Height());
		}

	// set up & show
	listView->MakeFocus();
	listView->Select(0);
	Show();

	// start the GetGroupStatsThread
	StartThread(new GetGroupStatsThread(newsrc, this));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~NewsrcWind()
{
	// notify the app
	((NNTPApp*) be_app)->WindowClosing(this);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void InvalidateNewsgroupAt(int index)
{
	Lock();
	listView->InvalidateItem(index);
	Unlock();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"BWindow virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Quit()
{
	// kill threads before taking down the window
	Hide();		// helps prevent deadlock
	KillOwnedThreads();
	BWindow::Quit();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void FrameMoved(BPoint screenPoint)
{
	BWindow::FrameMoved(screenPoint);
	SavePosition();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void FrameResized(float width, float height)
{
	BWindow::FrameResized(width, height);
	SavePosition();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SavePosition()
{
	// don't do it if we're the only NewsgroupWind
	for (int i=0; ; i++) {
		BWindow* wind = be_app->WindowAt(i);
		if (wind == NULL)
			break;
		if (wind != this && dynamic_cast<NewsrcWind*>(wind) != NULL)
			return;
		}

	Prefs()->SetRectPref("newsrcWind.frame", Frame());
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
NewsgroupsView* listView;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float defaultWidth = 300;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float defaultHeight = 400;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float defaultLeft = 50;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float defaultTop = 50;
]]></variable>

</class>


<class mod-time="Sat, 08 Apr 2000 10:53:53 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
ScrolledListView
</name>
<superclasses>
public BView
</superclasses>
<hIncludes><![CDATA[
#include <View.h>
]]></hIncludes>
<cppIncludes><![CDATA[
#include <Window.h>
#include <Application.h>
#include <ScrollBar.h>
#include <ScrollView.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ScrolledListView(BRect frame, const char *name,
                 uint32 resizingMode, uint32 flags)
	: BView(frame, name, resizingMode, flags), selection(-1), scroller(NULL),
	  active(true)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Pure Virtual"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual int NumItems()
{
	/** pure virtual **/
	return 0;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual float ItemHeight()
{
	/** pure virtual **/
	// real height *in pixels*
	return 0;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void DrawItem(int32 itemIndex, BRect itemRect, bool selected)
{
	/** pure virtual **/
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Hooks"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void OpenSelectedItem(int32 selectedIndex)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void RemoveSelectedItem(int32 selectedIndex)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void SelectionChanging(int32 newSelection, int32 oldSelection)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void ActivationChanging(bool toActive)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual bool CanRearrange()
{
	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void ItemMoved(int32 oldIndex, int32 newIndex)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Select(int32 index)
{
	int32 newSelection = index;
	if (newSelection < 0 || newSelection >= NumItems())
		newSelection = -1;
	if (selection != newSelection) {
		SelectionChanging(newSelection, selection);
		selection = newSelection;
		Invalidate();
		}
}
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 10:50:26 PDT"><![CDATA[
void ScrollToSelection()
{
	if (selection < 0)
		return;

	// see if the selected item is already visible
	float itemHeight = ItemHeight();
	BRect bounds = Bounds();
	int32 firstItem = (int) (bounds.top / itemHeight);
	int32 lastItem = (int) (bounds.bottom / itemHeight);
	if (selection >= firstItem && selection <= lastItem)
		return;

	// scroll
	ScrollTo(0, selection * itemHeight);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void InvalidateItem(int index)
{
	float itemHeight = ItemHeight();
	BRect itemRect = Bounds();
	itemRect.top = index * itemHeight;
	itemRect.bottom = itemRect.top + itemHeight - 1;
	Invalidate(itemRect);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Activate()
{
	if (active)
		return;

	SetFlags(Flags() | B_NAVIGABLE);
	active = true;
	ActivationChanging(true);
	Invalidate();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Deactivate()
{
	if (!active)
		return;

	SetFlags(Flags() & ~B_NAVIGABLE);
	active = false;
	ActivationChanging(false);
	Invalidate();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"BView virtuals"
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 10:52:36 PDT"><![CDATA[
void Draw(BRect updateRect)
{
	// figure out which items we're drawing
	float itemHeight = ItemHeight();
	int32 firstItem = (int) (updateRect.top / itemHeight);
	if (firstItem < 0)
		firstItem = 0;
	int32 lastItem = (int) ((updateRect.bottom + itemHeight - 1) / itemHeight);
	int32 numItems = NumItems();
	if (lastItem >= numItems)
		lastItem = numItems - 1;

	// draw
	BRect itemRect = Bounds();
	itemRect.top = firstItem * itemHeight;
	itemRect.bottom = itemRect.top + itemHeight - 1;
	for (int32 i=firstItem; i <= lastItem; i++) {
		// draw item
		DrawItem(i, itemRect, i == selection);

		// bump itemRect
		itemRect.top = itemRect.bottom + 1;
		itemRect.bottom = itemRect.top + itemHeight - 1;
		}

	// clear any left-over area
	if (itemRect.top < updateRect.bottom) {
		itemRect.bottom = updateRect.bottom;
		FillRect(itemRect, B_SOLID_LOW);
		}
}
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 10:53:11 PDT"><![CDATA[
void MouseDown(BPoint point)
{
	int32 clicks; 
	Window()->CurrentMessage()->FindInt32("clicks", &clicks);

	Activate();
	if (!IsFocus())
		MakeFocus();

	int32 newSelection = (int) (point.y / ItemHeight());
	if (newSelection < 0 || newSelection >= NumItems())
		newSelection = -1;

	// double-click opens
	if (selection == newSelection && selection >= 0 && clicks > 1)
		OpenSelectedItem(selection);

	// first click selects, maybe moves
	else {
		Select(newSelection);
		if (CanRearrange())
			TrackRearrangement(point);
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void KeyDown(const char *bytes, int32 numBytes)
{
	switch (bytes[0]) {
		case B_ENTER:
		case ' ':
			if (selection >= 0)
				OpenSelectedItem(selection);
			break;

		case B_UP_ARROW:
			int32 newSelection;
			if (selection < 0)
				newSelection = NumItems() - 1;
			else if (selection > 0)
				newSelection = selection - 1;
			else
				newSelection = selection;
			Select(newSelection);
			ScrollToSelection();
			break;

		case B_DOWN_ARROW:
			if (selection < NumItems() - 1)
				Select(selection + 1);
			ScrollToSelection();
			break;

		case B_PAGE_UP:
			{
			float itemHeight = ItemHeight();
			float visibleHeight = Bounds().Height() + 1;
			ScrollBy(0, -(visibleHeight - itemHeight));
			}
			break;

		case B_PAGE_DOWN:
			{
			float itemHeight = ItemHeight();
			float visibleHeight = Bounds().Height() + 1;
			ScrollBy(0, visibleHeight - itemHeight);
			}
			break;

		case B_HOME:
			ScrollTo(0, 0);
			break;

		case B_END:
			{
			float visibleHeight = Bounds().Height();
			ScrollTo(0, NumItems() * ItemHeight() - visibleHeight);
			}
			break;

		case B_BACKSPACE:
		case B_DELETE:
			if (selection >= 0)
				RemoveSelectedItem(selection);
			break;

		default:
			BView::KeyDown(bytes, numBytes);
			break;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MouseMoved(BPoint point, uint32 transit, const BMessage *message)
{
	if (transit == B_ENTERED_VIEW || message == NULL)
		be_app->SetCursor(B_HAND_CURSOR);
	// don't bother calling inherited, since we know it does nothing
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void TargetedByScrollView(BScrollView* scrollerIn)
{
	scroller = scrollerIn;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AttachedToWindow()
{
	UpdateScrollBar();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void FrameResized(float width, float height)
{
	UpdateScrollBar();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"For Users"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void NumItemsChanged()
{
	UpdateScrollBar();
	if (selection >= NumItems())
		selection = -1;
	Invalidate();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void UpdateScrollBar()
{
	// sanity clause
	if (scroller == NULL)
		return;

	BScrollBar* scrollBar = scroller->ScrollBar(B_VERTICAL);
	float itemHeight = ItemHeight();
	float visibleHeight = Bounds().Height() + 1;
	float dataHeight = NumItems() * itemHeight;
	float scrollMax = dataHeight - visibleHeight;
	if (scrollMax < 0)
		scrollMax = 0;
	scrollBar->SetRange(0, scrollMax);
	scrollBar->SetSteps(itemHeight, visibleHeight - itemHeight);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void TrackRearrangement(BPoint point)
{
/***
	static const rgb_color indicatorColor = { 128, 128, 128, 256 };
***/

	// sanity clause
	if (selection < 0)
		return;

	// first, because the selection might have changed, redraw the whole thing
	BRect bounds = Bounds();
	Draw(bounds);

	// track the movement
	int newIndex = -1;
	while (true) {
		uint32 buttons;
		GetMouse(&point, &buttons, true);
			// UNDOCUMENTED FACT ABOUT GetMouse():
			// If the "checkQueue" argument is true, GetMouse() will cause
			// the invalid region to be redrawn!  In our case we don't want
			// that, because sometimes it means the indicator gets clobbered,
			// since scrolling invalidates areas.
			// BUT, if "checkQueue" is false, something goes wrong after
			// you've held the mouse down for a while (about six seconds on
			// my machine), and the tracking loop starts to respond really
			// slowly.  Is the queue filling up?  Maybe with MOUSE_MOVED
			// messages, but I tried cleaning them out and it didn't help.
			// It didn't even delay the onset of the problem.
			// SO:  We leave "checkQueue" as true, just like the example in
			// the BeBook, but we do this GetMouse() call *before* we do
			// our drawing.  This means a bit of flashiness since items can
			// be drawn twice, but guarantees that everything will look right.
		if (buttons == 0)
			break;

		newIndex = TrackInsertionStep(point, newIndex);
		}

/***
	// track the movement
	float itemHeight = ItemHeight();
	int32 numItems = NumItems();
	int32 newIndex = -1;
	uint32 buttons = 1;
	while (buttons) {
		// autoscroll
		if (point.y < bounds.top) {
			if (bounds.top > 0) {
				ScrollBy(0, -itemHeight);
				bounds.OffsetBy(0, -itemHeight);
				}
			point.y = bounds.top;
			}
		else if (point.y > bounds.bottom) {
			if (bounds.bottom < numItems * itemHeight - 1) {
				ScrollBy(0, itemHeight);
				bounds.OffsetBy(0, itemHeight);
				}
			point.y = bounds.bottom + 1;	// need the +1 to let it get beyond the last item
			}

		// figure out where it is now
		int32 curNewIndex = point.y / itemHeight;
		if (curNewIndex < 0)
			curNewIndex = 0;
		else if (curNewIndex > numItems)	// can move beyond the last item
			curNewIndex = numItems;

		GetMouse(&point, &buttons, true);
			// UNDOCUMENTED FACT ABOUT GetMouse():
			// If the "checkQueue" argument is true, GetMouse() will cause
			// the invalid region to be redrawn!  In our case we don't want
			// that, because sometimes it means the indicator gets clobbered,
			// since scrolling invalidates areas.
			// BUT, if "checkQueue" is false, something goes wrong after
			// you've held the mouse down for a while (about six seconds on
			// my machine), and the tracking loop starts to respond really
			// slowly.  Is the queue filling up?  Maybe with MOUSE_MOVED
			// messages, but I tried cleaning them out and it didn't help.
			// It didn't even delay the onset of the problem.
			// SO:  We leave "checkQueue" as true, just like the example in
			// the BeBook, but we do this GetMouse() call *before* we do
			// our drawing.  This means a bit of flashiness since items can
			// be drawn twice, but guarantees that everything will look right.
			// We can get away with updating "point" and "buttons" here (instead
			// of at the end of the loop as you'd normally do) because they're
			// not used from here on.

		// draw
		if (curNewIndex != newIndex) {
			// redraw items bordering old indicator, to clear it
			if (newIndex >= 0) {
				if (newIndex > 0)
					DrawItemAt(newIndex - 1);
				if (newIndex < numItems)
					DrawItemAt(newIndex);
				else {
					// need to clean up bottom
					BRect bottomRect = bounds;
					bottomRect.top = newIndex * itemHeight;
					FillRect(bottomRect, B_SOLID_LOW);
					}
				}

			// draw new indicator
			newIndex = curNewIndex;
			SetHighColor(indicatorColor);
			SetPenSize(2.0);
			float indicatorY = newIndex * itemHeight;
			StrokeLine(BPoint(bounds.left, indicatorY),
			           BPoint(bounds.right, indicatorY));
			SetPenSize(1.0);
			}

		// go around again
		Flush();
		snooze(50000);	// BeBook-recommended snooze time is 20000, but we don't need to be that greedy
		}
***/

	// move the item
	if (newIndex >= 0) {
		if (newIndex > selection)
			newIndex -= 1;
		if (newIndex != selection) {
			ItemMoved(selection, newIndex);
			selection = newIndex;
			}
		}

	Invalidate();
}
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 10:53:31 PDT"><![CDATA[
int TrackInsertionStep(BPoint point, int prevInsertionIndex)
{
	BRect bounds = Bounds();
	float itemHeight = ItemHeight();
	int32 numItems = NumItems();

	// autoscroll
	if (point.y < bounds.top) {
		if (bounds.top > 0) {
			ScrollBy(0, -itemHeight);
			bounds.OffsetBy(0, -itemHeight);
			}
		point.y = bounds.top;
		}
	else if (point.y > bounds.bottom) {
		if (bounds.bottom < numItems * itemHeight - 1) {
			ScrollBy(0, itemHeight);
			bounds.OffsetBy(0, itemHeight);
			}
		point.y = bounds.bottom + 1;	// need the +1 to let it get beyond the last item
		}

	// figure out where it is now
	int32 curInsertionIndex = (int) (point.y / itemHeight);
	if (curInsertionIndex < 0)
		curInsertionIndex = 0;
	else if (curInsertionIndex > numItems)	// can move beyond the last item
		curInsertionIndex = numItems;

	// draw
	if (curInsertionIndex != prevInsertionIndex) {
		// redraw items bordering old indicator, to clear it
		if (prevInsertionIndex >= 0) {
			if (prevInsertionIndex > 0)
				DrawItemAt(prevInsertionIndex - 1);
			if (prevInsertionIndex < numItems)
				DrawItemAt(prevInsertionIndex);
			else {
				// need to clean up bottom
				BRect bottomRect = bounds;
				bottomRect.top = prevInsertionIndex * itemHeight;
				FillRect(bottomRect, B_SOLID_LOW);
				}
			}

		// draw new indicator
		SetHighColor(insertionIndicatorColor);
		SetPenSize(2.0);
		float indicatorY = curInsertionIndex * itemHeight;
		StrokeLine(BPoint(bounds.left, indicatorY),
		           BPoint(bounds.right, indicatorY));
		SetPenSize(1.0);
		}

	Flush();

	return curInsertionIndex;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DrawItemAt(int32 index)
{
	float itemHeight = ItemHeight();
	BRect itemRect = Bounds();
	itemRect.top = index * itemHeight;
	itemRect.bottom = itemRect.top + itemHeight - 1;
	DrawItem(index, itemRect, (index == selection));
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int selection;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BScrollView* scroller;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool active;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Sat, 08 Apr 2000 10:50:07 PDT"><![CDATA[
static const rgb_color insertionIndicatorColor = { 128, 128, 128, 255 };
]]></variable>

</class>


<class mod-time="Tue, 18 Apr 2000 23:02:21 PDT" wind-frame="134.000000,105.000000,774.000000,635.000000" list-views-height="0.000000">
<name>
NewsgroupsView
</name>
<superclasses>
public ScrolledListView, public PrefsChangeClient
</superclasses>
<hIncludes><![CDATA[
#include "ScrolledListView.h"
#include "PrefsChangeClient.h"

class Newsrc;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Newsrc.h"
#include "Newsgroup.h"
#include "OpenGroupThread.h"
#include "TrackGroupDragThread.h"
#include "NewsrcWind.h"
#include "NewsgroupWind.h"
#include "DragUtils.h"
#include "FontUtils.h"
#include "ListColors.h"
#include "Prefs.h"
#include "string_slice.h"
#include "qstring.h"
#include <Alert.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
NewsgroupsView(BRect frame, Newsrc* newsrcIn)	// assumes ownership
	: ScrolledListView(frame, "Newsrc", B_FOLLOW_ALL_SIDES,
	                   B_WILL_DRAW | B_FRAME_EVENTS | B_NAVIGABLE),
      newsrc(newsrcIn), itemHeight(0)
{
	SetViewColor(B_TRANSPARENT_32_BIT);
	newsrc->AttachedToView(this);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~NewsgroupsView()
{
	delete newsrc;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"ScrolledListView virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int NumItems()
{
	return newsrc->NumNewsgroups();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
float ItemHeight()
{
	SetupFont();
	return itemHeight;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DrawItem(int32 itemIndex, BRect itemRect, bool selected)
{
	SetupFont();

	// set up
	SetHighColor(ListColors::textColor);
	SetLowColor(selected ? ListColors::selectedBgndColor : ListColors::bgndColor);
	FillRect(itemRect, B_SOLID_LOW);
	SetFont(&font);

	// draw
	Newsgroup* newsgroup = newsrc->NewsgroupAt(itemIndex);
	// name
	string_slice name = newsgroup->Name();
	DrawString(name.begin(), name.length(),
	           BPoint(itemRect.left + groupNameLeft, itemRect.bottom - baseline));
	// numArticles
	int numArticles = newsgroup->NumUnreadArticles();
	if (numArticles > 0) {
		SetHighColor(numArticlesColor);
		qstring numArticlesStr(numArticles);
		if (numArticles > 9999) {
			numArticlesStr = qstring((numArticles + 500)/1000);
			numArticlesStr += "k";
			}
		float width = StringWidth(numArticlesStr.c_str());
		DrawString(numArticlesStr.c_str(),
		           BPoint(itemRect.left + leftMargin + numArticlesWidth - width,
		                  itemRect.bottom - baseline));
		}

	SetLowColor(ListColors::bgndColor);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void OpenSelectedItem(int32 selectedIndex)
{
	Newsgroup* newsgroup = newsrc->NewsgroupAt(selectedIndex);
	BWindow* wind = newsgroup->Window();
	if (wind)
		wind->Activate();
	else
		((NewsrcWind*) Window())->StartThread(new OpenGroupThread(newsgroup));
}
]]></method>

<method access="public" mod-time="Tue, 18 Apr 2000 18:02:50 PDT"><![CDATA[
void RemoveSelectedItem(int32 selectedIndex)
{
	// confirm
	const char* message =
		"Are you sure you want to delete the selected group?  You won't be able to undo it.";
	BAlert* alert =
		new BAlert("Confirm group deletion", message, "Delete", "Cancel");
	alert->SetShortcut(1, B_ESCAPE);
	alert->SetShortcut(0, 'd');
	int buttonIndex = alert->Go();
	if (buttonIndex != 0)
		return;

	// remove
	newsrc->RemoveNewsgroupAt(selectedIndex);
	NumItemsChanged();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool CanRearrange()
{
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ItemMoved(int32 oldIndex, int32 newIndex)
{
	Newsgroup* newsgroup = newsrc->RemoveNewsgroupAt(oldIndex);
	newsrc->AddNewsgroupAt(newsgroup, newIndex);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MouseMoved(BPoint point, uint32 transit, const BMessage* message)
{
	if (transit == B_ENTERED_VIEW && message != NULL && DragUtils::HasNewsgroups(message))
		(new TrackGroupDragThread(this, newsrc, message))->Go();
	else
		ScrolledListView::MouseMoved(point, transit, message);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"PrefsChangeClient virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void PrefChanged(string_slice prefName)
{
	if (prefName == "listBgndColor" || prefName == "listSelectedBgndColor" ||
			prefName == "listTextColor") {
		Window()->Lock();
		Invalidate();
		Window()->Unlock();
		}
	else if (prefName == "listFont") {
		itemHeight = 0;	// uncache
		SetupFont();
		Window()->Lock();
		NumItemsChanged();
		Window()->Unlock();
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetupFont()
{
	if (itemHeight != 0)
		return;

	FontUtils::StringToFont(Prefs()->GetStringPref("listFont", defaultListFont), &font);
	font_height fontInfo;
	font.GetHeight(&fontInfo);
	itemHeight = ceil(fontInfo.ascent + fontInfo.descent + fontInfo.leading);
	baseline = ceil(fontInfo.descent);
	float emWidth = font.StringWidth("m");

	numArticlesWidth = font.StringWidth("9999");
	groupNameLeft = leftMargin + numArticlesWidth + separationEms * emWidth;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Newsrc* newsrc;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"  Display"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BFont font;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
float itemHeight;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
float baseline;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
float numArticlesWidth;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
float groupNameLeft;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float leftMargin = 4;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float separationEms = 0.2;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const rgb_color numArticlesColor = { 128, 128, 128, 255 };
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Obsolete"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const rgb_color XtextColor = { 0, 0, 0, 255 };
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const rgb_color XbgndColor = { 255, 255, 255, 255 };
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const rgb_color XhiliteBgndColor = { 192, 192, 192, 255 };
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float XnumArticlesRight = 27;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float XgroupNameLeft = 30;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float Xbaseline = 2;
]]></variable>

</class>


<class mod-time="Sat, 08 Apr 2000 10:55:48 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
TrackGroupDragThread
</name>
<superclasses>
public Thread
</superclasses>
<hIncludes><![CDATA[
#include "Thread.h"

class ScrolledListView;
class Newsrc;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "ScrolledListView.h"
#include "Newsrc.h"
#include "Newsgroup.h"
#include "DragUtils.h"
#include <Message.h>
#include <Window.h>
#include <List.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
TrackGroupDragThread(ScrolledListView* viewIn, Newsrc* newsrcIn, const BMessage* messageIn)
	: view(viewIn), newsrc(newsrcIn), message(new BMessage(*messageIn))
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~TrackGroupDragThread()
{
	delete message;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Thread virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Action()
{
	// track the drag
	int insertionIndex = -1;
	while (true) {
		BWindow* wind = view->Window();
		if (wind == NULL || !wind->Lock())
			return;

		// get the mouse, and stop dragging if it leaves the view horizontally
		// (not vertically, since we want that to autoscroll)
		BPoint point;
		uint32 buttons;
		view->GetMouse(&point, &buttons, true);
		if (buttons == 0) {
			view->Invalidate();
			wind->Unlock();
			break;
			}
		BRect bounds = view->Bounds();
		if (point.x < bounds.left || point.x > bounds.right) {
			view->Invalidate();
			wind->Unlock();
			return;
			}

		insertionIndex = view->TrackInsertionStep(point, insertionIndex);

		wind->Unlock();

		snooze(50000);
		}

	InsertDragAt(insertionIndex);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void InsertDragAt(int index)
{
	int i;

	BList* groupNames = DragUtils::GetDraggedGroups(message);

	// add the groups
	int numDraggedGroups = groupNames->CountItems();
	for (i=0; i<numDraggedGroups; i++) {
		string_slice groupName = *(string_slice*) groupNames->ItemAt(i);
		if (newsrc->NewsgroupNamed(groupName) == NULL) {
			newsrc->AddNewsgroupAt(new Newsgroup(groupName, newsrc), index);
			index++;
			}
		}
	if (view->Window()->Lock()) {
		view->NumItemsChanged();
		view->Window()->Unlock();
		}

	// delete groupNames
	for (i=0; i<numDraggedGroups; i++)
		delete (string_slice*) groupNames->ItemAt(i);
	delete groupNames;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ScrolledListView* view;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Newsrc* newsrc;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BMessage* message;
]]></variable>

</class>


<class mod-time="Fri, 14 Apr 2000 18:09:09 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
"NewsgroupWind"
</name>
</class>


<class mod-time="Sat, 15 Apr 2000 02:37:20 PDT" wind-frame="174.000000,140.000000,814.000000,670.000000" list-views-height="0.000000">
<name>
NewsgroupWind
</name>
<superclasses>
public BWindow
</superclasses>
<hIncludes><![CDATA[
#include <Window.h>

class Newsgroup;
class SubjectsView;
class Subject;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Newsgroup.h"
#include "SubjectsView.h"
#include "SubjectTree.h"
#include "Subject.h"
#include "NNTPApp.h"
#include "Filters.h"
#include "FilterGroup.h"
#include "Filter.h"
#include "ExtractBinariesThread.h"
#include "Prefs.h"
#include "qstring.h"
#include "Messages.h"
#include <MenuBar.h>
#include <Menu.h>
#include <MenuItem.h>
#include <ScrollView.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Sat, 15 Apr 2000 02:37:20 PDT"><![CDATA[
NewsgroupWind(Newsgroup* newsgroupIn)
	: BWindow(BRect(0, 0, DefaultWidth, DefaultHeight), "", B_DOCUMENT_WINDOW, 0),
	  newsgroup(newsgroupIn)
{
	// menu bar
	BMenuBar* menuBar = new BMenuBar(BRect(0, 0, 0, 0), "");
	BMenu* newsgroupMenu = new BMenu("Newsgroup");
	newsgroupMenu->AddItem(new BMenuItem("View By Filter Score/Date",
	                                     new BMessage(ViewByScoreMessage),
	                                     'F', B_SHIFT_KEY));
	newsgroupMenu->AddItem(new BMenuItem("View By Subject",
	                                     new BMessage(ViewBySubjectMessage),
	                                     'S', B_SHIFT_KEY));
	newsgroupMenu->AddSeparatorItem();
	BMenuItem* filtersItem =
		new BMenuItem("Show Filters", new BMessage(ShowFiltersMessage), 'F');
	filtersItem->SetTarget(be_app_messenger);
	newsgroupMenu->AddItem(filtersItem);
	BMenuItem* prefsItem =
		new BMenuItem("Show Preferences", new BMessage(ShowPrefsMessage), ';');
	prefsItem->SetTarget(be_app_messenger);
	newsgroupMenu->AddItem(prefsItem);
	menuBar->AddItem(newsgroupMenu);
	BMenu* articleMenu = new BMenu("Article");
	articleMenu->AddItem(new BMenuItem("Mark", new BMessage(MarkMessage), 'M'));
	articleMenu->AddItem(new BMenuItem("Unmark", new BMessage(UnmarkMessage), 'U'));
	articleMenu->AddItem(new BMenuItem("Kill Selected Subjects", new BMessage(KillSubjectsMessage), 'K'));
	articleMenu->AddItem(new BMenuItem("Hilite Selected Subjects", new BMessage(HiliteSubjectsMessage), 'H'));
	articleMenu->AddItem(new BMenuItem("Remove Read Articles", new BMessage(RemoveReadMessage),
	                                   'R', B_SHIFT_KEY));
	articleMenu->AddSeparatorItem();
	articleMenu->AddItem(new BMenuItem("Save...", new BMessage(SaveArticlesMessage), 'S'));
	articleMenu->AddItem(new BMenuItem("Append To...", new BMessage(AppendArticlesMessage), 'D'));
	articleMenu->AddItem(new BMenuItem("Extract Binaries", new BMessage(ExtractBinariesMessage), 'B'));
	articleMenu->AddItem(new BMenuItem("Extract Multipart Binary", new BMessage(ExtractMultipartBinaryMessage), 'E'));
	articleMenu->AddSeparatorItem();
	articleMenu->AddItem(new BMenuItem("Select All", new BMessage(B_SELECT_ALL), 'A'));
	menuBar->AddItem(articleMenu);
	AddChild(menuBar);

	// make the listView
	BRect listViewFrame(0, menuBar->Frame().Height() + 1,
	                    DefaultWidth - B_V_SCROLL_BAR_WIDTH, DefaultHeight);
	listView = new SubjectsView(listViewFrame, newsgroup->FilterTree());

	// make the scrollView
	BScrollView* scrollView =
		new BScrollView("", listView, B_FOLLOW_ALL_SIDES, 0, false, true, B_NO_BORDER);
	AddChild(scrollView);

	// set the title
	qstring title = newsgroup->Name();
	SetTitle(title.c_str());

	newsgroup->AttachedToWindow(this);

	// place it on the screen
	MoveTo(DefaultLeft, DefaultTop);
	BRect savedFrame = Prefs()->GetRectPref("newsgroupWind.frame");
	if (savedFrame.IsValid()) {
		MoveTo(savedFrame.LeftTop());
		ResizeTo(savedFrame.Width(), savedFrame.Height());
		}

	listView->MakeFocus();
	Show();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~NewsgroupWind()
{
	newsgroup->Close();
	newsgroup->AttachedToWindow(NULL);
	((NNTPApp*) be_app)->WindowClosing(this);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"BWindow virtuals"
]]></method>

<method access="public" mod-time="Sat, 15 Apr 2000 02:35:44 PDT"><![CDATA[
void MessageReceived(BMessage* message)
{
	ListableTree* newTree;

	switch (message->what) {
		case ViewByScoreMessage:
			newTree = newsgroup->FilterTree();
			newTree->UpdateAllObjects();
			listView->SetTree(newTree);
			break;

		case ViewBySubjectMessage:
			newTree = newsgroup->SubjectTree();
			newTree->UpdateAllObjects();
			listView->SetTree(newTree);
			break;

		case MarkMessage:
			MarkSelected(true);
			break;

		case UnmarkMessage:
			MarkSelected(false);
			break;

		case KillSubjectsMessage:
			KillSubjects();
			break;

		case HiliteSubjectsMessage:
			HiliteSubjects();
			break;

		case RemoveReadMessage:
			newsgroup->RemoveReadArticles();
			break;

		case B_SELECT_ALL:
			listView->SelectAll();
			break;

		case AppendArticlesMessage:
			AppendArticles();
			break;

		case SaveArticlesMessage:
			SaveArticles();
			break;

		case ExtractBinariesMessage:
			ExtractBinaries(false);
			break;

		case ExtractMultipartBinaryMessage:
			ExtractBinaries(true);
			break;

		default:
			BWindow::MessageReceived(message);
			break;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MenusBeginning()
{
	BMenuBar* menuBar = KeyMenuBar();
	ListableTree* viewTree = listView->Tree();
	menuBar->FindItem(ViewByScoreMessage)->SetMarked(viewTree == newsgroup->FilterTree());
	menuBar->FindItem(ViewBySubjectMessage)->SetMarked(viewTree == newsgroup->SubjectTree());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void FrameMoved(BPoint screenPoint)
{
	BWindow::FrameMoved(screenPoint);
	SavePosition();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void FrameResized(float width, float height)
{
	BWindow::FrameResized(width, height);
	SavePosition();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Access"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Newsgroup* GetNewsgroup()
{
	return newsgroup;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SubjectChanged(Subject* subject)
{
	listView->ItemDisplayChanged(((SubjectTree*) listView->Tree())->AdaptorFor(subject));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void NumSubjectsChanged()
{
	listView->NumItemsChanged();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MarkSelected(bool marked)
{
	SubjectTree* tree = (SubjectTree*) listView->Tree();
	int numSelections = tree->NumSelections();
	for (int i=0; i<numSelections; i++)
		tree->SelectedSubjectAt(i)->MarkSelected(marked, newsgroup);
	newsgroup->ReadArticlesChanged();
	listView->Invalidate();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AppendArticles()
{
	// fill up the message
	BMessage* message = new BMessage();
	qstring groupName(newsgroup->Name());
	message->AddString("groupName", groupName.c_str());
	SubjectTree* tree = (SubjectTree*) listView->Tree();
	int numSelections = tree->NumSelections();
	for (int i=0; i<numSelections; i++)
		tree->SelectedSubjectAt(i)->SetupSaveArticles(message);

	((NNTPApp*) be_app)->ShowAppendArticlesPanel(message);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SaveArticles()
{
	// fill up the message
	BMessage* message = new BMessage();
	qstring groupName(newsgroup->Name());
	message->AddString("groupName", groupName.c_str());
	SubjectTree* tree = (SubjectTree*) listView->Tree();
	int numSelections = tree->NumSelections();
	for (int i=0; i<numSelections; i++)
		tree->SelectedSubjectAt(i)->SetupSaveArticles(message);

	((NNTPApp*) be_app)->ShowSaveArticlesPanel(message);
}
]]></method>

<method access="public" mod-time="Sat, 15 Apr 2000 02:35:59 PDT"><![CDATA[
void ExtractBinaries(bool multipart)
{
	// set up the articlesList
	BList* articlesList = new BList();
	SubjectTree* tree = (SubjectTree*) listView->Tree();
	int numSelections = tree->NumSelections();
	for (int i=0; i<numSelections; i++)
		tree->SelectedSubjectAt(i)->SetupExtractBinaries(articlesList);

	// run the thread
	ExtractBinariesThread* binariesThread =
		new ExtractBinariesThread(newsgroup, articlesList, listView, multipart);
	binariesThread->Go();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SavePosition()
{
	// don't do it if we're the only NewsgroupWind
	for (int i=0; ; i++) {
		BWindow* wind = be_app->WindowAt(i);
		if (wind == NULL)
			break;
		if (wind != this && dynamic_cast<NewsgroupWind*>(wind) != NULL)
			return;
		}

	Prefs()->SetRectPref("newsgroupWind.frame", Frame());
}
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 10:58:18 PDT"><![CDATA[
void KillSubjects()
{
	// set up
	Filters* filters = ((NNTPApp*) be_app)->GetFilters();
	string_slice groupName = newsgroup->Name();

	// kill and mark the subjects
	SubjectTree* tree = (SubjectTree*) listView->Tree();
	int numSelections = tree->NumSelections();
	for (int i=0; i<numSelections; i++) {
		// kill subject
		Subject* subject = tree->SelectedSubjectAt(i);
		FilterGroup* filterGroup = filters->GetFilterGroup(groupName);
		if (filterGroup == NULL) {
			filterGroup = new FilterGroup(groupName);
			filters->AddFilterGroup(filterGroup);
			}
		filterGroup->AddFilter(new Filter(Kill, BySubject, subject->GetSubject()));

		// mark subject
		subject->MarkSelected(true, newsgroup);
		}

	// update from marking
	newsgroup->ReadArticlesChanged();
	listView->Invalidate();
}
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 10:58:23 PDT"><![CDATA[
void HiliteSubjects()
{
	// set up
	Filters* filters = ((NNTPApp*) be_app)->GetFilters();
	string_slice groupName = newsgroup->Name();

	// kill the subjects
	SubjectTree* tree = (SubjectTree*) listView->Tree();
	int numSelections = tree->NumSelections();
	for (int i=0; i<numSelections; i++) {
		// hilite subject
		Subject* subject = tree->SelectedSubjectAt(i);
		FilterGroup* filterGroup = filters->GetFilterGroup(groupName);
		if (filterGroup == NULL) {
			filterGroup = new FilterGroup(groupName);
			filters->AddFilterGroup(filterGroup);
			}
		filterGroup->AddFilter(new Filter(Hilite, BySubject, subject->GetSubject()));
		}
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Newsgroup* newsgroup;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
SubjectsView* listView;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float DefaultWidth = 500;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float DefaultHeight = 560;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float DefaultLeft = 80;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float DefaultTop = 80;
]]></variable>

</class>


<class mod-time="Fri, 21 Apr 2000 01:31:29 PDT" wind-frame="64.000000,103.000000,704.000000,633.000000" list-views-height="0.000000">
<name>
SubjectsView
</name>
<superclasses>
public AATreeListView, public PrefsChangeClient
</superclasses>
<hIncludes><![CDATA[
#include "AATreeListView.h"
#include "PrefsChangeClient.h"

class Subject;
class Article;

enum SelectionDirection {
	None,
	Up,
	Down
};
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Subject.h"
#include "SubjectTreeAdaptor.h"
#include "Article.h"
#include "OpenArticleThread.h"
#include "ListableTree.h"
#include "SubjectTree.h"
#include "NewsgroupWind.h"
#include "Messages.h"
#include <AppDefs.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Fri, 21 Apr 2000 00:52:09 PDT"><![CDATA[
SubjectsView(BRect frame, ListableTree* tree, const char* name = NULL,
             uint32 resizingMode = B_FOLLOW_ALL_SIDES,
             uint32 flags = 0)
	: AATreeListView(frame, tree, name, resizingMode, flags), selectDirection(None)
{
	SetViewColor(B_TRANSPARENT_32_BIT);

	SubjectTreeAdaptor::ExtraInfoDisplayChanged();	// intialize this
	if (SubjectTreeAdaptor::HasExtraInfo())
		SetFlags(Flags() | B_FULL_UPDATE_ON_RESIZE);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"BView virtuals"
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 11:00:10 PDT"><![CDATA[
void KeyDown(const char* bytes, int32 numBytes)
{
	int i, numSelections;
	SubjectTreeAdaptor* adaptor;

	switch (bytes[0]) {
		case B_RIGHT_ARROW:
			numSelections = NumSelections();
			for (i=0; i<numSelections; i++) {
				adaptor = (SubjectTreeAdaptor*) SelectionAt(i);
				adaptor->subject->SetExpanded(true);
				ItemDisplayChanged(adaptor);
				}
			break;

		case B_LEFT_ARROW:
			numSelections = NumSelections();
			for (i=0; i<numSelections; i++) {
				adaptor = (SubjectTreeAdaptor*) SelectionAt(i);
				adaptor->subject->SetExpanded(false);
				ItemDisplayChanged(adaptor);
				}
			break;

		case ' ':
			// "open next unread", much like MT-Newswatcher
			OpenNextUnread();
			break;

		case 'm':
		case 'M':
			Window()->PostMessage(MarkMessage);
			break;

		case 'u':
		case 'U':
			Window()->PostMessage(UnmarkMessage);
			break;

		case 'w':
		case 'W':
			Window()->PostMessage(B_QUIT_REQUESTED);
			break;

		case 'a':
		case 'A':
			Window()->PostMessage(B_SELECT_ALL);
			break;

		default:
			AATreeListView::KeyDown(bytes, numBytes);
			break;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"PrefsChangeClient virtuals"
]]></method>

<method access="public" mod-time="Fri, 21 Apr 2000 01:31:29 PDT"><![CDATA[
void PrefChanged(string_slice prefName)
{
	if (prefName == "listBgndColor" || prefName == "listSelectedBgndColor" ||
			prefName == "listHilitedBgndColor" || prefName == "listTextColor") {
		Window()->Lock();
		Invalidate();
		Window()->Unlock();
		}
	else if (prefName == "listFont" || prefName == "extraInfoFont") {
		SubjectTreeAdaptor::FontChanged();
		tree->AllHeightsChanged();
		Window()->Lock();
		NumItemsChanged();
		Window()->Unlock();
		}
	else if (prefName == "showLines" || prefName == "showDates") {
		SubjectTreeAdaptor::ExtraInfoDisplayChanged();
		Window()->Lock();
			// it's not documented, but the window must be locked for a SetFlags() call
		if (SubjectTreeAdaptor::HasExtraInfo())
			SetFlags(Flags() | B_FULL_UPDATE_ON_RESIZE);
		else
			SetFlags(Flags() & ~B_FULL_UPDATE_ON_RESIZE);
		Invalidate();
		Window()->Unlock();
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Access"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
SelectionDirection SelectDirection()
{
	return selectDirection;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetSelectDirection(SelectionDirection newSelectDirection)
{
	selectDirection = newSelectDirection;
}
]]></method>

<method access="public" mod-time="Sat, 15 Apr 2000 01:05:10 PDT"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Sat, 15 Apr 2000 01:10:40 PDT"><![CDATA[
void InvalidateSubject(Subject* subject)
{
	Window()->Lock();
	InvalidateItem(((SubjectTree*) tree)->AdaptorFor(subject));
	Window()->Unlock();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 10:59:16 PDT"><![CDATA[
void OpenArticle(Article* article, Subject* subject)
{
	Newsgroup* newsgroup = ((NewsgroupWind*) Window())->GetNewsgroup();
	article->SetRead(true);
	InvalidateItem(((SubjectTree*) tree)->AdaptorFor(subject));
	OpenArticleThread* thread =
		new OpenArticleThread(newsgroup, article->ArticleNo(),
		                      subject->GetSubject(), article->Lines());
	thread->Go();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void OpenNextUnread()
{
	SubjectTreeAdaptor* adaptor;
	Subject* subject;

	bool openedSomething = false;;
	int numSelections = NumSelections();
	for (int i=0; i<numSelections; i++) {
		adaptor = (SubjectTreeAdaptor*) SelectionAt(i);
		subject = adaptor->subject;
		if (subject->AllRead())
			continue;
		// has an unread article--open it
		Article* article = NULL;
		if (subject->Selected())
			article = subject->FirstUnreadArticle();
		else {
			// find the first selected article, and select the next unread article
			// at or after it
			int numArticles = subject->NumArticles();
			for (int j=0; j<numArticles; j++) {
				if (subject->ArticleAt(j)->Selected()) {
					// find next unread
					for (; j<numArticles; j++) {
						if (!subject->ArticleAt(j)->IsRead()) {
							article = subject->ArticleAt(j);
							break;
							}
						}
					break;
					}
				}
			}
		if (article) {
			OpenArticle(article, subject);
			openedSomething = true;
			}
		}
	// if all are read, select and read the next unread
	if (!openedSomething && numSelections > 0) {
		SubjectTreeAdaptor* lastSelected =
			(SubjectTreeAdaptor*) tree->LastSelectedObject();
		int newSelection = tree->IndexOf(lastSelected);
		while (true) {
			// try the next item
			newSelection += 1;
			adaptor = (SubjectTreeAdaptor*) tree->ObjectAt(newSelection);
			if (adaptor == NULL)
				break;
			subject = adaptor->subject;
			if (!subject->AllRead()) {
				// found one to read
				DeselectAll();
				Select(newSelection);
				OpenArticle(subject->FirstUnreadArticle(), subject);
				break;
				}
			}
		}
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
SelectionDirection selectDirection;
]]></variable>

</class>


<class mod-time="Fri, 14 Apr 2000 18:09:00 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
"Filters"
</name>
</class>


<class mod-time="Sat, 08 Apr 2000 11:03:14 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
FilterGroup
</name>
<superclasses>
public DamnListableObject
</superclasses>
<hIncludes><![CDATA[
#include "DamnListableObject.h"
#include "string_slice.h"

class qstring;
class Filter;
class Article;
class FiltersView;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "qstring.h"
#include "Filter.h"
#include "FiltersView.h"
#include <List.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
FilterGroup(string_slice groupNameIn)
	: expanded(true)
{
	groupName = new qstring(groupNameIn);
	filters = new BList();
}
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 09:08:13 PDT"><![CDATA[
virtual ~FilterGroup()
{
	delete groupName;
	int numFilters = filters->CountItems();
	for (int i=0; i<numFilters; i++)
		delete (Filter*) filters->ItemAt(i);
	delete filters;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ApplyFilters(Article* article, string_slice subject)
{
	int numFilters = NumFilters();
	for (int i=0; i<numFilters; i++)
		FilterAt(i)->ApplyTo(article, subject);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AddFilter(Filter* filter)
{
	filters->AddItem(filter);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void EditFilterString(Filter* filter, BRect rect, FiltersView* view)
{
	int whichFilter = filters->IndexOf(filter);
	if (whichFilter < 0)
		return;
	BRect itemRect = rect;
	itemRect.left += itemLeft + filterIndent;
	itemRect.top = rect.top + groupHeight + whichFilter * filterHeight;
	itemRect.bottom = itemRect.top + filterHeight - 1;
	filter->EditString(itemRect, view);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Access"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice GroupName() const
{
	return *groupName;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int NumFilters()
{
	return filters->CountItems();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Filter* FilterAt(int index)
{
	return (Filter*) filters->ItemAt(index);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"ListableObject virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool isLessThan(const OrderedObject& otherObject)
{
	return string_slice(*groupName) < ((const FilterGroup*) &otherObject)->GroupName();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool isEqualTo(const OrderedObject& otherObject)
{
	return string_slice(*groupName) == ((const FilterGroup*) &otherObject)->GroupName();
}
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 11:01:15 PDT"><![CDATA[
int DisplayHeight()
{
	float height = groupHeight;
	if (expanded)
		height += filterHeight * filters->CountItems();
	return (int) height;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Draw(BRect rect, AATreeListView* view)
{
	// draw the expander
	DrawExpander(view, BPoint(rect.left + expanderLeft, rect.top + groupHeight - baseline - 1),
	             expanded);

	// draw the group header
	BRect itemRect = rect;
	itemRect.left += itemLeft;
	itemRect.bottom = itemRect.top + groupHeight - 1;
	view->PushState();
	view->SetLowColor(selected ? hiliteBgndColor : bgndColor);
	view->FillRect(itemRect, B_SOLID_LOW);
	view->DrawString(groupName->c_str(),
	                 BPoint(itemRect.left + nameLeft, itemRect.bottom - baseline));
	view->PopState();

	// draw the filters
	if (expanded) {
		itemRect.left += filterIndent;
		itemRect.top = itemRect.bottom + 1;
		itemRect.bottom = itemRect.top + filterHeight - 1;
		int numFilters = filters->CountItems();
		for (int i=0; i<numFilters; i++) {
			Filter* filter = (Filter*) filters->ItemAt(i);
			filter->Draw(itemRect, (FiltersView*) view);
			// bump itemRect
			itemRect.top += filterHeight;
			itemRect.bottom += filterHeight;
			}
		}
}
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 11:03:14 PDT"><![CDATA[
void MouseDown(BPoint where, BRect rect, int clicks, int modifiers, AATreeListView* view)
{
	((FiltersView*) view)->FinishStringEdit();

	// expander
	float groupBottom = rect.top + groupHeight - 1;
	if (where.x < rect.left + itemLeft && where.y <= groupBottom) {
		BPoint expanderStart(rect.left + expanderLeft, groupBottom - baseline);
		expanded = TrackExpander(view, expanderStart, expanded);
		view->Invalidate();
		return;
		}

	// select this
	view->DeselectAll();
	view->SelectItem(this);

	// pass it on to the filter if appropriate
	if (where.x >= rect.left + itemLeft && where.y > groupBottom) {
		int whichFilter = (int) ((where.y - groupBottom) / filterHeight);
		Filter* filter = FilterAt(whichFilter);
		if (filter) {
			BRect itemRect = rect;
			itemRect.left += itemLeft + filterIndent;
			itemRect.top = groupBottom + 1 + whichFilter * filterHeight;
			itemRect.bottom = itemRect.top + filterHeight - 1;
			filter->MouseDown(where, itemRect, clicks, modifiers, (FiltersView*) view);
			view->InvalidateItem(this);
			}
		}
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
qstring* groupName;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BList* filters;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool expanded;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float groupHeight = 14;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float expanderLeft = 3;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float itemLeft = 14;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float nameLeft = 3;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float filterHeight = 12;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float filterIndent = 8;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float baseline = 3;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const rgb_color bgndColor = { 255, 255, 255, 255 };
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const rgb_color hiliteBgndColor = { 192, 192, 192, 255 };
]]></variable>

</class>


<class mod-time="Sat, 08 Apr 2000 11:04:26 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Filter
</name>
<hIncludes><![CDATA[
#include "string_slice.h"
#include <Point.h>
#include <Rect.h>
#include <GraphicsDefs.h>

class qstring;
class Article;
class FiltersView;
class TextReader;
class BFile;

enum FilterAction {
	Hilite,
	Kill
};

enum FilterHeader {
	BySubject,
	ByAuthor
};
]]></hIncludes>
<cppIncludes><![CDATA[
#include "qstring.h"
#include "Article.h"
#include "FiltersView.h"
#include "TextReader.h"
#include <File.h>
#include <PopUpMenu.h>
#include <MenuItem.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Filter()
	: action(Hilite), header(BySubject)
{
	str = new qstring();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Filter(FilterAction actionIn, FilterHeader headerIn, string_slice stringIn)
	: action(actionIn), header(headerIn), str(new qstring(stringIn))
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~Filter()
{
	delete str;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ApplyTo(Article* article, string_slice subject)
{
	// see if this filter applies to the articles
	bool applies = false;
	switch (header) {
		case BySubject:
			applies = subject.containsCI(*str);
			break;

		case ByAuthor:
			applies = article->Author().containsCI(*str);
			break;
		}
	if (!applies)
		return;

	// do the appropriate action
	switch (action) {
		case Hilite:
			article->SetFilterScore(article->FilterScore() + 1);
			break;

		case Kill:
			article->SetRead(true);
			break;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void WriteToFile(BFile* file)
{
	string_slice tab("\t");
	string_slice eol("\n");

	file->Write(tab.begin(), tab.length());
	string_slice actionStr = actionStrings[action];
	file->Write(actionStr.begin(), actionStr.length());
	file->Write(tab.begin(), tab.length());
	string_slice headerStr = headerStrings[header];
	file->Write(headerStr.begin(), headerStr.length());
	file->Write(tab.begin(), tab.length());
	file->Write(str->data(), str->length());
	file->Write(eol.begin(), eol.length());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ReadFrom(TextReader* reader)
{
	// already past the empty field

	action = (FilterAction) IndexFor(reader->NextTabField(), actionStrings);
	header = (FilterHeader) IndexFor(reader->NextTabField(), headerStrings);
	*str = reader->NextTabField();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Access"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice GetString()
{
	return *str;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetString(string_slice newStr)
{
	*str = newStr;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"ListableObject analogs"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Draw(BRect rect, FiltersView* view)
{
	view->PushState();
	view->SetLowColor(bgndColor);
	view->FillRect(rect, B_SOLID_LOW);
	view->MovePenTo(rect.left + textLeft, rect.bottom - baseline);

	// action
	view->DrawString(actionStrings[action]);
	actionRight = view->PenLocation().x;
	view->DrawString(" if ");

	// header
	headerLeft = view->PenLocation().x;
	view->DrawString(headerStrings[header]);
	headerRight = view->PenLocation().x;
	view->DrawString(" contains ");

	// str
	qstring displayStr = "\"";
	displayStr += str;
	displayStr += '"';
	strLeft = view->PenLocation().x;
	view->DrawString(displayStr.c_str());

	view->PopState();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MouseDown(BPoint where, BRect rect, int clicks, int modifiers, FiltersView* view)
{
	BPopUpMenu* menu;
	BMenuItem* selectedItem;
	BPoint popPoint;

	BRect clickToOpenRect = view->ConvertToScreen(rect);

	// action menu
	if (where.x < actionRight) {
		menu = new BPopUpMenu("Filter Action");
		BMenuItem* hiliteItem = new BMenuItem(actionStrings[Hilite], NULL);
		hiliteItem->SetMarked(action == Hilite);
		menu->AddItem(hiliteItem);
		BMenuItem* killItem = new BMenuItem(actionStrings[Kill], NULL);
		killItem->SetMarked(action == Kill);
		menu->AddItem(killItem);
		popPoint = view->ConvertToScreen(BPoint(rect.left + textLeft, rect.top));
		selectedItem = menu->Go(popPoint, false, true, clickToOpenRect);
		if (selectedItem == hiliteItem)
			action = Hilite;
		else if (selectedItem == killItem)
			action = Kill;
		delete menu;
		}

	// headerMenu
	else if (where.x >= headerLeft && where.x < headerRight) {
		menu = new BPopUpMenu("Filter Header");
		BMenuItem* subjectItem = new BMenuItem(headerStrings[BySubject], NULL);
		subjectItem->SetMarked(header == BySubject);
		menu->AddItem(subjectItem);
		BMenuItem* authorItem = new BMenuItem(headerStrings[ByAuthor], NULL);
		authorItem->SetMarked(header == ByAuthor);
		menu->AddItem(authorItem);
		popPoint = view->ConvertToScreen(BPoint(headerLeft, rect.top));
		selectedItem = menu->Go(popPoint, false, true, clickToOpenRect);
		if (selectedItem == subjectItem)
			header = BySubject;
		else if (selectedItem == authorItem)
			header = ByAuthor;
		delete menu;
		}

	else if (where.x >= strLeft) {
		EditString(rect, view);
		}

	/***/
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void EditString(BRect rect, FiltersView* view)
{
	BRect editRect(strLeft, rect.top, rect.right - strEditRightMargin, rect.bottom);
	editRect.OffsetBy(strEditXOffset, strEditYOffset);
	view->EditFilterString(this, editRect);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int IndexFor(string_slice str, const char** strings)
{
	for (int index=0; ; index++) {
		const char* curString = strings[index];
		if (curString == NULL)
			break;
		if (str == curString)
			return index;
		}
	return -1;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
FilterAction action;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
FilterHeader header;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
qstring* str;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
float actionRight;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
float headerLeft;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
float headerRight;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
float strLeft;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float textLeft = 3;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float baseline = 3;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const rgb_color bgndColor = { 255, 255, 255, 0 };
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float strEditXOffset = -4;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float strEditYOffset = -5;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float strEditRightMargin = 6;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const char* actionStrings[] = { "Hilite", "Kill", NULL };
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const char* headerStrings[] = { "Subject", "Author", NULL };
]]></variable>

</class>


<class mod-time="Sat, 08 Apr 2000 11:07:16 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Filters
</name>
<superclasses>
public ListableTree
</superclasses>
<hIncludes><![CDATA[
#include "ListableTree.h"
#include "string_slice.h"

class FilterGroup;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "FilterGroup.h"
#include "Filter.h"
#include "FileNames.h"
#include "TextReader.h"
#include <Path.h>
#include <FindDirectory.h>
#include <File.h>

//*** test
#include "Filter.h"

class FilterGroupSearcher : public OrderedObject {
public:
	FilterGroupSearcher(string_slice groupNameIn)
		: groupName(groupNameIn) {}

	bool	operator<(const OrderedObject& otherObject)
				{ return groupName < ((FilterGroup*) &otherObject)->GroupName(); }
	bool	operator==(const OrderedObject& otherObject)
				{ return groupName == ((FilterGroup*) &otherObject)->GroupName(); }

protected:
	string_slice	groupName;
};
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Filters()
{
	// always has "All Groups"
	AddFilterGroup(new FilterGroup(string_slice(allGroupsName)));

	Load();

//*** test
/***
FilterGroup* testGroup = new FilterGroup("rec.audio.pro");
Filter* testFilter = new Filter();
testFilter->SetString("Folta");
testGroup->AddFilter(testFilter);
testGroup->AddFilter(new Filter(Hilite, Author, "Dorsey"));
testGroup->AddFilter(new Filter(Hilite, Author, "Fletcher"));
testGroup->AddFilter(new Filter(Hilite, Author, "Gerst"));
testGroup->AddFilter(new Filter(Hilite, Author, "McQuilken"));
testGroup->AddFilter(new Filter(Kill, Subject, "Spam Pan"));
AddFilterGroup(testGroup);
GetFilterGroup(string_slice(allGroupsName))->AddFilter(new Filter(Hilite, Author, "Folta"));
***/
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~Filters()
{
	Save();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
FilterGroup* GetFilterGroup(string_slice groupName)
{
	FilterGroupSearcher searcher(groupName);
	return (FilterGroup*) FindObject(&searcher);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
FilterGroup* GetGlobalFilters()
{
	return GetFilterGroup(string_slice(allGroupsName));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AddFilterGroup(FilterGroup* filterGroup)
{
	InsertObject(filterGroup);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Save()
{
	status_t err;

	// figure out where to put it
	BPath path;
	err = find_directory(B_USER_SETTINGS_DIRECTORY, &path, true);
	if (err != B_NO_ERROR)
		return;
	path.Append(FileNames::filtersFileName);

	// open the file
	BFile* file = new BFile(path.Path(), B_READ_WRITE | B_CREATE_FILE | B_ERASE_FILE);
	if (file->InitCheck() != B_NO_ERROR)
		return;

	// write
	WalkObjects(WriteFilterGroup, file);

	// clean up
	delete file;
}
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 11:06:47 PDT"><![CDATA[
void Load()
{
	status_t err;

	// figure out where the file should be
	BPath path;
	err = find_directory(B_USER_SETTINGS_DIRECTORY, &path, true);
	if (err != B_NO_ERROR)
		return;
	path.Append(FileNames::filtersFileName);

	// open the file
	BFile* file = new BFile(path.Path(), B_READ_ONLY);
	if (file->InitCheck() != B_NO_ERROR) {
		delete file;
		return;
		}

	// load the text
	off_t fileSize;
	file->GetSize(&fileSize);
	char* text = new char[fileSize];
	file->ReadAt(0, text, fileSize);
	delete file;

	// parse it
	TextReader reader(string_slice(text, text + fileSize));
	FilterGroup* curGroup = NULL;
	while (!reader.AtEOF()) {
		// get the groupName
		string_slice groupName = reader.NextTabField();
		if (groupName.length() > 0) {
			curGroup = GetFilterGroup(groupName);
			if (curGroup == NULL) {
				curGroup = new FilterGroup(groupName);
				AddFilterGroup(curGroup);
				}
			reader.NextLine();
			}

		// if none, this is a filter line (if it's not blank)
		else {
			string_slice filterLine = reader.NextLine();
			if (filterLine.length() > 0 && curGroup != NULL) {
				Filter* filter = new Filter();
				TextReader lineReader(filterLine);
				filter->ReadFrom(&lineReader);
				curGroup->AddFilter(filter);
				}
			}
		}

	// clean up
	delete text;
}
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 11:07:16 PDT"><![CDATA[
static void WriteFilterGroup(OrderedObject* object, void* data)
{
	FilterGroup* filterGroup = (FilterGroup*) object;
	BFile* file = (BFile*) data;
	string_slice eol("\n");

	// write the group name
	string_slice groupName = filterGroup->GroupName();
	file->Write(groupName.begin(), groupName.length());
	file->Write(eol.begin(), eol.length());

	// write the filters
	int numFilters = filterGroup->NumFilters();
	for (int i=0; i<numFilters; i++)
		filterGroup->FilterAt(i)->WriteToFile(file);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Public Tweex"
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const char* allGroupsName = "All Groups";
]]></variable>

</class>


<class mod-time="Sat, 08 Apr 2000 11:09:27 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
FiltersView
</name>
<superclasses>
public AATreeListView
</superclasses>
<hIncludes><![CDATA[
#include "AATreeListView.h"

class Filter;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Filter.h"
#include "Filters.h"
#include "FilterGroup.h"
#include "AddGroupDlog.h"
#include "qstring.h"
#include "Messages.h"
#include <TextControl.h>
#include <Message.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
FiltersView(BRect frame, ListableTree* tree, const char* name = NULL,
               uint32 resizingMode = B_FOLLOW_ALL_SIDES,
               uint32 flags = 0)
	: AATreeListView(frame, tree, name, resizingMode, flags),
	  stringEditor(NULL), editingFilter(NULL)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~FiltersView()
{
	FinishStringEdit();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void EditFilterString(Filter* filter, BRect rect)
{
	// finish up an existing one
	if (stringEditor)
		FinishStringEdit();

	// start the new editor
	editingFilter = filter;
	stringEditor = new BTextControl(rect, "Filter String", NULL,
	                                qstring(filter->GetString()).c_str(),
	                                new BMessage(EditDoneMessage),
	                                B_FOLLOW_LEFT_RIGHT | B_FOLLOW_TOP);
	stringEditor->SetTarget(this);
	AddChild(stringEditor);
	stringEditor->MakeFocus();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void FinishStringEdit()
{
	if (stringEditor == NULL)
		return;
	editingFilter->SetString(string_slice(stringEditor->Text()));
	RemoveChild(stringEditor);
	delete stringEditor;
	stringEditor = NULL;
	editingFilter = NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"BView virtuals"
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 11:09:27 PDT"><![CDATA[
void MessageReceived(BMessage* message)
{
	switch (message->what) {
		case EditDoneMessage:
			FinishStringEdit();
			break;

		case AddGroupMessage:
			{
			string_slice groupName(message->FindString("groupName"));
			Filters* filters = (Filters*) tree;
			if (filters->GetFilterGroup(groupName) == NULL) {
				filters->AddFilterGroup(new FilterGroup(groupName));
				NumItemsChanged();
				}
			}
			break;

		case NewGroupMessage:
			new AddGroupDlog("New Filter Group", BMessenger(this));
			break;

		case NewFilterMessage:
			{
			FilterGroup* filterGroup = (FilterGroup*) SelectionAt(0);
			if (filterGroup) {
				Filter* newFilter = new Filter();
				filterGroup->AddFilter(newFilter);
				ItemDisplayChanged(filterGroup);

				// start edit of filter string
				BRect itemRect = Bounds();
				itemRect.top = tree->YForObject(filterGroup);
				itemRect.bottom = itemRect.top + filterGroup->DisplayHeight() - 1;
				filterGroup->Draw(itemRect, this);
					// not only do we want it drawn, but Filter::EditString()
					// doesn't work correctly until the Filter has been drawn
				filterGroup->EditFilterString(newFilter, itemRect, this);
				}
			}
			break;

		default:
			AATreeListView::MessageReceived(message);
			break;
		}
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BTextControl* stringEditor;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Filter* editingFilter;
]]></variable>

</class>


<class mod-time="Sat, 08 Apr 2000 11:10:23 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
FiltersWind
</name>
<superclasses>
public BWindow
</superclasses>
<hIncludes><![CDATA[
#include <Window.h>

class FiltersView;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "NNTPApp.h"
#include "FiltersView.h"
#include "Filters.h"
#include "Messages.h"
#include "Prefs.h"
#include <MenuBar.h>
#include <Menu.h>
#include <MenuItem.h>
#include <ScrollView.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
FiltersWind()
	: BWindow(BRect(defaultLeft, defaultTop, defaultLeft + defaultWidth, defaultTop + defaultHeight),
	          "Filters", B_DOCUMENT_WINDOW, 0)
{
	// menu bar
	BMenuBar* menuBar = new BMenuBar(BRect(0, 0, 0, 0), "");
	BMenu* filtersMenu = new BMenu("Filters");
	BMenuItem* newFilterItem =
		new BMenuItem("New Filter", new BMessage(NewFilterMessage), 'N');
	filtersMenu->AddItem(newFilterItem);
	BMenuItem* newGroupItem =
		new BMenuItem("New Group", new BMessage(NewGroupMessage));
	filtersMenu->AddItem(newGroupItem);
	menuBar->AddItem(filtersMenu);
	AddChild(menuBar);

	// make the listView
	BRect listViewFrame(0, menuBar->Frame().Height() + 1,
	                    defaultWidth - B_V_SCROLL_BAR_WIDTH, defaultHeight);
	listView = new FiltersView(listViewFrame, ((NNTPApp*) be_app)->GetFilters());

	// make the scrollView
	BScrollView* scrollView =
		new BScrollView("", listView, B_FOLLOW_ALL_SIDES, 0, false, true, B_NO_BORDER);
	AddChild(scrollView);

	// set the listView as the target of menu messages
	// --need to do this *after* the listView is in the view hierarchy, for some
	//   reason (prob'ly cause it doesn't have a BLooper yet otherwise)
	newFilterItem->SetTarget(listView);
	newGroupItem->SetTarget(listView);

	// adjust the position
	BRect savedFrame = Prefs()->GetRectPref("filterWindFrame");
	if (savedFrame.IsValid()) {
		MoveTo(savedFrame.LeftTop());
		ResizeTo(savedFrame.Width(), savedFrame.Height());
		}

	listView->MakeFocus();
	Show();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~FiltersWind()
{
	Prefs()->SetRectPref("filterWindFrame", Frame());
	((NNTPApp*) be_app)->WindowClosing(this);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"BWindow virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MenusBeginning()
{
	BMenuBar* menuBar = KeyMenuBar();
	menuBar->FindItem(NewFilterMessage)->SetEnabled(listView->NumSelections() > 0);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
FiltersView* listView;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float defaultWidth = 400;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float defaultHeight = 400;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float defaultLeft = 500;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float defaultTop = 100;
]]></variable>

</class>


<class mod-time="Fri, 14 Apr 2000 18:08:50 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
"Groups List"
</name>
</class>


<class mod-time="Mon, 17 Apr 2000 18:30:42 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
GroupsList
</name>
<superclasses>
public BLocker, public ThreadOwner
</superclasses>
<hIncludes><![CDATA[
#include "ThreadOwner.h"
#include "string_slice.h"

class ListableTree;
class NNTPResponse;
class OrderedObject;
class GroupsListView;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "ListableTree.h"
#include "NNTPResponse.h"
#include "GroupName.h"
#include "GroupsListView.h"
#include <Window.h>
#include <ScrollView.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Mon, 17 Apr 2000 18:23:37 PDT"><![CDATA[
GroupsList()
	: tree(new ListableTree()), response(NULL), view(NULL)
{
}
]]></method>

<method access="public" mod-time="Mon, 17 Apr 2000 18:23:52 PDT"><![CDATA[
~GroupsList()
{
	KillOwnedThreads();

	tree->DeleteAllObjects();
	delete tree;
	delete response;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AddGroup(string_slice groupName)
{
	Lock();
	GroupName* group = new GroupName(groupName);
	bool hadGroup = (tree->FindObject(group) != NULL);
	if (!hadGroup)
		tree->InsertObject(group);
	else
		delete group;
	Unlock();

	// update window
	if (!hadGroup && view) {
		BWindow* wind = view->Window();
		if (wind && wind->Lock()) {
			view->NumItemsChanged();
			wind->Unlock();
			}
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetResponse(NNTPResponse* newResponse)
{
	delete response;
	response = newResponse;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AttachedToView(GroupsListView* viewIn)
{
	view = viewIn;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DetachedFromView()
{
	view = NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Access"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ListableTree* GetTree()
{
	return tree;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ListableTree* tree;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
NNTPResponse* response;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GroupsListView* view;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int fileReadUpdateQuantum = 1000;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int fileWriteUpdateQuantum = 1000;
]]></variable>

</class>


<class mod-time="Mon, 17 Apr 2000 18:35:19 PDT" wind-frame="139.000000,238.000000,779.000000,768.000000" list-views-height="0.000000">
<name>
AllGroupsList
</name>
<superclasses>
public GroupsList
</superclasses>
<hIncludes><![CDATA[
#include "GroupsList.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "ListableTree.h"
#include "GroupName.h"
#include "TextReader.h"
#include "Task.h"
#include "GetGroupsListThread.h"
#include "FileNames.h"
#include <Path.h>
#include <FindDirectory.h>
#include <File.h>

struct WriteGroupContext {
	BFile*	file;
	Task* 	task;
	int   	updateProgressAfter;

	WriteGroupContext(BFile* fileIn, Task* taskIn, int updateProgressAfterIn)
		: file(fileIn), task(taskIn), updateProgressAfter(updateProgressAfterIn) {}
};
]]></cppIncludes>
<method access="public" mod-time="Mon, 17 Apr 2000 18:13:45 PDT"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Mon, 17 Apr 2000 18:23:56 PDT"><![CDATA[
AllGroupsList()
	: fileText(NULL), dirty(false)
{
	status_t result = ReadFile();
	if (result != B_NO_ERROR)
		StartThread(new GetGroupsListThread(this));
}
]]></method>

<method access="public" mod-time="Mon, 17 Apr 2000 18:21:29 PDT"><![CDATA[
~AllGroupsList()
{
	KillOwnedThreads();

	if (dirty)
		Save();

	delete fileText;
}
]]></method>

<method access="public" mod-time="Mon, 17 Apr 2000 18:21:40 PDT"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Mon, 17 Apr 2000 18:24:35 PDT"><![CDATA[
status_t ReadFile()
{
	status_t err;

	// figure out where the file should be
	BPath path;
	err = find_directory(B_USER_SETTINGS_DIRECTORY, &path, true);
	if (err != B_NO_ERROR)
		return err;
	path.Append(FileNames::groupsFileName);

	// open the file
	BFile* file = new BFile(path.Path(), B_READ_ONLY);
	err = file->InitCheck();
	if (err != B_NO_ERROR) {
		delete file;
		return err;
		}
	off_t fileSize;
	file->GetSize(&fileSize);

	Task task("Reading groups...");
	task.SetProgressMax(fileSize);
	task.GotConnection();

	// load the text
	fileText = new char[fileSize];
	file->ReadAt(0, fileText, fileSize);
	delete file;

	// parse it
	TextReader reader(string_slice(fileText, fileText + fileSize));
	int updateAfter = fileReadUpdateQuantum;
	while (!reader.AtEOF()) {
		// get the groupName
		string_slice groupName = reader.NextLine();
		if (groupName.length() > 0) {
			tree->InsertObject(new GroupName(groupName));

			--updateAfter;
			if (updateAfter <= 0) {
				task.SetProgress(reader.Position());
				updateAfter = fileReadUpdateQuantum;
				}
			}
		}

	return err;
}
]]></method>

<method access="public" mod-time="Mon, 17 Apr 2000 18:25:20 PDT"><![CDATA[
void Save()
{
	status_t err;

	// figure out where to put it
	BPath path;
	err = find_directory(B_USER_SETTINGS_DIRECTORY, &path, true);
	if (err != B_NO_ERROR)
		return;
	path.Append(FileNames::groupsFileName);

	// open the file
	BFile* file = new BFile(path.Path(), B_READ_WRITE | B_CREATE_FILE | B_ERASE_FILE);
	if (file->InitCheck() != B_NO_ERROR) {
		delete file;
		return;
		}

	Task task("Saving groups list...");
	task.SetProgressMax(tree->NumObjects());
	task.GotConnection();

	// write
	WriteGroupContext saveContext(file, &task, fileWriteUpdateQuantum);
	tree->WalkObjects(WriteGroup, &saveContext);

	// clean up
	delete file;
}
]]></method>

<method access="public" mod-time="Mon, 17 Apr 2000 18:25:42 PDT"><![CDATA[
void Dirtify()
{
	dirty = true;
}
]]></method>

<method access="public" mod-time="Mon, 17 Apr 2000 18:25:47 PDT"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Mon, 17 Apr 2000 18:25:57 PDT"><![CDATA[
static void WriteGroup(OrderedObject* object, void* data)
{
	GroupName* groupName = (GroupName*) object;
	WriteGroupContext* context = (WriteGroupContext*) data;
	BFile* file = context->file;
	static const string_slice eol("\n");

	// write the group name
	string_slice name = groupName->Name();
	file->Write(name.begin(), name.length());
	file->Write(eol.begin(), eol.length());

	// progress
	--context->updateProgressAfter;
	if (context->updateProgressAfter <= 0) {
		context->task->BumpProgress(fileWriteUpdateQuantum);
		context->updateProgressAfter = fileWriteUpdateQuantum;
		}
}
]]></method>

<variable access="protected" mod-time="Mon, 17 Apr 2000 18:22:05 PDT"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Mon, 17 Apr 2000 18:22:12 PDT"><![CDATA[
char* fileText;
]]></variable>

<variable access="protected" mod-time="Mon, 17 Apr 2000 18:22:14 PDT"><![CDATA[
bool dirty;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
GroupName
</name>
<superclasses>
public DamnListableObject
</superclasses>
<hIncludes><![CDATA[
#include "DamnListableObject.h"
#include "string_slice.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "GroupsListView.h"
#include "ListColors.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GroupName(string_slice nameIn)
	: name(nameIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"ListableObject virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool isLessThan(const OrderedObject& otherObject)
{
	return name < ((const GroupName*) &otherObject)->name;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool isEqualTo(const OrderedObject& otherObject)
{
	return name == ((const GroupName*) &otherObject)->name;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int DisplayHeight()
{
	return displayHeight;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Draw(BRect rect, AATreeListView* view)
{
	// set up cached baseline
	if (baseline < 0) {
		font_height fontInfo;
		be_plain_font->GetHeight(&fontInfo);
		baseline = ceil(fontInfo.descent);
		}

	// set up colors
	view->SetHighColor(ListColors::textColor);
	view->SetLowColor(selected ? ListColors::selectedBgndColor : ListColors::bgndColor);
	view->FillRect(rect, B_SOLID_LOW);

	// draw the name
	view->DrawString(name.begin(), name.length(),
	                 BPoint(rect.left + nameLeft, rect.bottom - baseline));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MouseDown(BPoint where, BRect rect, int clicks, int modifiers, AATreeListView* view)
{
	// if already selected, initiate drag
	if (Selected())
		((GroupsListView*) view)->StartDrag(rect);

	// otherwise, select
	else {
		if ((modifiers & B_COMMAND_KEY) == 0)
			view->DeselectAll();
		view->SelectItem(this);
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Access"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice Name()
{
	return name;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice name;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Class variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static float baseline = -1;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int displayHeight = 12;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float nameLeft = 4;
]]></variable>

</class>


<class mod-time="Mon, 17 Apr 2000 18:08:38 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
GroupsListWind
</name>
<superclasses>
public BWindow
</superclasses>
<hIncludes><![CDATA[
#include "string_slice.h"
#include <Window.h>

class GroupsList;
class GroupsListView;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "GroupsList.h"
#include "GroupsListView.h"
#include "NNTPApp.h"
#include "Prefs.h"
#include <ScrollView.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Mon, 17 Apr 2000 18:08:38 PDT"><![CDATA[
GroupsListWind(GroupsList* groupsList, const char* title, const char* framePrefNameIn)
	: BWindow(BRect(defaultLeft, defaultTop, defaultLeft + defaultWidth, defaultTop + defaultHeight),
	          title, B_DOCUMENT_WINDOW, 0),
	  framePrefName(framePrefNameIn)
{
	// make the listView
	BRect listViewFrame(0, 0,
	                    defaultWidth - B_V_SCROLL_BAR_WIDTH, defaultHeight);
	listView = new GroupsListView(listViewFrame, groupsList);

	// make the scrollView
	BScrollView* scrollView =
		new BScrollView("", listView, B_FOLLOW_ALL_SIDES, 0, false, true, B_NO_BORDER);
	AddChild(scrollView);

	// adjust the position
	BRect savedFrame = Prefs()->GetRectPref(framePrefName);
	if (savedFrame.IsValid()) {
		MoveTo(savedFrame.LeftTop());
		ResizeTo(savedFrame.Width(), savedFrame.Height());
		}

	listView->MakeFocus();
	Show();
}
]]></method>

<method access="public" mod-time="Mon, 17 Apr 2000 18:06:08 PDT"><![CDATA[
~GroupsListWind()
{
	Prefs()->SetRectPref(framePrefName, Frame());
	((NNTPApp*) be_app)->WindowClosing(this);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GroupsListView* listView;
]]></variable>

<variable access="protected" mod-time="Mon, 17 Apr 2000 18:08:23 PDT"><![CDATA[
const char* framePrefName;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float defaultWidth = 300;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float defaultHeight = 400;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float defaultLeft = 500;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float defaultTop = 100;
]]></variable>

</class>


<class mod-time="Sat, 08 Apr 2000 11:13:00 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
GroupsListView
</name>
<superclasses>
public AATreeListView
</superclasses>
<hIncludes><![CDATA[
#include "AATreeListView.h"

class GroupsList;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "GroupsList.h"
#include "GroupName.h"
#include "qstring.h"
#include <Message.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GroupsListView(BRect frame, GroupsList* groupsListIn)
	: AATreeListView(frame, groupsListIn->GetTree()), groupsList(groupsListIn)
{
	groupsList->AttachedToView(this);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~GroupsListView()
{
	groupsList->DetachedFromView();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"BView virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Draw(BRect updateRect)
{
	if (groupsList->Lock()) {
		AATreeListView::Draw(updateRect);
		groupsList->Unlock();
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void StartDrag(BRect itemRect)
{
	// build the text
	qstring text;
	int numSelections = NumSelections();
	for (int i=0; i<numSelections; i++) {
		GroupName* group = (GroupName*) SelectionAt(i);
		text += group->Name();
		text += "\n";
		}

	// build the message
	BMessage message(B_MIME_DATA);
	message.AddData("text/plain", B_MIME_TYPE, text.data(), text.length());

	// drag
	DragMessage(&message, itemRect);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GroupsList* groupsList;
]]></variable>

</class>


<class mod-time="Mon, 17 Apr 2000 18:34:14 PDT" wind-frame="101.000000,196.000000,741.000000,726.000000" list-views-height="0.000000">
<name>
AllGroupsWind
</name>
<superclasses>
public GroupsListWind
</superclasses>
<hIncludes><![CDATA[
#include "GroupsListWind.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "NNTPApp.h"
#include "AllGroupsList.h"
]]></cppIncludes>
<method access="public" mod-time="Mon, 17 Apr 2000 18:02:14 PDT"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Mon, 17 Apr 2000 18:31:11 PDT"><![CDATA[
AllGroupsWind()
	: GroupsListWind(((NNTPApp*) be_app)->GetAllGroupsList(), "All Newsgroups", "groupsListWind.frame")
{
}
]]></method>

</class>


<class mod-time="Mon, 17 Apr 2000 19:36:02 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
NewGroupsWind
</name>
<superclasses>
public GroupsListWind
</superclasses>
<hIncludes><![CDATA[
#include "GroupsListWind.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "NNTPApp.h"
#include "AllGroupsList.h"
]]></cppIncludes>
<method access="public" mod-time="Mon, 17 Apr 2000 19:35:38 PDT"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Mon, 17 Apr 2000 19:36:02 PDT"><![CDATA[
NewGroupsWind()
	: GroupsListWind(((NNTPApp*) be_app)->GetNewGroupsList(), "New Newsgroups", "newGroupsWind.frame")
{
}
]]></method>

</class>


<class mod-time="Fri, 14 Apr 2000 18:08:42 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
"Connections"
</name>
</class>


<class mod-time="Sat, 08 Apr 2000 11:14:52 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
ConnectionPool
</name>
<hIncludes><![CDATA[
#include <List.h>
#include <Locker.h>

class NNTPConnection;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "NNTPConnection.h"
#include "Messages.h"
#include "Prefs.h"
#include "Error.h"
#include <Autolock.h>

struct ConnectionSpec {
	NNTPConnection*	connection;
	bool           	inUse;

	ConnectionSpec(NNTPConnection* connectionIn)
		: connection(connectionIn), inUse(false) {}
};
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static ConnectionPool* GetPool()
{
	if (connectionPool == NULL)
		connectionPool = new ConnectionPool();
	return connectionPool;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static bool HavePool()
{
	return (connectionPool != NULL);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static void DeletePool()
{
	if (connectionPool) {
		delete connectionPool;
		connectionPool = NULL;
		}
}
]]></method>

<method access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ConnectionPool()
{
	semaphore = create_sem(MaxConnections(), "NNTP Connections");
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~ConnectionPool()
{
	// ASSUMES ALL CONNECTIONS HAVE BEEN RELEASED
	// (which could be remedied by "acquire_sem_etc(semaphore, MaxConnections())")

	// close and delete all connections
	int numConnections = connections.CountItems();
	for (int i=0; i<numConnections; i++) {
		ConnectionSpec* info = (ConnectionSpec*) connections.ItemAt(i);
		NNTPConnection* connection = info->connection;
		connection->SendCommand("quit");
		delete connection;
		delete info;
		}
	connections.MakeEmpty();

	delete_sem(semaphore);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 11:14:52 PDT"><![CDATA[
NNTPConnection* GetConnection()
{
	// block until there's a free connection
	if (acquire_sem(semaphore) != B_NO_ERROR)
		return NULL;

	if (!BAutolock(lock).IsLocked())
		return NULL;

	// find a free connection
	int numConnections = connections.CountItems();
	for (int i=0; i<numConnections; i++) {
		ConnectionSpec* info = (ConnectionSpec*) connections.ItemAt(i);
		if (!info->inUse) {
			// found it!  return it.
			info->inUse = true;
			return info->connection;
			}
		}

	// no free connection; add one
	// create the connection
	NNTPConnection* connection = new NNTPConnection();
	ConnectionSpec* newInfo = new ConnectionSpec(connection);
	connections.AddItem(newInfo);
	newInfo->inUse = true;
	// connect
	status_t err = connection->Connect();
	if (err != B_NO_ERROR) {
		Error::ShowError("Couldn't open connection.", err);
		connections.RemoveItem(newInfo);
		delete newInfo;
		delete connection;
		return NULL;
		}
	return connection;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ReleaseConnection(NNTPConnection* connection)
{
	if (!BAutolock(lock).IsLocked())
		return;

	int numConnections = connections.CountItems();
	for (int i=0; i<numConnections; i++) {
		ConnectionSpec* info = (ConnectionSpec*) connections.ItemAt(i);
		if (info->connection == connection) {
			// found it!  release it
			info->inUse = false;
			release_sem(semaphore);
			return;
			}
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Access"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int NumConnections()
{
	if (!BAutolock(lock).IsLocked())
		return 0;

	int connectionsInUse = 0;
	int numConnections = connections.CountItems();
	for (int i=0; i<numConnections; i++) {
		ConnectionSpec* info = (ConnectionSpec*) connections.ItemAt(i);
		if (info->inUse)
			connectionsInUse++;
		}

	return connectionsInUse;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
NNTPConnection* ConnectionAt(int whichConnection)
{
	if (!BAutolock(lock).IsLocked())
		return 0;

	int connectionsInUse = 0;
	int numConnections = connections.CountItems();
	for (int i=0; i<numConnections; i++) {
		ConnectionSpec* info = (ConnectionSpec*) connections.ItemAt(i);
		if (info->inUse) {
			if (whichConnection == connectionsInUse)
				return info->connection;
			connectionsInUse++;
			}
		}

	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int MaxConnections()
{
	return (Prefs()->GetInt32Pref("maxConnections", defaultMaxConnections));
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance Variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BList connections;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
sem_id semaphore;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BLocker lock;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Static Variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static ConnectionPool* connectionPool = NULL;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Public Tweex"
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int defaultMaxConnections = 4;
]]></variable>

</class>


<class mod-time="Tue, 02 May 2000 16:06:46 PDT" wind-frame="100.000000,60.000000,745.000000,671.000000" list-views-height="0.000000">
<name>
NNTPConnection
</name>
<hIncludes><![CDATA[
#include "string_slice.h"
#include "qstring.h"
#include <SupportDefs.h>

class NNTPResponse;
class RespBuffer;
class Logger;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "NNTPResponse.h"
#include "RespBuffer.h"
#include "Logger.h"
#include "Prefs.h"
#include <socket.h>
#include <netdb.h>
#include <errno.h>
#include <string.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Thu, 27 Apr 2000 22:52:53 PDT"><![CDATA[
NNTPConnection()
	: logger(NULL)
{
	initResult = B_NO_INIT;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~NNTPConnection()
{
	if (socketID != -1)
		closesocket(socketID);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int InitCheck()
{
	return initResult;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Connection"
]]></method>

<method access="public" mod-time="Tue, 02 May 2000 16:06:46 PDT"><![CDATA[
status_t Connect()
{
	initResult = B_NO_ERROR;

	// look up the server
	const char* serverName = Prefs()->GetStringPref("nntpServer");
	const unsigned short port = 119;		//*** make this a pref
	hostent* hostEntry = gethostbyname(serverName);
	if (hostEntry == NULL) {
		initResult = errno;
		return initResult;
		}
	uint32 ipAddress = *(uint32 *) hostEntry->h_addr;

	// open the socket & connect
	socketID = socket(AF_INET, SOCK_STREAM, 0);
	if (socketID == -1) {
		initResult = errno;
		return initResult;
		}
	sockaddr_in remoteSocket;
	remoteSocket.sin_family = AF_INET;
	remoteSocket.sin_port = htons(port);
	remoteSocket.sin_addr.s_addr = ipAddress;
	memset(remoteSocket.sin_zero, 0, 4);
	int err = connect(socketID, (sockaddr*) &remoteSocket, sizeof(remoteSocket));
	if (err != B_NO_ERROR) {
		initResult = errno;
		closesocket(socketID);
		socketID = -1;
		return initResult;
		}

	// read connection response
	err = GetResponse();	// should be 200 or 201
	if (err != 200 && err != 201) {
		initResult = err;
		return initResult;
		}

	// authenticate if appropriate
	string_slice userName = Prefs()->GetStringPref("userName");
	if (!userName.empty()) {
		// send the userName
		qstring command = "AUTHINFO USER ";
		command += userName;
		if (logger)
			logger->Log(command);
		int result = SendLine(command);
		if (result < B_NO_ERROR) {
			initResult = result;
			return initResult;
			}

		// get the response to the userName
		NNTPResponse* response = new NNTPResponse(this);
		result = response->Read(logger);
		delete response;
		if (result < B_NO_ERROR) {
			initResult = result;
			return initResult;
			}

		// send the password if requested
		if (result == 381) {
			// send the password
			string_slice password = Prefs()->GetStringPref("password");
			command = "AUTHINFO PASS ";
			command += password;
			if (logger)
				logger->Log(command);
			result = SendLine(command);
			if (result < B_NO_ERROR) {
				initResult = result;
				return initResult;
				}

			// get the response
			response = new NNTPResponse(this);
			result = response->Read(logger);
			delete response;
			if (result < B_NO_ERROR) {
				initResult = result;
				return initResult;
				}
			}
		}

	return initResult;
}
]]></method>

<method access="public" mod-time="Thu, 27 Apr 2000 22:47:36 PDT"><![CDATA[
status_t SendCommand(string_slice command)
{
	// log the command
	if (logger)
		logger->Log(command);

	// send the command
	status_t result = SendLine(command);
	if (result == ECONNRESET || result == ENOTCONN || result == EBADF || result == -1) {
		// failed--quite possibly the server timed out the connection, so we'll reconnect

		// close the socket (locally)
		qstring group = curGroup;	// save this before we clear it
		closesocket(socketID);
		socketID = -1;
		curGroup = "";

		// reconnect
		result = Connect();

		// reselect the group
		if (result == B_NO_ERROR && group.length() > 0)
			result = SelectGroup(group);

		// resend the command
		if (result == B_NO_ERROR)
			result = SendLine(command);
		}

	lastCommand = command;
	return result;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
status_t SendLine(string_slice command)
{
	ssize_t bytesSent;

	if (command.length() > 0) {		// net_server crashes on zero-length send
		bytesSent = send(socketID, command.begin(), command.length(), 0);
		if (bytesSent < 0)
			return errno;
		}
	bytesSent = send(socketID, "\r\n", 2, 0);
	return (bytesSent < 0 ? bytesSent : B_NO_ERROR);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
status_t SelectGroup(string_slice group)
{
	// kick out if already there
	if (group == curGroup)
		return B_NO_ERROR;

	// send the "group" command
	qstring cmd = "group ";
	cmd += group;
	status_t result = SendCommand(cmd);
	if (result != B_NO_ERROR)
		return result;

	// check the reply
	result = GetResponse();
	if (result != 211)
		return result;

	// set & return
	curGroup = group;
	return B_NO_ERROR;
}
]]></method>

<method access="public" mod-time="Tue, 02 May 2000 13:50:01 PDT"><![CDATA[
status_t GetResponse(NNTPResponse** respLineOut = NULL)
{
	// returns the NNTP result code, or an error code.
	// if "respLine" is given, it will be filled by an NNTPResponse.
	// blocks until the response is received.

	if (respLineOut)
		*respLineOut = NULL;	// until we determine otherwise

	NNTPResponse* response = new NNTPResponse(this);
	status_t result = response->Read(logger);
	if (result < B_NO_ERROR) {
		delete response;
		return result;		
		}

	// handle authentication
	// actually, this is probably never used now that we do "preemptive" authentication
	if (result == 250) {
		delete response;
		string_slice userName = Prefs()->GetStringPref("userName");
		if (userName.empty())
			return result;

		// send the userName
		qstring command = "AUTHINFO USER ";
		command += userName;
		if (logger)
			logger->Log(command);
		result = SendLine(command);
		if (result < B_NO_ERROR)
			return result;

		// get the response to the userName
		response = new NNTPResponse(this);
		result = response->Read(logger);
		delete response;
		if (result < B_NO_ERROR)
			return result;

		// send the password if requested
		if (result == 381) {
			// send the password
			string_slice password = Prefs()->GetStringPref("password");
			command = "AUTHINFO PASS ";
			command += password;
			if (logger)
				logger->Log(command);
			result = SendLine(command);
			if (result < B_NO_ERROR)
				return result;

			// get the response
			response = new NNTPResponse(this);
			result = response->Read(logger);
			delete response;
			}

		// resend the command if authentication succeeded
		if (result == 281) {
			if (logger)
				logger->Log(lastCommand);
			result = SendLine(lastCommand);
			if (result < B_NO_ERROR)
				return result;
			response = new NNTPResponse(this);
			result = response->Read(logger);
			if (result < B_NO_ERROR) {
				delete response;
				return result;
				}
			}
		}

	// return result
	if (respLineOut)
		*respLineOut = response;
	else
		delete response;
	return result;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetGroup(string_slice group)
{
	// for use by callers that send their own "group" commands
	curGroup = group;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Access"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice CurrentGroup()
{
	return curGroup;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
struct in_addr LocalIPAddr()
{
	struct sockaddr_in interface;
	int size = sizeof(interface);
	getsockname(socketID, (struct sockaddr*) &interface, &size);
	return interface.sin_addr;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Communication with NNTPResponse"
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 11:18:24 PDT"><![CDATA[
status_t ReadBuffer(RespBuffer* buffer)
{
	ssize_t bytesRead = 0;
	do {
		bytesRead = recv(socketID, buffer->start, buffer->Length(), 0);
	} while (bytesRead == 0);
	if (bytesRead < 0) {
		buffer->end = buffer->start;
		return errno;
		}
	buffer->end = buffer->start + bytesRead;
	return B_NO_ERROR;
}
]]></method>

<method access="public" mod-time="Thu, 27 Apr 2000 22:42:08 PDT"><![CDATA[
"Logging"
]]></method>

<method access="public" mod-time="Thu, 27 Apr 2000 22:42:25 PDT"><![CDATA[
void AttachLogger(Logger* newLogger)
{
	logger = newLogger;
}
]]></method>

<method access="public" mod-time="Thu, 27 Apr 2000 22:42:36 PDT"><![CDATA[
void DetachLogger()
{
	logger = NULL;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance Variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int socketID;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
qstring curGroup;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int initResult;
]]></variable>

<variable access="protected" mod-time="Thu, 20 Apr 2000 22:47:16 PDT"><![CDATA[
string_slice lastCommand;
]]></variable>

<variable access="protected" mod-time="Thu, 27 Apr 2000 22:41:49 PDT"><![CDATA[
Logger* logger;
]]></variable>

</class>


<class mod-time="Wed, 31 May 2000 02:47:14 PDT" wind-frame="183.000000,111.000000,823.000000,641.000000" list-views-height="0.000000">
<name>
NNTPResponse
</name>
<superclasses>
BLocker
</superclasses>
<hIncludes><![CDATA[
#include "string_slice.h"
#include <Locker.h>

class RespBuffer;
class NNTPConnection;
class NNTPResponseThreadParams;
class Logger;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "RespBuffer.h"
#include "NNTPConnection.h"
#include "Logger.h"
#include <Autolock.h>
#include <stdlib.h>

struct NNTPResponseThreadParams {
	NNTPResponse*	response;
	RespBuffer*  	nextBuffer;

	NNTPResponseThreadParams(NNTPResponse* respIn, RespBuffer* nextBufIn)
		: response(respIn), nextBuffer(nextBufIn) {}
};
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"

NNTPResponse represents the whole response.  Read() will block while the first
bufferful is read; subsequent buffers will be read by a separate thread.

Read() returns either an error code or the NNTP response code, and leaves NextField() etc.
pointed right after the NNTP result code field.

When a buffer fills, it's final line is moved ("spilled") to the next buffer
before the next buffer starts a read.

If this is a "multiline" response, it's complete when the "." line is received.  If not,
it's complete when the first line is received.

The lock (inherited from BLocker) locks the end of the list of RespBuffers, not the
buffers themselves--once they're in the list, they're fair game for the main thread.
]]></method>

<method access="public" mod-time="Thu, 27 Apr 2000 22:50:17 PDT"><![CDATA[
NNTPResponse(NNTPConnection* connectionIn)
	: multiline(false), connection(connectionIn),
	  firstBuffer(NULL), lastBuffer(NULL), readBuffer(NULL), readByte(NULL),
	  readerThread(-1)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~NNTPResponse()
{
	if (readerThread >= 0)
		kill_thread(readerThread);
	ReleaseThru(lastBuffer->end - 1);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action"
]]></method>

<method access="public" mod-time="Thu, 27 Apr 2000 22:50:07 PDT"><![CDATA[
status_t Read(Logger* logger = NULL)
{
	BAutolock(this);

	// set up & read the first buffer
	firstBuffer = new RespBuffer(multiline ? LargeBufferSize : MaxStatusRespSize);
	lastBuffer = firstBuffer;
	status_t result = connection->ReadBuffer(firstBuffer);
	if (result != B_NO_ERROR)
		return result;

	// log the response
	if (logger) {
		logger->Log(NextLine());
		Reset();
		}

	// get the result code and set "multiline" based on it
	// we need this before we can call IsFinalBuffer()
	result = NextIntField();
	switch (result) {
		case 100:	case 215:	case 218:	case 220:	case 221:	case 222:	case 224:
		case 230:	case 231:	case 282:	case 288:
			multiline = true;
			break;

		default:
			multiline = false;
			break;
		}

	// if that's all, we're done
	if (IsFinalBuffer(firstBuffer))
		return result;

	// otherwise, start reading the rest of the buffers
	RespBuffer* nextBuffer = new RespBuffer(LargeBufferSize);
	SpillBuffer(firstBuffer, nextBuffer);
	NNTPResponseThreadParams* threadParams = new NNTPResponseThreadParams(this, nextBuffer);
	readerThread =
		spawn_thread(ThreadStarter, "NNTPResponse reader", B_NORMAL_PRIORITY, threadParams);
	if (readerThread < 0) {
		delete threadParams;
		return readerThread;
		}
	resume_thread(readerThread);

	return result;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Access"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool AtEOF()
{
	BAutolock(this);
	return (readBuffer == lastBuffer && readByte >= lastBuffer->end && readerThread < 0);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice NextLine()
{
	// NOTE: will return an extra blank line at the end

	if (!SetupRead())
		return string_slice();

	// find EOL
	const char* lineStart = readByte;
	const char* p = readByte;
	const char* stopper = readBuffer->end - 1;
	for (; p < stopper; p++) {
		if (*p == '\r' && p[1] == '\n')
			break;
		}
	readByte = p + 2;	// skip the "\r\n"

	// un-escape lines beginning with '.'
	if (*lineStart == '.')
		lineStart++;

	return string_slice(lineStart, p);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice NextField()
{
	if (!SetupRead())
		return string_slice();

	// find the field
	const char* p = readByte;
	const char* stopper = readBuffer->end;
	// skip initial whitespace
	for (; p < stopper; p++) {
		char c = *p;
		if (c != ' ' && c != '\t' && c != '\r' && c != '\n')
			break;
		}
	// read the field, up until the next whitespace
	const char* fieldStart = p;
	for (; p < stopper; p++) {
		char c = *p;
		if (c == ' ' || c == '\t' || c == '\r' || c == '\n')
			break;
		}
	readByte = p;

	return string_slice(fieldStart, p);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int NextIntField()
{
	return sstoi(NextField());
/***
	string_slice field = NextField();

	// convert to int
	char fieldStr[256];
	if (field.length() > 255)
		field.resize(255);
	int len = field.length();
	memcpy(fieldStr, field.begin(), len);
	fieldStr[len] = 0;
	return atoi(fieldStr);
***/
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice NextTabField()
{
	if (!SetupRead())
		return string_slice();

	// find the field
	const char* p = readByte;
	const char* stopper = readBuffer->end;
	const char* fieldStart = p;
	for (; p < stopper; p++) {
		char c = *p;
		if (c == '\t' || c == '\r' || c == '\n')
			break;
		}
	string_slice result(fieldStart, p);

	// skip the tab
	if (p < stopper && *p == '\t')
		p++;
	readByte = p;

	return result;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int NextIntTabField()
{
	return sstoi(NextTabField());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Reset()
{
	readBuffer = NULL;
	SetupRead();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ReleaseThru(const char* byte)
{
	// release all buffers up to the one containing "byte" (and that one too if
	// "byte" is the last byte of that buffer.

	Lock();
	while (firstBuffer) {
		RespBuffer* buffer = firstBuffer;

		// if this is the buffer containing "byte", stop
		if (byte > buffer->buf && byte < buffer->end) {
			if (byte == buffer->end - 1) {
				// "byte" is the last byte in the buffer; delete this buffer too
				firstBuffer = buffer->next;
				delete buffer;
				}
			break;
			}

		// delete this buffer
		firstBuffer = buffer->next;
		delete buffer;
		}
	// finish up deletions
	if (firstBuffer)
		firstBuffer->prev = NULL;
	else
		lastBuffer = NULL;
	Unlock();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="protected" mod-time="Wed, 31 May 2000 02:17:19 PDT"><![CDATA[
void ReadFurtherBuffers(RespBuffer* nextBuffer)
{
	// this is the body of the spawned thread that reads all buffers after the first

	while (true) {
		// read the new buffer
		RespBuffer* newBuffer = nextBuffer;
		connection->ReadBuffer(newBuffer);
		newBuffer->start = newBuffer->buf;	// set start back to beginning; the spill may have
		                                  	// set it into the buffer

		// see if it's the last one
		bool isFinalBuffer = IsFinalBuffer(newBuffer);

		// spill if necessary
		if (!isFinalBuffer) {
			nextBuffer = new RespBuffer(LargeBufferSize);
			SpillBuffer(newBuffer, nextBuffer);
			}

		// link it in
		Lock();
		if (lastBuffer)
			lastBuffer->next = newBuffer;
		newBuffer->prev = lastBuffer;
		lastBuffer = newBuffer;
		if (firstBuffer == NULL)
			firstBuffer = newBuffer;
		Unlock();

		if (isFinalBuffer)
			break;
		}

	// done; mark as such
	readerThread = -1;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsFinalBuffer(RespBuffer* buffer)
{
	if (multiline)
		if (buffer->end - buffer->start >= 5)
			return (string_slice(buffer->end - 5, buffer->end) == "\r\n.\r\n");
		else
			return (string_slice(buffer->end - 3, buffer->end) == ".\r\n");
	else
		return (string_slice(buffer->end - 2, buffer->end) == "\r\n");
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool SetupRead()
{
	// if we haven't started reading, set up
	if (readBuffer == NULL) {
		if (firstBuffer == NULL)
			return false;
		readBuffer = firstBuffer;
		readByte = readBuffer->start;
		}

	// if we're done with the current buffer, go to next buffer
	while (readByte >= readBuffer->end) {
		if (readBuffer->next) {
			readBuffer = readBuffer->next;
			readByte = readBuffer->start;
			}
		else if (readBuffer == lastBuffer && readerThread < 0) {
			// at EOF
			return false;
			}
		else {
			// we're read all the buffers, but we're still waiting for one to come in
			// wait for it...
			while (true) {
				snooze(20000);
				Lock();
				bool haveNewBuffer = (lastBuffer != readBuffer);
				Unlock();
				if (haveNewBuffer)
					break;
				}
			// go to it
			readBuffer = readBuffer->next;
			readByte = readBuffer->start;
			}
		}

	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 May 2000 02:47:14 PDT"><![CDATA[
void SpillBuffer(RespBuffer* buffer, RespBuffer* nextBuffer)
{
	// find last EOL
	char* stopper = buffer->start + 1;
	char* p = buffer->end - 1;
	for (; p >= stopper; --p) {
		if (*p == '\n' && p[-1] == '\r')
			break;
		}
	if (p == buffer->end - 1)
		return;		// ends at line boundary, don't spill
	if (p >= stopper)
		p++;	// skip the '\n'

	// spill to nextBuffer
	uint32 spillLength = buffer->end - p;
	memcpy(nextBuffer->buf, p, spillLength);
	buffer->end = p;
	nextBuffer->start += spillLength;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static int32 ThreadStarter(void* paramsIn)
{
	NNTPResponseThreadParams* paramsObj = (NNTPResponseThreadParams*) paramsIn;
	NNTPResponseThreadParams params = *paramsObj;
	delete paramsObj;

	params.response->ReadFurtherBuffers(params.nextBuffer);

	return B_NO_ERROR;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int sstoi(string_slice ss)
{
	char str[256];
	if (ss.length() > 255)
		ss.resize(255);
	int len = ss.length();
	memcpy(str, ss.begin(), len);
	str[len] = 0;
	return atoi(str);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance Variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool multiline;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
NNTPConnection* connection;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
RespBuffer* firstBuffer;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
RespBuffer* lastBuffer;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
RespBuffer* readBuffer;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
const char* readByte;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
thread_id readerThread;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Public Constants"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const uint32 MaxStatusRespSize = 512;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const uint32 LargeBufferSize = 2048;
]]></variable>

</class>


<class mod-time="Sat, 08 Apr 2000 11:21:22 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
RespBuffer
</name>
<hIncludes><![CDATA[
#include <SupportDefs.h>
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
RespBuffer(uint32 size)
	: prev(NULL), next(NULL)
{
	buf = new char[size];
	start = buf;
	end = buf + size;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~RespBuffer()
{
	delete buf;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Reporting"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
uint32 Length()
{
	return end - start;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance Variables"
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
char* start;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
char* end;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
char* buf;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
RespBuffer* prev;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
RespBuffer* next;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
ConnectionGetter
</name>
<hIncludes><![CDATA[
#include "ConnectionPool.h"

class ConnectionGetter {
public:
	ConnectionGetter()
		: connection(ConnectionPool::GetPool()->GetConnection()) {}
	~ConnectionGetter()
		{ ConnectionPool::GetPool()->ReleaseConnection(connection); }

	NNTPConnection*	Connection() { return connection; }

protected:
	NNTPConnection*	connection;
};
]]></hIncludes>
</class>


<class mod-time="Fri, 14 Apr 2000 18:08:35 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
"Threads"
</name>
</class>


<class mod-time="Fri, 14 Apr 2000 17:31:46 PDT" wind-frame="167.000000,75.000000,807.000000,605.000000" list-views-height="0.000000">
<name>
Thread
</name>
<hIncludes><![CDATA[
#include <OS.h>
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Thread(const char* name = NULL, int32 priority = B_NORMAL_PRIORITY)
{
	if (name == NULL)
		name = "";
	threadID = spawn_thread(ThreadStarter, name, priority, this);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual ~Thread()
{
	// just need to make this virtual
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Virtual"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void Action()
{
	/** pure virtual **/
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
status_t Go()
{
	return resume_thread(threadID);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void WaitFor()
{
	status_t exitValue;
	wait_for_thread(threadID, &exitValue);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private Static"
]]></method>

<method access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static int32 ThreadStarter(void* data)
{
	Thread* thread = (Thread*) data;
	thread->Action();
	delete thread;
	return 0;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance Variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
thread_id threadID;
]]></variable>

</class>


<class mod-time="Mon, 17 Apr 2000 20:15:46 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
OwnedThread
</name>
<superclasses>
public Thread
</superclasses>
<hIncludes><![CDATA[
#include "Thread.h"

class ThreadOwner;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "ThreadOwner.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
OwnedThread(const char* name = NULL, int32 priority = B_NORMAL_PRIORITY)
	: Thread(name, priority), threadOwner(NULL), stopRequested(false)
{
}
]]></method>

<method access="public" mod-time="Mon, 17 Apr 2000 20:15:46 PDT"><![CDATA[
virtual ~OwnedThread()
{
	if (threadOwner)
		threadOwner->ThreadFinished(this);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Virtual"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void Stop()
{
	// virtual; default sets flag, but subclasses are free to use whatever
	// mechanism is appropriate
	stopRequested = true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"For ThreadOwner"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetOwner(ThreadOwner* owner)
{
	threadOwner = owner;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ThreadOwner* threadOwner;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool stopRequested;		// subclasses are free to use a different mechanism
]]></variable>

</class>


<class mod-time="Sat, 08 Apr 2000 08:20:13 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
ThreadOwner
</name>
<hIncludes><![CDATA[
#include <Locker.h>

class OwnedThread;
class BList;

/* mix-in class for objects that need to own threads */
]]></hIncludes>
<cppIncludes><![CDATA[
#include "OwnedThread.h"
#include <List.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ThreadOwner()
{
	threads = new BList();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~ThreadOwner()
{
	KillOwnedThreads();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void StartThread(OwnedThread* thread)
{
	threadsLock.Lock();
	threads->AddItem(thread);
	threadsLock.Unlock();
	thread->SetOwner(this);
	thread->Go();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void KillOwnedThreads()
{
	// signal all threads to stop
	threadsLock.Lock();
	int numThreads = threads->CountItems();
	for (int i=0; i<numThreads; i++) {
		OwnedThread* thread = (OwnedThread*) threads->ItemAt(i);
		thread->Stop();
		}
	threadsLock.Unlock();

	while (true) {
		// get the next thread, if there are any left
		threadsLock.Lock();
		OwnedThread* thread = (OwnedThread*) threads->ItemAt(0);
		threadsLock.Unlock();
		if (thread == NULL)
			break;

		// wait for it to die
		//*** POSSIBLE RACE CONDITION--if thread dies after the Unlock() but before
		//*** we get here.
		thread->WaitFor();
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"For children"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ThreadFinished(OwnedThread* thread)
{
	threadsLock.Lock();
	threads->RemoveItem(thread);
	threadsLock.Unlock();
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BList* threads;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BLocker threadsLock;
]]></variable>

</class>


<class mod-time="Tue, 18 Apr 2000 17:38:48 PDT" wind-frame="84.000000,88.000000,724.000000,618.000000" list-views-height="0.000000">
<name>
ArticleSavingThread
</name>
<superclasses>
public Thread
</superclasses>
<hIncludes><![CDATA[
#include "Thread.h"
#include "string_slice.h"

class BFile;
class NNTPResponse;
class Task;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "NNTPResponse.h"
#include "Task.h"
#include "ParseUtils.h"
#include <File.h>
]]></cppIncludes>
<method access="public" mod-time="Fri, 14 Apr 2000 17:32:16 PDT"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Fri, 14 Apr 2000 17:35:27 PDT"><![CDATA[
ArticleSavingThread(const char* name = NULL, int32 priority = B_NORMAL_PRIORITY)
	: Thread(name, priority)
{
}
]]></method>

<method access="public" mod-time="Fri, 14 Apr 2000 17:36:01 PDT"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Tue, 18 Apr 2000 17:38:48 PDT"><![CDATA[
status_t WriteFile(BFile* file, NNTPResponse* response, string_slice lineEnd,
                   Task* task, bool forBinary = false)
{
	// rewind to beginning of article
	response->Reset();
	response->NextLine();	// skip result line

	// set up progress
	bool haveProgressMax = (task->GetProgressMax() != 0);
	int progressBase = task->CurProgress();

	// write
	bool inBody = false;
	int curLines = 0;
	while (!response->AtEOF()) {
		string_slice line = response->NextLine();
		if (!forBinary || (inBody && !line.empty())) {
			ssize_t result = file->Write(line.begin(), line.length());
			if (result >= 0)
				result = file->Write(lineEnd.begin(), lineEnd.length());
			if (result < 0)
				return result;
			}

		// progress
		if (!inBody) {
			if (line.length() == 0)
				inBody = true;
			else if (!haveProgressMax) {
				// check for "Lines" header
				string_slice header, value;
				ParseUtils::ParseHeader(line, &header, &value);
				if (header == "Lines") {
					task->SetProgressMax(value.asInt());
					haveProgressMax = true;
					}
				}
			}
		else {
			curLines++;
			if (task->IsReadyForUpdate())
				task->SetProgress(progressBase + curLines);
			}
		}

	task->SetProgress(progressBase + curLines);

	return B_NO_ERROR;
}
]]></method>

</class>


<class mod-time="Sat, 08 Apr 2000 10:09:47 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
OpenNewsrcThread
</name>
<superclasses>
public Thread
</superclasses>
<hIncludes><![CDATA[
#include "Thread.h"
#include <Entry.h>

/*
	This really doesn't need to be a thread anymore, since the real multi-threaded
	functionality has been moved to GetGroupStatsThread.  But since it already is
	one, I'm not going to bother to get rid of it.
*/
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Newsrc.h"
#include "NewsrcWind.h"
#include "Newsgroup.h"
#include "ConnectionPool.h"
#include "NNTPConnection.h"
#include "NNTPResponse.h"
#include "Error.h"
#include <File.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
OpenNewsrcThread(entry_ref* fileRefIn)
	: Thread("OpenNewsrc"), fileRef(*fileRefIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Thread virtual"
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 10:09:47 PDT"><![CDATA[
void Action()
{
	// open the file
	BFile* file = new BFile(&fileRef, B_READ_WRITE);
	status_t err = file->InitCheck();
	if (err != B_NO_ERROR) {
		Error::ShowError("Couldn't open \"", fileRef.name, "\".", err);
		delete file;
		return;
		}

	// create the newsrc
	Newsrc* newsrc = new Newsrc(file);

	// read the Newsrc
	newsrc->Read();

	// create the window
	new NewsrcWind(newsrc, fileRef.name);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
entry_ref fileRef;
]]></variable>

</class>


<class mod-time="Sat, 08 Apr 2000 10:21:33 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
GetGroupStatsThread
</name>
<superclasses>
public OwnedThread
</superclasses>
<hIncludes><![CDATA[
#include "OwnedThread.h"

class Newsrc;
class NewsrcWind;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Newsrc.h"
#include "NewsrcWind.h"
#include "Newsgroup.h"
#include "ConnectionPool.h"
#include "NNTPConnection.h"
#include "NNTPResponse.h"
#include "Task.h"
#include "Error.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GetGroupStatsThread(Newsrc* newsrcIn, NewsrcWind* windIn)
	: OwnedThread("GetGroupStats"), newsrc(newsrcIn), wind(windIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Thread virtuals"
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 10:21:33 PDT"><![CDATA[
void Action()
{
	Task task("Getting article counts...");

	// get a connection
	ConnectionPool* connectionPool = ConnectionPool::GetPool();
	NNTPConnection* connection = connectionPool->GetConnection();
	if (connection == NULL) {
		Error::ShowError("Couldn't get a connection.");
		return;
		}
	task.GotConnection();

	// start getting the available article ranges
	NNTPResponse* response = NULL;
	int numGroups = newsrc->NumNewsgroups();
	task.SetProgressMax(numGroups);
	for (int i=0; i<numGroups; i++) {
		if (stopRequested)
			break;

		Newsgroup* newsgroup = newsrc->NewsgroupAt(i);
		task.SetProgress(i);
		task.SetProgressString(newsgroup->Name());

		// send the "group" command
		qstring cmd = "group ";
		cmd += newsgroup->Name();
		connection->SendCommand(cmd);

		// get the results
		int result = connection->GetResponse(&response);
		if (result != 211) {
			if (result == 411)
				continue;
			else {
				// probably something wrong with the connection
				// show an error?
				continue;	// break?
				}
			}
		connection->SetGroup(newsgroup->Name());
		int numArticles = response->NextIntField();		// ignore the "unused variable" warning.
		int firstArticle = response->NextIntField();
		int lastArticle = response->NextIntField();
		delete response;

		// update newsgroup & wind
		newsgroup->SetAvailableArticles(firstArticle, lastArticle);
		if (!stopRequested)
			wind->InvalidateNewsgroupAt(i);
		}

	connectionPool->ReleaseConnection(connection);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Newsrc* newsrc;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
NewsrcWind* wind;
]]></variable>

</class>


<class mod-time="Sat, 08 Apr 2000 10:23:41 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
OpenGroupThread
</name>
<superclasses>
public OwnedThread
</superclasses>
<hIncludes><![CDATA[
#include "OwnedThread.h"
#include "Newsgroup.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "NNTPConnection.h"
#include "NNTPResponse.h"
#include "ConnectionPool.h"
#include "NewsgroupWind.h"
#include "Task.h"
#include "qstring.h"
#include "Error.h"

class ArticleSet;
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
OpenGroupThread(Newsgroup* newsgroupIn)
	: OwnedThread("Open Group"), newsgroup(newsgroupIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Thread virtuals"
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 10:23:41 PDT"><![CDATA[
void Action()
{
	NNTPResponse* response;
	int result;

	Task task(newsgroup->Name());

	// open the window
	new NewsgroupWind(newsgroup);
	snooze(20000);	// this seems to be the only way to get the window to display
	              	// before ReadArticleCache() locks it

	// read the cached headers, even before getting a connection, since that
	// could take a few seconds
	ArticleSet* cachedArticles = newsgroup->ReadArticleCache();

	// get a connection
	ConnectionPool* connectionPool = ConnectionPool::GetPool();
	NNTPConnection* connection = connectionPool->GetConnection();
	if (connection == NULL) {
		Error::ShowError("Couldn't get a connection to read ", newsgroup->Name(), "!");
		return;
		}
	task.GotConnection();
	task.SetProgressString(newsgroup->Name());

	// go to the newsgroup and get the stats if necessary
	//    no, do it always; unless we tell the newsgroup there are more
	//    are more articles available, it won't know it has to get
	//    more headers
	const bool needStats = true;
/***
	bool needStats = (!newsgroup->HaveAvailableArticlesInfo() ||
	                  connection->CurrentGroup() != newsgroup->Name());
***/
	if (needStats) {
		qstring cmd = "group ";
		cmd += newsgroup->Name();
		connection->SendCommand(cmd);
		}

	// get the results of the "group" command if we sent one
	if (needStats) {
		result = connection->GetResponse(&response);
		if (result != 211) {
			if (result == 411)
				Error::ShowError(newsgroup->Name(), " no longer exists on the server.");
			else
				Error::ShowError("Couldn't open ", newsgroup->Name(), ".", result);
			connectionPool->ReleaseConnection(connection);
			return;
			}
		connection->SetGroup(newsgroup->Name());
		int numArticles = response->NextIntField();	// ignore "unused variable" warning
		int firstArticle = response->NextIntField();
		int lastArticle = response->NextIntField();
		delete response;
		newsgroup->SetAvailableArticles(firstArticle, lastArticle);
		}
	if (stopRequested)
		goto stop;

	// have the newsgroup read its headers
	result = newsgroup->ReadHeaders(connection, cachedArticles, &task, stopRequested);
	if (result != B_NO_ERROR) {
		Error::ShowError("Couldn't get headers for ", newsgroup->Name(), ".", result);
		delete newsgroup;
		connectionPool->ReleaseConnection(connection);
		return;
		}
	if (stopRequested)
		goto stop;

stop:
	// clean up
	connectionPool->ReleaseConnection(connection);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Newsgroup* newsgroup;
]]></variable>

</class>


<class mod-time="Sat, 15 Apr 2000 01:07:17 PDT" wind-frame="251.000000,139.000000,891.000000,669.000000" list-views-height="0.000000">
<name>
OpenArticleThread
</name>
<superclasses>
public ArticleSavingThread
</superclasses>
<hIncludes><![CDATA[
#include "ArticleSavingThread.h"
#include "string_slice.h"

class Article;
class Newsgroup;
class NNTPResponse;
class NNTPConnection;
class Task;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Newsgroup.h"
#include "NNTPConnection.h"
#include "NNTPResponse.h"
#include "ConnectionPool.h"
#include "ParseUtils.h"
#include "Task.h"
#include "Error.h"
#include <Path.h>
#include <FindDirectory.h>
#include <File.h>
#include <NodeInfo.h>
#include <Entry.h>
#include <Roster.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Fri, 14 Apr 2000 17:41:23 PDT"><![CDATA[
OpenArticleThread(Newsgroup* newsgroupIn, int articleNoIn, string_slice subjectIn, int linesIn)
	: ArticleSavingThread("Open Article"), newsgroup(newsgroupIn), articleNo(articleNoIn),
	  subject(subjectIn), lines(linesIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Thread virtuals"
]]></method>

<method access="public" mod-time="Sat, 15 Apr 2000 01:07:17 PDT"><![CDATA[
void Action()
{
	Task task(subject);
	task.SetProgressMax(lines);

	// get a connection
	ConnectionPool* connectionPool = ConnectionPool::GetPool();
	NNTPConnection* connection = connectionPool->GetConnection();
	if (connection == NULL) {
		Error::ShowError("Couldn't get a connection to read ", newsgroup->Name(), "!");
		return;
		}
	task.GotConnection();

	// select the newsgroup
	int result = connection->SelectGroup(newsgroup->Name());
	if (result != B_NO_ERROR) {
		Error::ShowError("Couldn't open ", newsgroup->Name(), " to get article.", result);
		connectionPool->ReleaseConnection(connection);
		return;
		}

	// get the article
	qstring cmd = "article ";
	cmd += articleNo;
	NNTPResponse* response = NULL;
	result = connection->SendCommand(cmd);
	if (result == B_NO_ERROR)
		result = connection->GetResponse(&response);
	if (result != 220) {
		Error::ShowError("Couldn't get article.", result);
		delete response;
		connectionPool->ReleaseConnection(connection);
		return;
		}

	// find the article's message-id--we'll use it as the filename
	string_slice messageID = ExtractMessageID(response);
	// make sure it doesn't have any slashes
	for (const char* p = messageID.begin(); p != messageID.end(); ++p) {
		if (*p == '/') {
			messageID = "xxx";
			break;
			}
		}

	// open the file
	BPath path;
	result = find_directory(B_COMMON_TEMP_DIRECTORY, &path, true);
	if (result != B_NO_ERROR) {
		Error::ShowError("Couldn't find temp directory.", result);
		delete response;
		connectionPool->ReleaseConnection(connection);
		return;
		}
	path.Append(qstring(messageID).c_str());
	BFile* file = new BFile(path.Path(), B_READ_WRITE | B_CREATE_FILE | B_ERASE_FILE);
	result = file->InitCheck();
	if (result != B_NO_ERROR) {
		Error::ShowError("Couldn't create message file.", result);
		delete response;
		connectionPool->ReleaseConnection(connection);
		delete file;
		return;
		}

	// set the MIME info
	BNodeInfo nodeInfo(file);
	nodeInfo.SetType("text/x-news");

	// write the file
	result = WriteFile(file, response, "\n", &task);
	delete file;
	delete response;
	connectionPool->ReleaseConnection(connection);
	if (result != B_NO_ERROR) {
		Error::ShowError("Error writing message file.", result);
		return;
		}

	// open the file with the viewer app
	entry_ref fileRef, appRef;
	result = get_ref_for_path(path.Path(), &fileRef);
	if (result == B_NO_ERROR)
		result = be_roster->FindApp(&fileRef, &appRef);
	if (result == B_NO_ERROR) {
		// cook up the B_REFS_RECEIVED message ourself so we can pass extra
		// info to the viewer app
		BMessage refsMessage(B_REFS_RECEIVED);
		refsMessage.AddRef("refs", &fileRef);
		refsMessage.AddBool("spacebarCanClose", true);
		be_roster->Launch(&appRef, &refsMessage);
		}

	// mark as read in the newsgroup
	newsgroup->ArticleRead(articleNo);
	newsgroup->ReadArticlesChanged();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice ExtractMessageID(NNTPResponse* response)
{
	string_slice name, value;
	while (true) {
		// get the next line
		string_slice line = response->NextLine();
		if (line.length() == 0) {
			// we're out of the headers, there was no message-id
			break;
			}

		// parse & check if it's the Message-ID header
		ParseUtils::ParseHeader(line, &name, &value);
		if (name == "Message-ID")
			return value;
		}

	/***/
	return string_slice("xxx");
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Newsgroup* newsgroup;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int articleNo;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice subject;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int lines;
]]></variable>

</class>


<class mod-time="Fri, 14 Apr 2000 18:26:03 PDT" wind-frame="267.000000,166.000000,907.000000,696.000000" list-views-height="0.000000">
<name>
SaveArticleThread
</name>
<superclasses>
public ArticleSavingThread
</superclasses>
<hIncludes><![CDATA[
#include "ArticleSavingThread.h"
#include "string_slice.h"
#include "qstring.h"
#include "LineEndType.h"
#include <Message.h>

class NNTPResponse;
class NNTPConnection;
class Task;

#define copies
]]></hIncludes>
<cppIncludes><![CDATA[
#include "ConnectionGetter.h"
#include "NNTPConnection.h"
#include "NNTPResponse.h"
#include "ParseUtils.h"
#include "Task.h"
#include "Error.h"
#include <File.h>
#include <Locker.h>
#include <Entry.h>
#include <stdio.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Fri, 14 Apr 2000 17:36:28 PDT"><![CDATA[
SaveArticleThread(copies BMessage* messageIn)
	: ArticleSavingThread("Save Article"), message(*messageIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Action()
{
	// get the info out of the message
	entry_ref fileRef;
	status_t result = message.FindRef("refs", &fileRef);
	if (result != B_NO_ERROR)
		return;
	string_slice groupName(message.FindString("groupName"));
	if (groupName.length() == 0)
		return;

	// save the messages
	for (int i=0; ; i++) {
		// get the info
		int32 articleNo = message.FindInt32("articleNos", i);
		if (articleNo == 0)
			break;
		string_slice subject(message.FindString("subjects", i));
		if (subject.length() == 0)
			break;

		// save
		SaveMessage(&fileRef, groupName, articleNo, subject);
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 10:26:25 PDT"><![CDATA[
void SaveMessage(entry_ref* fileRef, string_slice groupName, int articleNo, string_slice subject)
{
	status_t result;

	// set up progress
	qstring progressStr = subject;
	progressStr += " -> ";
	progressStr += fileRef->name;
	Task task(progressStr);

	// open the file
	BFile file(fileRef, B_READ_WRITE | B_CREATE_FILE);
	if (file.InitCheck() != B_NO_ERROR) {
		Error::ShowError("Couldn't open ", fileRef->name, ".", file.InitCheck());
		return;
		}

	// find out the line-end type
	LineEndType lineEndType = GetLineEndType(&file);
	if (lineEndType == UnknownLineEndType)
		lineEndType = BeLineEndType;	// for new file, make it a Be text file

	// get a connection
	ConnectionGetter connectionGetter;
	NNTPConnection* connection = connectionGetter.Connection();
	connection->SelectGroup(groupName);
	task.GotConnection();

	// send the command to read the article
	qstring cmd = "article ";
	cmd += articleNo;
	NNTPResponse* response = NULL;
	result = connection->SendCommand(cmd);
	if (result == B_NO_ERROR)
		result = connection->GetResponse(&response);
	if (result != 220) {
		Error::ShowError("Couldn't get article \"", subject, "\".", result);
		delete response;
		return;
		}

	// start writing the file
	string_slice lineEnd = lineEndFor[lineEndType];
	off_t fileLen;
	file.GetSize(&fileLen);
	file.Seek(fileLen, SEEK_SET);
	if (fileLen > 0) {
		// write the divider
		file.Write(lineEnd.begin(), lineEnd.length());
		file.Write(divider.begin(), divider.length());
		file.Write(lineEnd.begin(), lineEnd.length());
		file.Write(lineEnd.begin(), lineEnd.length());
		}

	// write the article into the file
	result = WriteFile(&file, response, lineEnd, &task);
	delete response;
	if (result < B_NO_ERROR) {
		Error::ShowError("Error while writing to \"", fileRef->name, "\".", result);
		return;
		}
}
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 10:37:58 PDT"><![CDATA[
LineEndType GetLineEndType(BFile* file)
{
	LineEndType lineEndType = UnknownLineEndType;
	file->Seek(0, SEEK_SET);
	static size_t bufSize = 1024;
	char* buf = new char[bufSize];
	while (true) {
		// read a bufferfull
		ssize_t bytesRead = file->Read(buf, bufSize);
		if (bytesRead < 0)
			break;

		// find a line end
		const char* p = buf;
		const char* stopper = buf + bufSize;
		bool foundLineEnd = false;
		for (; p<stopper; p++) {
			if (*p == '\n') {
				lineEndType = BeLineEndType;
				foundLineEnd = true;
				break;
				}
			else if (*p == '\r') {
				if (p<stopper-1 && p[1] == '\n')	//** slight bug: fails if "\r\n" straddles buffer boundary
					lineEndType = NetworkLineEndType;
				else
					lineEndType = MacLineEndType;
				foundLineEnd = true;
				break;
				}
			}
		if (foundLineEnd)
			break;

		// quit if it was the last buffer
		if ((size_t) bytesRead < bufSize)
			break;
		}

	delete buf;

	return lineEndType;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BMessage message;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const string_slice divider = "----------------------------------------------------------------------";
]]></variable>

</class>


<class mod-time="Thu, 27 Apr 2000 22:56:01 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
PostArticlesThread
</name>
<superclasses>
public OwnedThread
</superclasses>
<hIncludes><![CDATA[
#include "OwnedThread.h"

class NNTPConnection;
class Task;
class qstring;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "NNTPConnection.h"
#include "NNTPResponse.h"
#include "ConnectionGetter.h"
#include "TextReader.h"
#include "ParseUtils.h"
#include "Error.h"
#include "Autodeleter.h"
#include "Task.h"
#include "Logger.h"
#include "qstring.h"
#include <E-mail.h>
#include <Entry.h>
#include <File.h>
#include <socket.h>
#include <netdb.h>
#include <stdio.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
PostArticlesThread(BList* fileRefsIn)
	: OwnedThread("Post Articles"), fileRefs(fileRefsIn)
{
	/***/
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~PostArticlesThread()
{
	int numFileRefs = fileRefs->CountItems();
	for (int i=0; i<numFileRefs; i++)
		delete (entry_ref*) fileRefs->ItemAt(i);
	delete fileRefs;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Thread virtuals"
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 10:39:10 PDT"><![CDATA[
void Action()
{
	int i;

	// find out the total size (in bytes)
	int totalBytes = 0;
	int numFiles = fileRefs->CountItems();
	for (i=0; i<numFiles; i++) {
		BEntry entry((entry_ref*) fileRefs->ItemAt(i), true);
		off_t fileSize;
		if (entry.GetSize(&fileSize) == B_NO_ERROR)
			totalBytes += fileSize;
		}

	// set up progress
	Task task("Posting...");
	task.SetProgressMax(totalBytes);

	// get a connection
	ConnectionGetter connectionGetter;
	NNTPConnection* connection = connectionGetter.Connection();
	if (connection == NULL) {
		Error::ShowError("Couldn't get a connection to post articles.");
		return;
		}
	task.GotConnection();

	// post the files
	for (i=0; i<numFiles; i++)
		PostArticle((entry_ref*) fileRefs->ItemAt(i), connection, &task);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Thu, 27 Apr 2000 22:55:50 PDT"><![CDATA[
status_t PostArticle(entry_ref* fileRef, NNTPConnection* connection, Task* task)
{
	status_t result = B_NO_ERROR;

	// setup progress reporting
	qstring progressString = "Posting \"";
	progressString += fileRef->name;
	progressString += "\"";
	task->SetProgressString(progressString);
	int progressBase = task->CurProgress();

	// open the file
	BFile file(fileRef, B_READ_ONLY);
	result = file.InitCheck();
	if (result != B_NO_ERROR)
		return Error::ShowError("Couldn't open \"", fileRef->name, "\".", result);

	// read the file
	off_t fileSize;
	file.GetSize(&fileSize);
	char* text = new char[fileSize];
	Autodeleter<char> textDeleter(text);
	result = file.ReadAt(0, text, fileSize);
	if (result < B_NO_ERROR)
		return Error::ShowError("Couldn't read \"", fileRef->name, "\".", result);
	TextReader reader(string_slice(text, text + fileSize));

	// log
	Logger logger(connection);

	// start sending
	connection->SendCommand("POST");
	result = connection->GetResponse();
	if (result != 340)
		return Error::ShowError("Couldn't post article.", result);

	// send the headers
	string_slice line;
	bool haveFrom = false, haveDate = false, haveReplyTo = false, haveMessageID = false;;
	while (!reader.AtEOF()) {
		line = reader.NextLine();
		if (line.length() == 0)
			break;

		// write the header
		connection->SendCommand(line);
		task->SetProgress(progressBase + reader.Position());

		// check for required headers
		string_slice headerName, headerValue;
		ParseUtils::ParseHeader(line, &headerName, &headerValue);
		if (headerName == "From")
			haveFrom = true;
		else if (headerName == "Date")
			haveDate = true;
		else if (headerName == "Reply-To" || headerName == "Reply-to")
			haveReplyTo = true;
		else if (headerName == "Message-ID")
			haveMessageID = true;
		}

	// send missing headers
	if (!haveFrom) {
		qstring* fromHeader = GetFromHeader();
		if (fromHeader)
			connection->SendCommand(*fromHeader);
		delete fromHeader;
		}
	if (!haveDate) {
		time_t curTime = time(NULL);
		char dateStr[256];
		strftime(dateStr, 256, "Date: %a, %d %b %Y %T %Z", localtime(&curTime));
		connection->SendCommand(dateStr);
		}
	if (!haveMessageID) {
		qstring* messageIDHeader = GetMessageIDHeader(connection);
		if (messageIDHeader)
			connection->SendCommand(*messageIDHeader);
		delete messageIDHeader;
		}
	if (!haveReplyTo) {
		qstring* replyToHeader = GetReplyToHeader();
		if (replyToHeader)
			connection->SendCommand(*replyToHeader);
		delete replyToHeader;
		}

	// finish header section
	connection->SendCommand("");

	// write the body
	while (!reader.AtEOF()) {
		line = reader.NextLine();

		// send the line, doubling initial period if there is one
		if (line[0] == '.') {
			qstring quotedLine = ".";
			quotedLine += line;
			connection->SendCommand(quotedLine);
			}
		else
			connection->SendCommand(line);

		task->SetProgress(progressBase + reader.Position());
		}

	// finish
	task->SetProgress(progressBase + fileSize);
	connection->SendCommand(".");
	NNTPResponse* response;
	result = connection->GetResponse(&response);
	if (result != 240) {
		qstring msg = "Couldn't post \"";
		msg += fileRef->name;
		msg += "\".  (";
		msg += response->NextLine();
		msg += ")";
		delete response;
		return Error::ShowError(msg, result);
		}
	delete response;

	return B_NO_ERROR;
}
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 10:41:05 PDT"><![CDATA[
qstring* GetFromHeader()
{
	// ask the mail_daemon
	mail_pop_account accountInfo;
	status_t result = get_pop_account(&accountInfo);
	if (result != B_NO_ERROR)
		return NULL;

	if (accountInfo.pop_name[0] == 0 && accountInfo.reply_to[0])
		Error::ShowError("If posting fails, you should choose Preferences/E-mail from the Be menu and set up your email settings.");

	// build the "From:" header
	qstring* str = new qstring("From: ");
	if (accountInfo.real_name[0]) {
		*str += accountInfo.real_name;
		*str += " <";
		}
	if (accountInfo.reply_to[0])
		*str += accountInfo.reply_to;
	else if (accountInfo.pop_name[0]) {
		*str += accountInfo.pop_name;
		if (accountInfo.pop_host[0]) {
			*str += "@";
			*str += accountInfo.pop_host;
			}
		}
	if (accountInfo.real_name[0])
		*str += ">";
	return str;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
qstring* GetReplyToHeader()
{
	// ask the mail_daemon
	mail_pop_account accountInfo;
	status_t result = get_pop_account(&accountInfo);
	if (result != B_NO_ERROR)
		return NULL;
	if (accountInfo.reply_to[0] == 0)
		return NULL;

	// build the "Reply-To:" header
	qstring* str = new qstring("Reply-To: ");
	*str += accountInfo.reply_to;
	return str;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
qstring* GetMessageIDHeader(NNTPConnection* connection)
{
	// get the address
	struct in_addr address = connection->LocalIPAddr();

	// get the date/time info
	time_t curTime = time(NULL);
	char dateStr[256];
	strftime(dateStr, 256, "%Y%m%d%H%M%S", localtime(&curTime));
	char usecStr[128];
	sprintf(usecStr, "%06d", (int) (system_time() % 1000000));

	// build the string
	qstring* str = new qstring("Message-ID: <");
	*str += dateStr;
	*str += ".";
	*str += usecStr;
	*str += "@";
	*str += inet_ntoa(address);
	*str += ">";
	return str;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BList* fileRefs;
]]></variable>

</class>


<class mod-time="Mon, 17 Apr 2000 21:12:51 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
GetGroupsListThread
</name>
<superclasses>
public OwnedThread
</superclasses>
<hIncludes><![CDATA[
#include "OwnedThread.h"

class AllGroupsList;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "AllGroupsList.h"
#include "ConnectionGetter.h"
#include "NNTPConnection.h"
#include "NNTPResponse.h"
#include "NNTPApp.h"
#include "Task.h"
#include "Prefs.h"
#include "Error.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Mon, 17 Apr 2000 18:32:40 PDT"><![CDATA[
GetGroupsListThread(AllGroupsList* groupsListIn)
	: groupsList(groupsListIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Thread virtuals"
]]></method>

<method access="public" mod-time="Mon, 17 Apr 2000 21:12:51 PDT"><![CDATA[
void Action()
{
	Task task("Getting the list of all newsgroups...");
	time_t curTime = time(NULL);

	// get a connection
	ConnectionGetter connectionGetter;
	NNTPConnection* connection = connectionGetter.Connection();
	if (connection == NULL) {
		Error::ShowError("Couldn't get connection to read all groups.");
		return;
		}
	task.GotConnection();

	// send the LIST command
	status_t result = connection->SendCommand("LIST");
	if (result != B_NO_ERROR) {
		Error::ShowError("Couldn't send command to get groups list.", result);
		return;
		}
	NNTPResponse* response;
	result = connection->GetResponse(&response);
	if (result != 215) {
		Error::ShowError("An error occurred while getting the groups list.", result);
		return;
		}
	groupsList->SetResponse(response);
	response->NextLine();	// skip rest of response line

	// read the result
	int bumpProgressAfter = progressQuantum;
	for (; !response->AtEOF(); response->NextLine()) {
		string_slice groupName = response->NextField();
		if (groupName.length() == 0 || groupName == ".")	// check for ".", because NextField() doesn't deal with that like NextLine() does
			continue;

		// add the group (but check if it's already there first)
		groupsList->AddGroup(groupName);

		// update progress
		--bumpProgressAfter;
		if (bumpProgressAfter <= 0) {
			task.BumpProgress();
			bumpProgressAfter = progressQuantum;
			}
		}

	groupsList->Dirtify();

	// update the pref
	Prefs()->SetInt32Pref("lastGroupsUpdateTime", curTime);

	// automatically pop the groups list window open
	((NNTPApp*) be_app)->OpenAllGroupsWind();
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Mon, 17 Apr 2000 18:33:32 PDT"><![CDATA[
AllGroupsList* groupsList;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int progressQuantum = 20;
]]></variable>

</class>


<class mod-time="Mon, 17 Apr 2000 21:59:20 PDT" wind-frame="114.000000,153.000000,754.000000,683.000000" list-views-height="0.000000">
<name>
GetNewGroupsThread
</name>
<superclasses>
public OwnedThread
</superclasses>
<hIncludes><![CDATA[
#include "OwnedThread.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "AllGroupsList.h"
#include "ConnectionGetter.h"
#include "NNTPConnection.h"
#include "NNTPResponse.h"
#include "NNTPApp.h"
#include "Task.h"
#include "Prefs.h"
#include "OSException.h"
]]></cppIncludes>
<method access="public" mod-time="Mon, 17 Apr 2000 19:15:37 PDT"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Mon, 17 Apr 2000 19:15:52 PDT"><![CDATA[
GetNewGroupsThread()
{
}
]]></method>

<method access="public" mod-time="Mon, 17 Apr 2000 19:15:56 PDT"><![CDATA[
"Thread virtuals"
]]></method>

<method access="public" mod-time="Mon, 17 Apr 2000 21:59:20 PDT"><![CDATA[
void Action()
{
	Task task("Getting new groups...");

	try {

	// get the relevant times
	time_t lastUpdate = Prefs()->GetInt32Pref("lastGroupsUpdateTime");
	time_t curTime = time(NULL);

	// get a connection
	ConnectionGetter connectionGetter;
	NNTPConnection* connection = connectionGetter.Connection();
	if (connection == NULL)
		throw OSException("Couldn't get connection to get new groups.");
	task.GotConnection();

	// send the NEWGROUPS command
	// ignore the compiler warning about strftime(); the NEWGROUPS command
	// really does take only a two-digit year
	char command[128];
	struct tm* timeStruct = gmtime(&lastUpdate);
	strftime(command, 128, "NEWGROUPS %y%m%d %H%M%S GMT", timeStruct);
	status_t result = connection->SendCommand(command);
	if (result != B_NO_ERROR)
		throw OSException("Couldn't send command to get the new groups.", result);
	NNTPResponse* response;
	result = connection->GetResponse(&response);
	if (result != 231)
		throw OSException("An error occurred while getting the new groups.", result);
	response->NextLine();	// skip rest of response line

	// read the result
	GroupsList* groupsList = NULL;
	GroupsList* allGroupsList = NULL;
	for (; !response->AtEOF(); response->NextLine()) {
		string_slice groupName = response->NextField();
		if (groupName.length() == 0 || groupName == ".")	// check for ".", because NextField() doesn't deal with that like NextLine() does
			continue;

		// set up the groupsList (& allGroupsList) if we haven't done so already
		if (groupsList == NULL) {
			NNTPApp* app = (NNTPApp*) be_app;
			groupsList = app->GetNewGroupsList();
			groupsList->SetResponse(response);
			allGroupsList = app->GetAllGroupsList();
			app->OpenNewGroupsWind();
			}

		// add the group (but check if it's already there first)
		groupsList->AddGroup(groupName);
		allGroupsList->AddGroup(groupName);

		// update progress
		task.BumpProgress();
		}

	// update the pref
	Prefs()->SetInt32Pref("lastGroupsUpdateTime", curTime);
	}
	catch (DisplayableException& e) {
		e.Display();
		}
}
]]></method>

</class>


<class mod-time="Tue, 18 Apr 2000 17:19:32 PDT" wind-frame="139.000000,100.000000,779.000000,630.000000" list-views-height="0.000000">
<name>
ExtractBinariesThread
</name>
<superclasses>
public ArticleSavingThread
</superclasses>
<hIncludes><![CDATA[
#include "ArticleSavingThread.h"

class Newsgroup;
class Subject;
class Article;
class SubjectsView;
class BList;

struct BinaryArticleSpec {
	Subject*	subject;
	Article*	article;

	BinaryArticleSpec(Subject* subjectIn, Article* articleIn)
		: subject(subjectIn), article(articleIn) {}
};

#define takes
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Newsgroup.h"
#include "Subject.h"
#include "Article.h"
#include "ConnectionGetter.h"
#include "NNTPConnection.h"
#include "NNTPResponse.h"
#include "SubjectsView.h"
#include "Task.h"
#include "Prefs.h"
#include "Error.h"
#include "OSException.h"
#include <File.h>
#include <Entry.h>
#include <List.h>
#include <stdio.h>
#include <unistd.h>
#include <memory>
]]></cppIncludes>
<method access="public" mod-time="Fri, 14 Apr 2000 18:28:51 PDT"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Sat, 15 Apr 2000 02:36:37 PDT"><![CDATA[
ExtractBinariesThread(Newsgroup* newsgroupIn, takes BList* articlesIn,
                      SubjectsView* subjectsViewIn, bool multipartIn)
	: ArticleSavingThread("Extract Binaries"),
	  newsgroup(newsgroupIn), articles(articlesIn), subjectsView(subjectsViewIn),
	  multipart(multipartIn)
{
}
]]></method>

<method access="public" mod-time="Fri, 14 Apr 2000 19:02:27 PDT"><![CDATA[
"Thread virtuals"
]]></method>

<method access="public" mod-time="Sat, 15 Apr 2000 02:33:20 PDT"><![CDATA[
void Action()
{
	if (multipart)
		ExtractMultipartBinary();
	else
		ExtractMultipleBinaries();
}
]]></method>

<method access="public" mod-time="Sat, 15 Apr 2000 02:22:29 PDT"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Tue, 18 Apr 2000 17:19:32 PDT"><![CDATA[
void ExtractMultipleBinaries()
{
	int i;
	BinaryArticleSpec* spec;
	NNTPResponse* response = NULL;

	try {

	Task task("Extracting binaries...");

	// set up the dirPath
	qstring dirPath = Prefs()->GetStringPref("binariesPath");
	if (dirPath.empty())
		throw OSException("You must specify a path for binaries in the Preferences before trying to extract binaries.");
	if (dirPath.data()[dirPath.length() - 1] != '/')
		dirPath += '/';

	// get the total number of lines
	int numArticles = articles->CountItems();
	unsigned int totalNumLines = 0;
	for (i=0; i<numArticles; ++i) {
		spec = (BinaryArticleSpec*) articles->ItemAt(i);
		totalNumLines += spec->article->Lines();
		}
	task.SetProgressMax(totalNumLines);

	// extract each file one by one
	bool undecodedBinaries = false;
	for (i=0; i<numArticles; ++i) {
		spec = (BinaryArticleSpec*) articles->ItemAt(i);
		task.SetProgressString(spec->subject->GetSubject());

		// get a connection
		ConnectionGetter connectionGetter;
		NNTPConnection* connection = connectionGetter.Connection();
		connection->SelectGroup(newsgroup->Name());
		task.GotConnection();

		// open the file
		qstring filePath = dirPath;
		char tempFileName[64];
		GetTempFileName(tempFileName);
		filePath += tempFileName;
		BFile file(filePath.c_str(), B_READ_WRITE | B_CREATE_FILE | B_ERASE_FILE);
		status_t result = file.InitCheck();
		if (result != B_NO_ERROR)
			throw OSException("Couldn't create a file to extract binaries to.", result);

		// get the article
		int articleNo = spec->article->ArticleNo();
		qstring cmd = "article ";
		cmd += articleNo;
		result = connection->SendCommand(cmd);
		if (result == B_NO_ERROR)
			result = connection->GetResponse(&response);
		if (result != 220)
			throw OSException("Couldn't get article.", result);

		// write it to the file
		result = WriteFile(&file, response, "\n", &task, true);
		if (result < B_NO_ERROR)
			throw OSException("An error occurred while extracting binaries.", result);

		// mark as read in the newsgroup
		newsgroup->ArticleRead(articleNo);
		newsgroup->ReadArticlesChanged();
		spec->article->SetRead(true);
		subjectsView->InvalidateSubject(spec->subject);

		// clean up
		delete response;
		response = NULL;
		file.Unset();	// closes the file

		// decode the file
		task.SetProgressString("Decoding binary...");
		result = chdir(dirPath.c_str());
		if (result != 0)
			throw OSException("Couldn't decode the binary [error setting dir].", result);
		qstring command = "/bin/uudecode \"";
		command += filePath;
		command += "\"";
		result = system(command.c_str());
		if (result != 0)
			undecodedBinaries = true;

		// delete the file
		BEntry fileEntry(filePath.c_str());
		fileEntry.Remove();

		task.ReleasedConnection();
		}

	// warn about undecoded binaries
	if (undecodedBinaries)
		Error::ShowError("One or more binaries couldn't be decoded and have been left in their encoded form.");
	}
	catch (DisplayableException& e) {
		delete response;
		e.Display();
		}
}
]]></method>

<method access="public" mod-time="Tue, 18 Apr 2000 17:19:04 PDT"><![CDATA[
void ExtractMultipartBinary()
{
	int i;
	BinaryArticleSpec* spec;
	NNTPResponse* response = NULL;

	try {

	Task task("Extracting binaries...");

	// open the file
	qstring dirPath = Prefs()->GetStringPref("binariesPath");
	if (dirPath.empty())
		throw OSException("You must specify a path for binaries in the Preferences before trying to extract binaries.");
	qstring filePath = dirPath;
	if (filePath.data()[filePath.length() - 1] != '/')
		filePath += '/';
	char tempFileName[64];
	GetTempFileName(tempFileName);
	filePath += tempFileName;
	BFile file(filePath.c_str(), B_READ_WRITE | B_CREATE_FILE | B_ERASE_FILE);
	status_t result = file.InitCheck();
	if (result != B_NO_ERROR)
		throw OSException("Couldn't create a file to extract binaries to.", result);

	// get the total number of lines
	int numArticles = articles->CountItems();
	unsigned int totalNumLines = 0;
	for (i=0; i<numArticles; ++i) {
		spec = (BinaryArticleSpec*) articles->ItemAt(i);
		totalNumLines += spec->article->Lines();
		}
	task.SetProgressMax(totalNumLines);

	// read all the articles into the file
	for (i=0; i<numArticles; ++i) {
		spec = (BinaryArticleSpec*) articles->ItemAt(i);
		task.SetProgressString(spec->subject->GetSubject());

		// get a connection
		ConnectionGetter connectionGetter;
		NNTPConnection* connection = connectionGetter.Connection();
		connection->SelectGroup(newsgroup->Name());
		task.GotConnection();

		// get the article
		int articleNo = spec->article->ArticleNo();
		qstring cmd = "article ";
		cmd += articleNo;
		result = connection->SendCommand(cmd);
		if (result == B_NO_ERROR)
			result = connection->GetResponse(&response);
		if (result != 220)
			throw OSException("Couldn't get article.", result);

		// append it to the file
		result = WriteFile(&file, response, "\n", &task, true);
		if (result < B_NO_ERROR)
			throw OSException("An error occurred while extracting binaries.", result);

		// mark as read in the newsgroup
		newsgroup->ArticleRead(articleNo);
		newsgroup->ReadArticlesChanged();
		spec->article->SetRead(true);
		subjectsView->InvalidateSubject(spec->subject);

		// clean up
		delete response;
		response = NULL;
		task.ReleasedConnection();
		}
	file.Unset();	// closes the file

	// decode the file
	task.SetProgressString("Decoding binary...");
	chdir(dirPath.c_str());
	qstring command = "/bin/uudecode \"";
	command += filePath;
	command += "\"";
	system(command.c_str());

	// delete the file
	BEntry fileEntry(filePath.c_str());
	fileEntry.Remove();

	}
	catch (DisplayableException& e) {
		delete response;
		e.Display();
		}
}
]]></method>

<method access="public" mod-time="Sun, 16 Apr 2000 00:43:30 PDT"><![CDATA[
void GetTempFileName(char* tempFileName)
{
	unsigned int microseconds = system_time() % 1000000;
	sprintf(tempFileName, "• %u%u.uu", (unsigned int) real_time_clock(), microseconds);
}
]]></method>

<variable access="protected" mod-time="Fri, 14 Apr 2000 19:04:33 PDT"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Fri, 14 Apr 2000 19:04:40 PDT"><![CDATA[
Newsgroup* newsgroup;
]]></variable>

<variable access="protected" mod-time="Fri, 14 Apr 2000 19:04:43 PDT"><![CDATA[
BList* articles;
]]></variable>

<variable access="protected" mod-time="Sat, 15 Apr 2000 01:08:02 PDT"><![CDATA[
SubjectsView* subjectsView;
]]></variable>

<variable access="protected" mod-time="Sat, 15 Apr 2000 02:24:58 PDT"><![CDATA[
bool multipart;
]]></variable>

</class>


<class mod-time="Fri, 14 Apr 2000 18:08:24 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
"ArticleSet"
</name>
</class>


<class mod-time="Sat, 08 Apr 2000 11:24:16 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
ArticleSet
</name>
<hIncludes><![CDATA[
#include "IntRange.h"
#include "string_slice.h"

class IntRangeTree;
class qstring;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "IntRangeTree.h"
#include "qstring.h"
#include <stdio.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ArticleSet()
{
	tree = new IntRangeTree();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~ArticleSet()
{
	delete tree;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AddArticle(int articleNo)
{
	if (tree->FindOverlappingRange(IntRange(articleNo)).IsValid())
		return;		// already there

	// get rid of adjacent ranges, and add merged range
	IntRange mergedRange(articleNo);
	IntRange leftRange = tree->RemoveOverlappingRange(IntRange(articleNo - 1));
	if (leftRange.IsValid())
		mergedRange.min = leftRange.min;
	IntRange rightRange = tree->RemoveOverlappingRange(IntRange(articleNo + 1));
	if (rightRange.IsValid())
		mergedRange.max = rightRange.max;
	tree->Insert(mergedRange);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AddRange(IntRange range)
{
	// get rid of all overlapping & adjacent ranges, merging them into "range"
	IntRange adjacentFinderRange(range.min - 1, range.max + 1);
	while (true) {
		IntRange existingRange = tree->RemoveOverlappingRange(adjacentFinderRange);
		if (!existingRange.IsValid())
			break;
		if (existingRange.min < range.min)
			range.min = existingRange.min;
		if (existingRange.max > range.max)
			range.max = existingRange.max;
		}

	// add the merged range
	tree->Insert(range);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void RemoveArticle(int articleNo)
{
	// get rid of the range containing it
	IntRange removedRange = tree->RemoveOverlappingRange(IntRange(articleNo));
	if (!removedRange.IsValid())
		return;

	// add back two new ranges
	IntRange leftRange(removedRange.min, articleNo - 1);
	if (leftRange.IsValid())
		tree->Insert(leftRange);
	IntRange rightRange(articleNo + 1, removedRange.max);
	if (rightRange.IsValid())
		tree->Insert(rightRange);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void RemoveRange(IntRange range)
{
	// get rid of all overlapping ranges, splitting them if necessary
	while (true) {
		IntRange removedRange = tree->RemoveOverlappingRange(range);
		if (!removedRange.IsValid())
			return;

		// left split
		IntRange leftRange(removedRange.min, range.min - 1);
		if (leftRange.IsValid())
			tree->Insert(leftRange);
		IntRange rightRange(range.max + 1, removedRange.max);
		if (rightRange.IsValid())
			tree->Insert(rightRange);
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool ContainsArticle(int articleNo)
{
	return tree->FindOverlappingRange(IntRange(articleNo)).IsValid();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AddArticles(string_slice str)
{
	const char* p = str.begin();
	const char* stopper = str.end();
	const char* numStart = p;
	for (; p<stopper; p++) {
		if (*p == ',') {
			AddArticle(string_slice(numStart, p).asInt());
			numStart = p + 1;
			}
		else if (*p == '-') {
			int firstArticle = string_slice(numStart, p).asInt();
			p++;	// skip hyphen
			// read the last article number
			numStart = p;
			while (p < stopper && *p != ',')
				p++;
			int lastArticle = string_slice(numStart, p).asInt();
			// add the range
			IntRange range(firstArticle, lastArticle);
			if (range.IsValid())
				AddRange(range);
			// set up for next go-round
			numStart = p + 1;
			}
		}
	// add the final article
	if (numStart < stopper)
		AddArticle(string_slice(numStart, stopper).asInt());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
qstring* AsString()
{
	char	numStr[128];

	qstring* str = new qstring;
	bool needsComma = false;
	unsigned int numRanges = tree->NumObjects();
	for (unsigned int i=0; i<numRanges; i++) {
		IntRange range = *(IntRange*) tree->ObjectAt(i);

		if (needsComma)
			*str += ',';
		needsComma = true;

		if (range.min == range.max)
			sprintf(numStr, "%d", range.min);
		else
			sprintf(numStr, "%d-%d", range.min, range.max);
		*str += numStr;
		}
	return str;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MakeEmpty()
{
	tree->DeleteAllObjects();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Incorporate(ArticleSet* otherSet)
{
	int numRanges = otherSet->NumRanges();
	for (int rangeIdx = 0; rangeIdx<numRanges; rangeIdx++)
		AddRange(otherSet->RangeAt(rangeIdx));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Access"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
unsigned int NumRanges()
{
	return tree->NumRanges();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
IntRange RangeAt(unsigned int index)
{
	return tree->RangeAt(index);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int NumArticles()
{
	int numArticles = 0;
	int numRanges = NumRanges();
	for (int i=0; i<numRanges; i++)
		numArticles += RangeAt(i).Size();
	return numArticles;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int NumArticlesIn(IntRange inRange)
{
	int numArticles = 0;
	int numRanges = NumRanges();
	for (int i=0; i<numRanges; i++) {
		IntRange range = RangeAt(i) & inRange;
		if (range.IsValid())
			numArticles += range.Size();
		}
	return numArticles;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
IntRangeTree* tree;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
IntRange
</name>
<superclasses>
public OrderedObject
</superclasses>
<hIncludes><![CDATA[
#include "OrderedObject.h"

class IntRange : public OrderedObject {
public:
	IntRange(int minIn, int maxIn)
		: min(minIn), max(maxIn) {}
	IntRange(int val)
		: min(val), max(val) {}
	IntRange()
		: min(0), max(-1) {}

	bool    	IsValid() { return (min <= max); }
	IntRange	operator&(IntRange otherRange);		// intersection
	int     	Size() { return max - min + 1; }

	// comparisons
	// NOTE:  these find OVERLAPPING ranges, not identical ones
	bool	operator<(const OrderedObject& otherRange);
	bool	operator==(const OrderedObject& otherRange);

	int	min, max;
};
]]></hIncludes>
<cppIncludes><![CDATA[

IntRange IntRange::operator&(IntRange otherRange)
{
	int newMin = (min > otherRange.min ? min : otherRange.min);
	int newMax = (max < otherRange.max ? max : otherRange.max);
	return IntRange(newMin, newMax);
}

bool IntRange::operator<(const OrderedObject& otherObj)
{
	const IntRange& otherRange = *((IntRange*) &otherObj);
	return (max < otherRange.min);
}

bool IntRange::operator==(const OrderedObject& otherObj)
{
	const IntRange& otherRange = *((IntRange*) &otherObj);
	return (max >= otherRange.min && min <= otherRange.max);
}
]]></cppIncludes>
</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
IntRangeTree
</name>
<superclasses>
public AATree
</superclasses>
<hIncludes><![CDATA[
#include "AATree.h"
#include "IntRange.h"
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
IntRangeTree()
	: AATree()
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~IntRangeTree()
{
	DeleteAllObjects();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Insert(IntRange range)
{
	InsertObject(new IntRange(range));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
IntRange RemoveOverlappingRange(IntRange range)
{
	IntRange foundRange;
	IntRange* removedRange = (IntRange*) RemoveObject(&range);
	if (removedRange) {
		foundRange = *removedRange;
		delete removedRange;
		}
	return foundRange;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
IntRange FindOverlappingRange(IntRange range)
{
	IntRange* foundRange = (IntRange*) FindObject(&range);
	if (foundRange)
		return *foundRange;
	else
		return IntRange();	// invalid range
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline unsigned int NumRanges()
{
	return NumObjects();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
IntRange RangeAt(unsigned int index)
{
	IntRange result;
	IntRange* rangeObj = (IntRange*) ObjectAt(index);
	if (rangeObj)
		result = *rangeObj;
	return result;
}
]]></method>

</class>


<class mod-time="Fri, 14 Apr 2000 18:08:16 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
"Tasks"
</name>
</class>


<class mod-time="Sat, 15 Apr 2000 09:39:18 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Task
</name>
<hIncludes><![CDATA[
#include "qstring.h"
#include "string_slice.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "TasksWind.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Sat, 15 Apr 2000 09:39:04 PDT"><![CDATA[
Task(string_slice initProgressString)
	: progressString(initProgressString), progressMax(0), progressCurrent(0),
	  hasConnection(false), progressUpdateInterval(1), unitsLeftUntilUpdate(0)
{
	TasksWind::GetTasksWind()->AddTask(this);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Task()
	: progressString("Waiting for connection..."), progressMax(0), progressCurrent(0),
	  hasConnection(false)
{
	TasksWind::GetTasksWind()->AddTask(this);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~Task()
{
	TasksWind::GetTasksWind()->RemoveTask(this);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Sat, 15 Apr 2000 09:39:18 PDT"><![CDATA[
void SetProgressMax(int newProgressMax)
{
	progressMax = newProgressMax;
	SetupProgressUpdateInterval();
	TasksWind::GetTasksWind()->Invalidate();
}
]]></method>

<method access="public" mod-time="Sat, 15 Apr 2000 09:37:32 PDT"><![CDATA[
void SetProgress(int curProgress)
{
	progressCurrent = curProgress;
	unitsLeftUntilUpdate = progressUpdateInterval;
	TasksWind::GetTasksWind()->Invalidate();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void BumpProgress(int increment = 1)
{
	progressCurrent += increment;
	TasksWind::GetTasksWind()->Invalidate();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetProgressString(string_slice newProgressString)
{
	progressString = newProgressString;
	TasksWind::GetTasksWind()->Invalidate();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetHasConnection(bool newHasConnection)
{
	hasConnection = newHasConnection;
	TasksWind::GetTasksWind()->Invalidate();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void GotConnection()
{
	SetHasConnection(true);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ReleasedConnection()
{
	SetHasConnection(false);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Access"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline int CurProgress()
{
	return progressCurrent;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int GetProgressMax()
{
	return progressMax;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
float ProgressRatio()
{
	return (progressMax > 0 ? ((float) progressCurrent) / progressMax : 0);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice ProgressString()
{
	return progressString;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool HasConnection()
{
	return hasConnection;
}
]]></method>

<method access="public" mod-time="Sat, 15 Apr 2000 09:32:28 PDT"><![CDATA[
"Update Intervals"
]]></method>

<method access="public" mod-time="Sat, 15 Apr 2000 09:38:04 PDT"><![CDATA[
bool IsReadyForUpdate()
{
	return (--unitsLeftUntilUpdate <= 0);
}
]]></method>

<method access="public" mod-time="Sat, 15 Apr 2000 09:36:05 PDT"><![CDATA[
void SetupProgressUpdateInterval()
{
	// Updating the progress involves a certain amount of overhead, which we're
	// trying to avoid because it can be significant.
	// This method doesn't need to be called directly, since SetProgressMax()
	// will call it.
	// We want to update at least once per pixel, so we update 2000 times,
	// since that's wider than any known screen.
	static const unsigned long minUpdates = 2000;

	int progressUpdateInterval = progressMax / minUpdates;
	if (progressUpdateInterval < 1)
		progressUpdateInterval = 1;
	unitsLeftUntilUpdate = 0;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
qstring progressString;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int progressMax;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int progressCurrent;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool hasConnection;
]]></variable>

<variable access="protected" mod-time="Sat, 15 Apr 2000 09:31:48 PDT"><![CDATA[
int progressUpdateInterval;
]]></variable>

<variable access="protected" mod-time="Sat, 15 Apr 2000 09:32:14 PDT"><![CDATA[
int unitsLeftUntilUpdate;
]]></variable>

</class>


<class mod-time="Sat, 08 Apr 2000 16:33:52 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
TasksWind
</name>
<superclasses>
public BWindow
</superclasses>
<hIncludes><![CDATA[
#include <Window.h>
#include <Locker.h>

class TasksView;
class Task;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "TasksView.h"
#include "Prefs.h"
#include <Screen.h>
#include <Autolock.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
TasksWind()
	: BWindow(BRect(0, 0, defaultWidth, taskHeight - 1),		// why -1?
	          "Tasks",
	          B_FLOATING_WINDOW_LOOK, B_NORMAL_WINDOW_FEEL,
	          B_NOT_CLOSABLE | B_NOT_V_RESIZABLE | B_NOT_ZOOMABLE | B_AVOID_FRONT | B_AVOID_FOCUS),
	  growsUp(true)
{
	tasks = new BList();

	// make the tasks view
	tasksView = new TasksView(BRect(0, 0, defaultWidth, defaultHeight));
	AddChild(tasksView);

	// move to bottom right corner of screen
	BRect screenRect = BScreen(this).Frame();
	windBottom = screenRect.bottom - Frame().Height() - screenMargin;
	MoveTo(screenRect.right - Frame().Width() - screenMargin, windBottom);

	// restore the saved frame
	BRect savedFrame = Prefs()->GetRectPref("tasksWind.frame");
	if (savedFrame.IsValid() && screenRect.Contains(savedFrame)) {
		MoveTo(savedFrame.LeftTop());
		ResizeTo(savedFrame.Width(), Frame().Height());
		}

	Show();		// must do this to start the message loop
	Hide();		// until something happens
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~TasksWind()
{
	Prefs()->SetRectPref("tasksWind.frame", Frame());
	tasksWind = NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Invalidate()
{
	Lock();
	tasksView->Invalidate();
	Unlock();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AddTask(Task* task)
{
	tasks->AddItem(task);

	// adjust window
	if (IsHidden())
		Show();
	else {
		// resize
		float newHeight = tasks->CountItems() * taskHeight - 1;	// why -1?
		ResizeTo(Frame().Width(), newHeight);
		if (growsUp)
			MoveTo(Frame().left, windBottom - newHeight);
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void RemoveTask(Task* task)
{
	tasks->RemoveItem(task);

	// adjust window
	if (tasks->CountItems() == 0)
		Hide();
	else {
		// resize
		float newHeight = tasks->CountItems() * taskHeight - 1;	// why -1?
		ResizeTo(Frame().Width(), newHeight);
		if (growsUp)
			MoveTo(Frame().left, windBottom - newHeight);
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"BWindow virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void FrameMoved(BPoint screenPoint)
{
	windBottom = Frame().bottom;
	BRect screenRect = BScreen(this).Frame();
	growsUp = (windBottom > (screenRect.top + screenRect.bottom) / 2);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Static"
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 16:33:23 PDT"><![CDATA[
static TasksWind* GetTasksWind()
{
	BAutolock locker(tasksWindCreationGuard);
	if (tasksWind == NULL)
		tasksWind = new TasksWind();
	return tasksWind;
}
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 16:28:00 PDT"><![CDATA[
static bool HaveTasksWind()
{
	return (tasksWind != NULL);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"For TasksView"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int NumTasks()
{
	return tasks->CountItems();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Task* TaskAt(int index)
{
	return (Task*) tasks->ItemAt(index);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BList* tasks;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
TasksView* tasksView;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
float windBottom;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool growsUp;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Static variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static TasksWind* tasksWind = NULL;
]]></variable>

<variable access="protected" mod-time="Sat, 08 Apr 2000 16:31:51 PDT"><![CDATA[
static BLocker tasksWindCreationGuard;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float defaultWidth = 300;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float defaultHeight = 60;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float screenMargin = 6;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Public Tweex"
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float taskHeight = 12;
]]></variable>

</class>


<class mod-time="Sat, 08 Apr 2000 16:44:29 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
TasksView
</name>
<superclasses>
public BView
</superclasses>
<hIncludes><![CDATA[
#include <View.h>

class Task;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Task.h"
#include "TasksWind.h"
#include "string_slice.h"
#include <Region.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
TasksView(BRect frame)
	: BView(frame, "Tasks", B_FOLLOW_ALL_SIDES,
	        B_WILL_DRAW | B_FULL_UPDATE_ON_RESIZE)
{
	SetViewColor(B_TRANSPARENT_32_BIT);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"BView virtuals"
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 16:44:29 PDT"><![CDATA[
void Draw(BRect updateRect)
{
	TasksWind* wind = (TasksWind*) Window();
		// I was using TasksWind::GetTaskWind() for this, but that
		// caused a deadlock once the creation guard was added to
		// prevent the race condition

	// set up initial taskRect
	BRect taskRect = Bounds();
	taskRect.bottom = taskRect.top + TasksWind::taskHeight - 1;

	// draw the connections
	int numTasks = wind->NumTasks();
	for (int i=0; i<numTasks; i++) {
		Task* task = wind->TaskAt(i);
		if (task == NULL)
			continue;

		if (task->GetProgressMax() == 0 && task->CurProgress() != 0)
			DrawIndeterminiteTask(task, taskRect);
		else
			DrawFiniteTask(task, taskRect);

		// bump the connectionRect
		taskRect.OffsetBy(0, TasksWind::taskHeight);
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DrawFiniteTask(Task* task, BRect taskRect)
{
	// set up to draw
	float progressRatio = task->ProgressRatio();
	string_slice progressString = task->ProgressString();
	font_height fontInfo;
	be_plain_font->GetHeight(&fontInfo);
	BPoint stringStart(taskRect.left + stringLeft,
	                   taskRect.bottom - fontInfo.descent);
	BRegion clipRegion;

	// draw the first half of the progress
	BRect progressRect = taskRect;
	progressRect.right = progressRect.left + ceil(progressRatio * progressRect.Width());
	if (progressRect.IsValid()) {
		PushState();
		clipRegion.Set(progressRect);
		ConstrainClippingRegion(&clipRegion);
		SetHighColor(task->HasConnection() ? stringColor : unconnectedStringColor);
		SetLowColor(progressColor);
		FillRect(progressRect, B_SOLID_LOW);
		if (progressString.length() > 0)
			DrawString(progressString.begin(), progressString.length(), stringStart);
		PopState();
		}

	// draw the second half of the progress
	progressRect.left = progressRect.right + 1;
	progressRect.right = taskRect.right;
	if (progressRect.IsValid()) {
		PushState();
		clipRegion.Set(progressRect);
		ConstrainClippingRegion(&clipRegion);
		SetHighColor(task->HasConnection() ? stringColor : unconnectedStringColor);
		SetLowColor(bgndColor);
		FillRect(progressRect, B_SOLID_LOW);
		if (progressString.length() > 0)
			DrawString(progressString.begin(), progressString.length(), stringStart);
		PopState();
		}
}
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 11:25:48 PDT"><![CDATA[
void DrawIndeterminiteTask(Task* task, BRect taskRect)
{
	// set up to draw
	string_slice progressString = task->ProgressString();
	font_height fontInfo;
	be_plain_font->GetHeight(&fontInfo);
	BPoint stringStart(taskRect.left + stringLeft,
	                   taskRect.bottom - fontInfo.descent);
	BRegion clipRegion;

	// draw the slice
	// calc the slice
	int sliceMax = (int) (taskRect.Width() / sliceWidth);
	int curSlice = task->CurProgress() % (sliceMax * 2);
	if (curSlice > sliceMax)
		curSlice = sliceMax * 2 - curSlice;
	BRect sliceRect = taskRect;
	sliceRect.left += curSlice * sliceWidth;
	sliceRect.right = sliceRect.left + sliceWidth;
	// draw
	PushState();
	clipRegion.Set(sliceRect);
	ConstrainClippingRegion(&clipRegion);
	SetHighColor(task->HasConnection() ? stringColor : unconnectedStringColor);
	SetLowColor(progressColor);
	FillRect(sliceRect, B_SOLID_LOW);
	if (progressString.length() > 0)
		DrawString(progressString.begin(), progressString.length(), stringStart);
	PopState();

	// draw the rest of the progress
	// calc the clipping region
	clipRegion.MakeEmpty();
	BRect nonSliceRect = taskRect;
	nonSliceRect.right = sliceRect.left - 1;
	if (nonSliceRect.IsValid())
		clipRegion.Include(nonSliceRect);
	nonSliceRect = taskRect;
	nonSliceRect.left = sliceRect.right + 1;
	if (nonSliceRect.IsValid())
		clipRegion.Include(nonSliceRect);
	// draw
	PushState();
	ConstrainClippingRegion(&clipRegion);
	SetHighColor(task->HasConnection() ? stringColor : unconnectedStringColor);
	SetLowColor(bgndColor);
	FillRect(taskRect, B_SOLID_LOW);
	if (progressString.length() > 0)
		DrawString(progressString.begin(), progressString.length(), stringStart);
	PopState();
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const rgb_color progressColor = { 192, 192, 192, 255 };
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const rgb_color stringColor = { 0, 0, 0, 255 };
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const rgb_color unconnectedStringColor = { 226, 190, 74, 255 };
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const rgb_color bgndColor = { 255, 255, 255, 255 };
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float stringLeft = 6;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float sliceWidth = 10;
]]></variable>

</class>


<class mod-time="Fri, 14 Apr 2000 18:08:09 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
"Dialogs"
</name>
</class>


<class mod-time="Sat, 08 Apr 2000 11:28:33 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
ServerDlog
</name>
<superclasses>
public BWindow
</superclasses>
<hIncludes><![CDATA[
#include <Window.h>
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Prefs.h"
#include <TextControl.h>
#include <Button.h>
#include <Message.h>
#include <StringView.h>
#include <Screen.h>
#include <Beep.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 11:26:44 PDT"><![CDATA[
ServerDlog()
	: BWindow(BRect(0, 0, WindWidth, WindHeight), "Server Dlog", B_MODAL_WINDOW, B_NOT_RESIZABLE),
	  doneSem(-1), wasDone(false)
{
	// set up for synchronous operation
	doneSem = create_sem(0, "ServerDlog synchronous");

	// set up background color
	BView* bgndView = new BView(Frame(), "", B_FOLLOW_ALL, B_WILL_DRAW | B_PULSE_NEEDED);
	bgndView->SetViewColor(BgndColor);
	AddChild(bgndView);

	// make the views
	// label
	BRect labelFrame(Margin, Margin, WindWidth - 2*Margin, Margin + LabelHeight);
	bgndView->AddChild(new BStringView(labelFrame, "", "Enter the address of your news server:"));
	// serverControl
	BRect serverControlFrame(0, 0, WindWidth, 100);
	serverControlFrame.InsetBy(Margin + ServerControlInset, 0);
	serverControl =
		new BTextControl(serverControlFrame, "", "Server address:", "", NULL,
		                 B_FOLLOW_LEFT | B_FOLLOW_TOP,
		                 B_WILL_DRAW | B_NAVIGABLE | B_PULSE_NEEDED);
	bgndView->AddChild(serverControl);
	float width, height;
	serverControl->GetPreferredSize(&width, &height);
	float vSpacing =
		floor((WindHeight - 2*Margin - LabelHeight - ButtonHeight - height) / 2);
	serverControl->MoveTo(serverControlFrame.left, Margin + LabelHeight + vSpacing);
	serverControl->MakeFocus();
	// ok button
	BRect okButtonFrame(WindWidth - Margin - ButtonWidth,
	                    WindHeight - Margin - ButtonHeight,
	                    WindWidth - Margin,
	                    WindHeight - Margin);
	BButton* okButton =
		new BButton(okButtonFrame, "", "OK", new BMessage(B_QUIT_REQUESTED));
	bgndView->AddChild(okButton);
	okButton->MakeDefault(true);
	// cancel button
	BRect cancelButtonFrame = okButtonFrame;
	cancelButtonFrame.OffsetBy(-(ButtonWidth + ButtonSpacing), 0);
	bgndView->AddChild(new BButton(cancelButtonFrame, "", "Cancel", new BMessage(B_CANCEL)));

	// center on the screen
	BRect screenRect = BScreen(this).Frame();
	MoveTo((screenRect.left + screenRect.right - WindWidth) / 2,
	       (screenRect.top + screenRect.bottom - WindHeight) / 2);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~ServerDlog()
{
	delete_sem(doneSem);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"BWindow virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MessageReceived(BMessage* message)
{
	switch (message->what) {
		case B_CANCEL:
			Close();
			break;

		case B_KEY_DOWN:
			int8 key;
			message->FindInt8("byte", 0, &key);
			if (key == B_ESCAPE)
				Close();
			break;

		default:
			BWindow::MessageReceived(message);
			break;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DispatchMessage(BMessage* message, BHandler* handler)
{
	bool passMessage = true;
	switch (message->what) {
		case B_KEY_DOWN:
			// intercept ESC key
			int8 key;
			message->FindInt8("byte", 0, &key);
			if (key == B_ESCAPE) {
				Close();
				passMessage = false;
				}
			break;
		}

	if (passMessage)
		BWindow::DispatchMessage(message, handler);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool QuitRequested()
{
	// verify
	const char* server = serverControl->Text();
	if (server[0] == 0) {
		beep();
		return false;
		}

	// set the pref
	Prefs()->SetStringPref("nntpServer", server);
	wasDone = true;
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool Go()
{
	Show();
	acquire_sem(doneSem);
	bool retVal = wasDone;
	Close();
	return retVal;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BTextControl* serverControl;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
sem_id doneSem;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool wasDone;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float WindWidth = 300;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float WindHeight = 120;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float ButtonWidth = 80;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float ButtonHeight = 20;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float ButtonSpacing = 20;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float Margin = 12;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float LabelHeight = 14;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float ServerControlInset = 20;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const rgb_color BgndColor = { 220, 220, 220, 255 };
]]></variable>

</class>


<class mod-time="Sat, 08 Apr 2000 11:29:36 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
AddGroupDlog
</name>
<superclasses>
public BWindow
</superclasses>
<hIncludes><![CDATA[
#include <Window.h>
#include <Messenger.h>
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Messages.h"
#include <View.h>
#include <TextControl.h>
#include <Button.h>
#include <Screen.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
AddGroupDlog(const char* title, const BMessenger& targetIn)
	: BWindow(BRect(0, 0, defaultWindWidth, windHeight), title, B_TITLED_WINDOW,
	          B_NOT_V_RESIZABLE | B_NOT_ZOOMABLE),
	  target(targetIn)
{
	// set up background color
	BView* bgndView = new BView(Frame(), "", B_FOLLOW_ALL, B_WILL_DRAW | B_PULSE_NEEDED);
	bgndView->SetViewColor(bgndColor);
	AddChild(bgndView);

	// group view
	BRect groupViewFrame(margin, margin, defaultWindWidth - margin, margin);
	groupView = new BTextControl(groupViewFrame, "", "Newsgroup:", NULL, NULL,
	                             B_FOLLOW_LEFT_RIGHT | B_FOLLOW_TOP);
	groupView->SetDivider(groupViewDivider);
	bgndView->AddChild(groupView);

	// add button
	const float addButtonRight = defaultWindWidth - margin;
	const float buttonTop = windHeight - margin - buttonHeight;
	BRect buttonFrame(addButtonRight - buttonWidth, buttonTop,
	                  addButtonRight, buttonTop + buttonHeight);
	addButton = new BButton(buttonFrame, "", "Add",
	                        new BMessage(AcceptedMessage),
	                        B_FOLLOW_RIGHT | B_FOLLOW_BOTTOM);
	bgndView->AddChild(addButton);
	SetDefaultButton(addButton);

	// cancel button
	buttonFrame.OffsetBy(-(buttonWidth + buttonHSpacing), 0);
	BButton* cancelButton = new BButton(buttonFrame, "", "Cancel",
	                                    new BMessage(B_QUIT_REQUESTED),
	                                    B_FOLLOW_RIGHT | B_FOLLOW_BOTTOM);
	bgndView->AddChild(cancelButton);

	// center on the screen
	BRect screenRect = BScreen(this).Frame();
	MoveTo((screenRect.left + screenRect.right - defaultWindWidth) / 2,
	       (screenRect.top + screenRect.bottom - windHeight) / 2);

	groupView->MakeFocus();
	Show();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"BWindow virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DispatchMessage(BMessage* message, BHandler* handler)
{
	switch (message->what) {
		case B_KEY_DOWN:
			// intercept ESC key to close the window
			int8 key;
			message->FindInt8("byte", &key);
			if (key == B_ESCAPE)
				PostMessage(B_QUIT_REQUESTED);
			else if (key == ' ' && CurrentFocus() == groupView->TextView()) {
				// disallow spaces in the groupView
				}
			else
				BWindow::DispatchMessage(message, handler);
			break;

		default:
			BWindow::DispatchMessage(message, handler);
			break;
		}

	// update the addButton's enabledness
	addButton->SetEnabled(groupView->Text()[0] != 0);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MessageReceived(BMessage* message)
{
	switch (message->what) {
		case AcceptedMessage:
			{
			BMessage addGroupMessage(AddGroupMessage);
			addGroupMessage.AddString("groupName", groupView->Text());
			target.SendMessage(&addGroupMessage);
			Quit();
			}
			break;

		default:
			BWindow::MessageReceived(message);
			break;
		}
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BMessenger target;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BTextControl* groupView;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BButton* addButton;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const rgb_color bgndColor = { 220, 220, 220, 255 };
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float margin = 10;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float groupViewDivider = 60;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float buttonWidth = 80;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float buttonHeight = 20;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float buttonHSpacing = 16;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float windHeight = 80;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float defaultWindWidth = 300;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private Messages"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int32 AcceptedMessage = 'Acpt';
]]></variable>

</class>


<class mod-time="Fri, 21 Apr 2000 01:57:44 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
PrefsDlog
</name>
<superclasses>
public BWindow
</superclasses>
<hIncludes><![CDATA[
#include <Window.h>

class ColorPrefControl;
class FontPrefControl;
class BCheckBox;
class BMessage;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "ColorPrefControl.h"
#include "FontPrefControl.h"
#include "NNTPApp.h"
#include "ConnectionPool.h"
#include "Prefs.h"
#include "ListColors.h"
#include "Messages.h"
#include "qstring.h"
#include <Button.h>
#include <TabView.h>
#include <TextControl.h>
#include <CheckBox.h>
#include <Box.h>
#include <Message.h>
#include <Screen.h>
#include <Beep.h>

// tab indexes
enum {
	serverTabIndex
};
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Fri, 21 Apr 2000 01:46:44 PDT"><![CDATA[
PrefsDlog()
	: BWindow(BRect(0, 0, windWidth, windHeight), "Preferences", B_TITLED_WINDOW,
	          B_NOT_RESIZABLE | B_NOT_ZOOMABLE)
{
	// create the bgndView
	BView* bgndView = new BView(Bounds(), "Background", B_FOLLOW_ALL, B_WILL_DRAW);
	bgndView->SetViewColor(bgndColor);
	AddChild(bgndView);

	// create the "OK" button
	BRect okButtonFrame(windWidth - buttonMargin - buttonWidth,
	                    windHeight - buttonMargin - buttonHeight,
	                    windWidth - buttonMargin,
	                    windHeight - buttonMargin);
	BButton* okButton =
		new BButton(okButtonFrame, "", "OK", new BMessage(B_QUIT_REQUESTED));
	bgndView->AddChild(okButton);
	okButton->MakeDefault(true);

	// cancel button
	BRect cancelButtonFrame = okButtonFrame;
	cancelButtonFrame.OffsetBy(-(buttonWidth + buttonSpacing), 0);
	bgndView->AddChild(new BButton(cancelButtonFrame, "", "Cancel", new BMessage(B_CANCEL)));

	// create the tabView
	BRect tabViewRect = Bounds();
	tabViewRect.InsetBy(tabInset, tabInset);
	tabViewRect.bottom = cancelButtonFrame.top - buttonMargin;
	tabView = new BTabView(tabViewRect, "tabView");
	tabView->SetViewColor(bgndColor);
	bgndView->AddChild(tabView);

	// set up some handy rects 'n' stuff
	BRect panelRect = tabView->Bounds();
	panelRect.InsetBy(tabInset, tabInset);
	BRect itemRect = panelRect;
	itemRect.OffsetTo(0, 0);
	itemRect.InsetBy(tabMargin, tabMargin);
	Preferences* prefs = Prefs();

	// create the "Server" panel
	BView* serverView = new BView(panelRect, "Server", B_FOLLOW_ALL, B_WILL_DRAW);
	serverView->SetViewColor(bgndColor);
	// serverControl
	serverControl =
		new BTextControl(itemRect, "", "Server address:", "", NULL,
		                 B_FOLLOW_LEFT | B_FOLLOW_TOP,
		                 B_WILL_DRAW | B_NAVIGABLE | B_PULSE_NEEDED);
	serverControl->SetText(prefs->GetStringPref("nntpServer"));
	serverControl->ResizeToPreferred();
	serverView->AddChild(serverControl);
	// maxConnectionsControl
	maxConnectionsControl =
		new BTextControl(itemRect, "", "Maximum connections:", "", NULL,
		                 B_FOLLOW_LEFT | B_FOLLOW_TOP,
		                 B_WILL_DRAW | B_NAVIGABLE | B_PULSE_NEEDED);
	int maxConnections = prefs->GetInt32Pref("maxConnections", ConnectionPool::defaultMaxConnections);
	maxConnectionsControl->SetText(qstring(maxConnections).c_str());
	maxConnectionsControl->ResizeToPreferred();
	maxConnectionsControl->ResizeTo(maxConnectionsControl->Divider() + numberFieldWidth,
	                                maxConnectionsControl->Frame().Height());
	serverView->AddChild(maxConnectionsControl);
	// userNameControl
	userNameControl =
		new BTextControl(itemRect, "", "User name:", "", NULL,
		                 B_FOLLOW_LEFT | B_FOLLOW_TOP,
		                 B_WILL_DRAW | B_NAVIGABLE | B_PULSE_NEEDED);
	userNameControl->SetText(prefs->GetStringPref("userName"));
	userNameControl->ResizeToPreferred();
	serverView->AddChild(userNameControl);
	// passwordControl
	passwordControl =
		new BTextControl(itemRect, "", "Password:", "", NULL,
		                 B_FOLLOW_LEFT | B_FOLLOW_TOP,
		                 B_WILL_DRAW | B_NAVIGABLE | B_PULSE_NEEDED);
	passwordControl->SetText(prefs->GetStringPref("password"));
	passwordControl->ResizeToPreferred();
	serverView->AddChild(passwordControl);
	// set up
	LayoutItemsIn(serverView);
	tabView->AddTab(serverView);

	// "Appearance" panel
	BView* appearanceView = new BView(panelRect, "Appearance", B_FOLLOW_ALL, B_WILL_DRAW);
	appearanceView->SetViewColor(bgndColor);
	// list colors
	BBox* listColorsBox = new BBox(itemRect);
	listColorsBox->SetLabel("Colors");
	appearanceView->AddChild(listColorsBox);
		// selected
	listSelectedColorControl =
		new ColorPrefControl(itemRect, "listSelectedBgndColor", "Selected:", ListColors::selectedBgndColor);
	listSelectedColorControl->SetViewColor(bgndColor);
	listSelectedColorControl->ResizeToPreferred();
	listColorsBox->AddChild(listSelectedColorControl);
		// hilited
	listHilitedColorControl =
		new ColorPrefControl(itemRect, "listHilitedBgndColor", "Hilited:", ListColors::hilitedBgndColor);
	listHilitedColorControl->SetViewColor(bgndColor);
	listHilitedColorControl->ResizeToPreferred();
	listColorsBox->AddChild(listHilitedColorControl);
		// bgnd
	listBgndColorControl =
		new ColorPrefControl(itemRect, "listBgndColor", "Background:", ListColors::bgndColor);
	listBgndColorControl->SetViewColor(bgndColor);
	listBgndColorControl->ResizeToPreferred();
	listColorsBox->AddChild(listBgndColorControl);
		// selected
	listTextColorControl =
		new ColorPrefControl(itemRect, "listTextColor", "Text:", ListColors::textColor);
	listTextColorControl->SetViewColor(bgndColor);
	listTextColorControl->ResizeToPreferred();
	listColorsBox->AddChild(listTextColorControl);
	// set up the listColorsBox
	DistributeItemsAcross(listColorsBox, boxChildTop);
	ResizeBox(listColorsBox);
	// listFontControl
	listFontControl = new FontPrefControl("listFont", "Font:", itemRect,
	                                      B_FOLLOW_LEFT | B_FOLLOW_TOP);
	listFontControl->SetViewColor(bgndColor);
	listFontControl->ResizeToPreferred();
	appearanceView->AddChild(listFontControl);
	// extraFontControl
	extraInfoFontControl =
		new FontPrefControl("extraInfoFont", "Extra info font:", itemRect,
		                    B_FOLLOW_LEFT | B_FOLLOW_TOP);
	extraInfoFontControl->SetViewColor(bgndColor);
	extraInfoFontControl->ResizeToPreferred();
	appearanceView->AddChild(extraInfoFontControl);
	// expandSubjectsControl
	expandSubjectsControl =
		MakeCheckbox("expandSubjectsByDefault", "Expand subjects by default", itemRect);
	appearanceView->AddChild(expandSubjectsControl);
	// showDatesControl
	showDatesControl = MakeCheckbox("showDates", "Show dates", itemRect);
	appearanceView->AddChild(showDatesControl);
	// showLinesControl
	showLinesControl = MakeCheckbox("showLines", "Show lines", itemRect);
	appearanceView->AddChild(showLinesControl);
	// set up
	LayoutItemsIn(appearanceView);
	tabView->AddTab(appearanceView);

	// create the "Binaries" panel
	BView* binariesView = new BView(panelRect, "Binaries", B_FOLLOW_ALL, B_WILL_DRAW);
	binariesView->SetViewColor(bgndColor);
	// binariesPathControl
	binariesPathControl =
		new BTextControl(itemRect, "", "Save binaries in:", "", NULL,
		                 B_FOLLOW_LEFT | B_FOLLOW_TOP,
		                 B_WILL_DRAW | B_NAVIGABLE | B_PULSE_NEEDED);
	binariesPathControl->SetText(prefs->GetStringPref("binariesPath"));
	ResizeToPreferredHeight(binariesPathControl);
	binariesView->AddChild(binariesPathControl);
	// set up
	LayoutItemsIn(binariesView);
	tabView->AddTab(binariesView);

	// position the window
	BRect screenRect = BScreen(this).Frame();
	BRect savedFrame = Prefs()->GetRectPref("prefsDlogFrame");
	if (!savedFrame.IsValid() || !screenRect.Contains(savedFrame)) {
		// either not saved or off the screen; center on the screen
		MoveTo((screenRect.left + screenRect.right - windWidth) / 2,
		       (screenRect.top + screenRect.bottom - windHeight) / 2);
		}
	else {
		// move to saved position
		MoveTo(savedFrame.LeftTop());
		}

	tabView->MakeFocus();
	tabView->Select(0);
	Show();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~PrefsDlog()
{
	((NNTPApp*) be_app)->WindowClosing(this);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"BWindow virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void FrameMoved(BPoint screenPoint)
{
	Prefs()->SetRectPref("prefsDlogFrame", Frame());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DispatchMessage(BMessage* message, BHandler* handler)
{
	bool passMessage = true;
	switch (message->what) {
		case B_KEY_DOWN:
			int8 key;
			message->FindInt8("byte", &key);
			BView* focusView = CurrentFocus();
			// intercept ESC key to close the window
			if (key == B_ESCAPE) {
				Close();
				passMessage = false;
				}
			// always allow return, tab, backspace, delete
			else if (key == B_ENTER || key == '\t' || key == B_BACKSPACE || key == B_DELETE)
				passMessage = true;
			// always allow command keys
			else if ((message->FindInt32("modifiers") & B_COMMAND_KEY) != 0)
				passMessage = true;
			// some items don't allow spaces
			else if (focusView == serverControl->TextView()) {
				passMessage = (key != ' ');
				}
			// some items only take positive numbers
			else if (focusView == maxConnectionsControl->TextView()) {
				passMessage = (key >= '0' && key <= '9');
				}
			break;
		}

	if (passMessage)
		BWindow::DispatchMessage(message, handler);
}
]]></method>

<method access="public" mod-time="Fri, 21 Apr 2000 01:16:21 PDT"><![CDATA[
void MessageReceived(BMessage* message)
{
	switch (message->what) {
		case B_CANCEL:
			Close();
			break;

		case PrefsCheckboxClicked:
			CheckboxClicked(message);
			break;

		default:
			BWindow::MessageReceived(message);
			break;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool QuitRequested()
{
	// verify
	bool ok = true;
	// server tab
	if (serverControl->Text()[0] == 0) {
		tabView->Select(serverTabIndex);
		serverControl->MakeFocus();
		ok = false;
		}
	if (string_slice(maxConnectionsControl->Text()).asInt() < 1) {
		tabView->Select(serverTabIndex);
		maxConnectionsControl->MakeFocus();
		ok = false;
		}
	// kick out if not ok
	if (!ok) {
		beep();
		return false;
		}

	// save
	Save();

	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Fri, 21 Apr 2000 01:16:47 PDT"><![CDATA[
BCheckBox* MakeCheckbox(const char* prefName, const char* label, BRect itemRect)
{
	BMessage* message = new BMessage(PrefsCheckboxClicked);
	BCheckBox* checkbox = new BCheckBox(itemRect, "", label, message);
	int32 checkboxValue =
		(Prefs()->GetBoolPref(prefName) ? B_CONTROL_ON : B_CONTROL_OFF);
	checkbox->SetValue(checkboxValue);
	checkbox->ResizeToPreferred();
	return checkbox;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void LayoutItemsIn(BView* parentView)
{
	float y = tabMargin;
	int numChildren = parentView->CountChildren();
	for (int i=0; i<numChildren; i++) {
		BView* childView = parentView->ChildAt(i);
		childView->MoveTo(tabMargin, y);
		y += childView->Bounds().Height() + itemVSpacing;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DistributeItemsAcross(BView* parentView, float top)
{
	int i;
	BView* childView;

	// first find the total width
	float totalWidth = 0;
	int numChildren = parentView->CountChildren();
	for (i=0; i<numChildren; i++) {
		childView = parentView->ChildAt(i);
		totalWidth += childView->Frame().Width() + 1;
		}

	// distribute
	float parentWidth = (parentView->Frame().Width() + 1) - 2 * tabMargin;
	float spacing = (parentWidth - totalWidth) / (numChildren - 1);
	float x = tabMargin;
	for (i=0; i<numChildren; i++) {
		childView = parentView->ChildAt(i);
		childView->MoveTo(x, top);
		x += childView->Bounds().Width() + 1 + spacing;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ResizeBox(BView* view)
{
	int numChildren = view->CountChildren();
	float newHeight =
		(numChildren > 0 ?
		 view->ChildAt(numChildren - 1)->Frame().bottom + tabMargin :
		 view->Frame().bottom);
	view->ResizeTo(view->Frame().Width(), newHeight);
}
]]></method>

<method access="public" mod-time="Fri, 21 Apr 2000 01:57:44 PDT"><![CDATA[
void ResizeToPreferredHeight(BTextControl* control)
{
	float origWidth = control->Bounds().Width();
	control->ResizeToPreferred();
	float correctDivider = control->Divider();
	control->ResizeTo(origWidth, control->Bounds().Height());
	control->SetDivider(correctDivider);
	// setting the divider doesn't resize the textView, so we have to do that ourself
	BTextView* textView = control->TextView();
	textView->ResizeTo(origWidth - correctDivider, textView->Bounds().Height());
}
]]></method>

<method access="public" mod-time="Fri, 21 Apr 2000 01:46:36 PDT"><![CDATA[
void Save()
{
	Preferences* prefs = Prefs();

	// server prefs
	prefs->SetStringPref("nntpServer", serverControl->Text());
	prefs->SetInt32Pref("maxConnections",
	                    string_slice(maxConnectionsControl->Text()).asInt());
	prefs->SetStringPref("userName", userNameControl->Text());
	prefs->SetStringPref("password", passwordControl->Text());

	// color prefs
	listSelectedColorControl->Save();
	listHilitedColorControl->Save();
	listBgndColorControl->Save();
	listTextColorControl->Save();
	// other appearance prefs
	listFontControl->Save();
	extraInfoFontControl->Save();
	SaveCheckbox(expandSubjectsControl, "expandSubjectsByDefault");
	SaveCheckbox(showDatesControl, "showDates");
	SaveCheckbox(showLinesControl, "showLines");

	// binaries prefs
	prefs->SetStringPref("binariesPath", binariesPathControl->Text());

	prefs->Save();
}
]]></method>

<method access="public" mod-time="Fri, 21 Apr 2000 01:02:04 PDT"><![CDATA[
void SaveCheckbox(BCheckBox* checkbox, const char* prefName)
{
	Prefs()->SetBoolPref(prefName, (checkbox->Value() == B_CONTROL_ON));
}
]]></method>

<method access="public" mod-time="Fri, 21 Apr 2000 01:57:11 PDT"><![CDATA[
void CheckboxClicked(BMessage* message)
{
	BCheckBox* checkbox;
	status_t result = message->FindPointer("source", (void**) &checkbox);
	if (result != B_NO_ERROR)
		return;

	if (checkbox == showDatesControl)
		SaveCheckbox(checkbox, "showDates");
	else if (checkbox == showLinesControl)
		SaveCheckbox(checkbox, "showLines");
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BTabView* tabView;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"  Server controls"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BTextControl* serverControl;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BTextControl* maxConnectionsControl;
]]></variable>

<variable access="protected" mod-time="Thu, 20 Apr 2000 23:07:56 PDT"><![CDATA[
BTextControl* userNameControl;
]]></variable>

<variable access="protected" mod-time="Thu, 20 Apr 2000 23:08:03 PDT"><![CDATA[
BTextControl* passwordControl;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"  Color controls"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ColorPrefControl* listSelectedColorControl;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ColorPrefControl* listHilitedColorControl;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ColorPrefControl* listBgndColorControl;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ColorPrefControl* listTextColorControl;
]]></variable>

<variable access="protected" mod-time="Thu, 20 Apr 2000 23:30:11 PDT"><![CDATA[
"  Other Appearance controls"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
FontPrefControl* listFontControl;
]]></variable>

<variable access="protected" mod-time="Fri, 21 Apr 2000 01:43:39 PDT"><![CDATA[
FontPrefControl* extraInfoFontControl;
]]></variable>

<variable access="protected" mod-time="Thu, 20 Apr 2000 23:31:13 PDT"><![CDATA[
BCheckBox* expandSubjectsControl;
]]></variable>

<variable access="protected" mod-time="Fri, 21 Apr 2000 00:53:24 PDT"><![CDATA[
BCheckBox* showDatesControl;
]]></variable>

<variable access="protected" mod-time="Fri, 21 Apr 2000 00:53:31 PDT"><![CDATA[
BCheckBox* showLinesControl;
]]></variable>

<variable access="protected" mod-time="Fri, 14 Apr 2000 17:54:53 PDT"><![CDATA[
"  Binaries controls"
]]></variable>

<variable access="protected" mod-time="Fri, 14 Apr 2000 17:55:17 PDT"><![CDATA[
BTextControl* binariesPathControl;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Fri, 14 Apr 2000 18:00:11 PDT"><![CDATA[
static const float windWidth = 440;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float windHeight = 300;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float tabInset = 5;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float tabMargin = 8;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float boxChildTop = 14;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float itemVSpacing = 10;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float buttonWidth = 80;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float buttonHeight = 20;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float buttonSpacing = 20;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float buttonMargin = 12;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float numberFieldWidth = 40;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const rgb_color bgndColor = { 216, 216, 216, 255 };
]]></variable>

</class>


<class mod-time="Sat, 08 Apr 2000 16:04:45 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
ColorPrefControl
</name>
<superclasses>
public BView, public PrefsChangeClient
</superclasses>
<hIncludes><![CDATA[
#include <View.h>
#include "PrefsChangeClient.h"

class ColorPrefWind;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Prefs.h"
#include "ColorPrefWind.h"
#include <Region.h>
#include <Message.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 15:50:30 PDT"><![CDATA[
ColorPrefControl(BRect frame, const char* prefNameIn, const char* labelIn,
                 rgb_color defaultColor)
	: BView(frame, prefNameIn, B_FOLLOW_LEFT_RIGHT | B_FOLLOW_TOP,
	        B_WILL_DRAW | B_FULL_UPDATE_ON_RESIZE),
	  prefName(prefNameIn), label(labelIn), wind(NULL)
{
	savedColor = Prefs()->GetColorPref(prefName, defaultColor);
}
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 16:04:45 PDT"><![CDATA[
~ColorPrefControl()
{
	if (wind)
		wind->Close();

	// revert to the saved color
	Prefs()->SetColorPref(prefName, savedColor);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Save()
{
	savedColor = Prefs()->GetColorPref(prefName, savedColor);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void WindowClosing(BWindow* closingWind)
{
	if (closingWind == wind)
		wind = NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"BView virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Draw(BRect updateRect)
{
	SetLowColor(ViewColor());
	BRect bounds = Bounds();

	// draw the label
	SetHighColor(textColor);
	font_height fontInfo;
	GetFontHeight(&fontInfo);
	BPoint labelStart(0, floor((bounds.top + bounds.bottom + fontInfo.ascent) / 2));
	DrawString(label, labelStart);

	// draw the box
	BRect box;
	BRegion frameRgn;
	CalcBox(&box, &frameRgn);
	// frame
	SetHighColor(boxFrameColor);
/***
	BRect frameRect = box;
	frameRect.InsetBy(-boxFrameSize, -boxFrameSize);
	frameRgn.Set(frameRect);
	frameRgn.Exclude(box);
***/
	FillRegion(&frameRgn);
/***
	SetPenSize(boxFrameSize);
	SetHighColor(boxFrameColor);
	StrokeRect(boxFrame);
***/
	// box
	SetHighColor(Prefs()->GetColorPref(prefName, savedColor));
	FillRect(box);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void GetPreferredSize(float* width, float* height)
{
	*width = StringWidth(label) + divider + boxSize + 2 * boxFrameSize;
	*height = boxSize + boxFrameSize * 2;
}
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 11:34:35 PDT"><![CDATA[
void MessageReceived(BMessage* message)
{
	switch (message->what) {
		case B_PASTE:
			{
			const rgb_color* color;
			ssize_t numBytes = sizeof(color);
			status_t result =
				message->FindData("RGBColor", B_RGB_COLOR_TYPE, (const void**) &color, &numBytes);
			if (result == B_NO_ERROR) {
				Prefs()->SetColorPref(prefName, *color);
				}
			}
			break;

		default:
			BView::MessageReceived(message);
			break;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MouseMoved(BPoint point, uint32 transit, const BMessage* message)
{
	// check for drag
	if (message != NULL && (transit == B_ENTERED_VIEW || transit == B_EXITED_VIEW)) {
		if (message->what == B_PASTE && message->HasData("RGBColor", B_RGB_COLOR_TYPE)) {
			BRegion boxFrameRgn;
			CalcBox(NULL, &boxFrameRgn);
			SetHighColor(transit == B_ENTERED_VIEW ? keyboard_navigation_color() : boxFrameColor);
			FillRegion(&boxFrameRgn);
			}
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MouseDown(BPoint point)
{
	if (wind)
		wind->Activate();
	else
		wind = new ColorPrefWind(prefName, label, this, savedColor);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"PrefsChangeClient virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void PrefChanged(string_slice changedPrefName)
{
	if (changedPrefName == prefName) {
		BWindow* parentWind = Window();
		if (parentWind->Lock()) {
			Invalidate();
			parentWind->Unlock();
			}
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void CalcBox(BRect* boxRectOut, BRegion* boxFrameRegionOut)
{
	BRect bounds = Bounds();

	// box
	BRect box;
	box.top = floor((bounds.top + bounds.bottom - boxSize) / 2);
	box.bottom = box.top + boxSize - 1;
	box.right = bounds.right - boxFrameSize;
	box.left = box.right - boxSize + 1;
	if (boxRectOut)
		*boxRectOut = box;

	// frame
	if (boxFrameRegionOut) {
		BRect frameRect = box;
		frameRect.InsetBy(-boxFrameSize, -boxFrameSize);
		boxFrameRegionOut->Set(frameRect);
		boxFrameRegionOut->Exclude(box);
		}
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
const char* prefName;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
const char* label;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
rgb_color savedColor;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ColorPrefWind* wind;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float boxSize = 18;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float boxFrameSize = 2;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float divider = 4;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const rgb_color textColor = { 0, 0, 0, 255 };
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const rgb_color boxFrameColor = { 255, 255, 255, 255 };
]]></variable>

</class>


<class mod-time="Sat, 08 Apr 2000 16:03:59 PDT" wind-frame="123.000000,59.000000,763.000000,589.000000" list-views-height="0.000000">
<name>
ColorPrefWind
</name>
<superclasses>
public BWindow
</superclasses>
<hIncludes><![CDATA[
#include <Window.h>

class ColorPrefControl;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "ColorPrefControl.h"
#include "Prefs.h"
#include <ColorControl.h>
#include <Screen.h>

static const int32 ColorChangedMessage = 'ClrD';
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ColorPrefWind(const char* prefNameIn, const char* title, ColorPrefControl* ownerIn,
              rgb_color defaultColor)
	: BWindow(BRect(0, 0, 1, 1), title, B_TITLED_WINDOW, B_NOT_RESIZABLE | B_NOT_ZOOMABLE),
	  prefName(prefNameIn), owner(ownerIn)
{
	// make the colorControl
	colorControl =
		new BColorControl(BPoint(0, 0), B_CELLS_32x8, cellSide, "",
		                  new BMessage(ColorChangedMessage), true);
	colorControl->SetValue(Prefs()->GetColorPref(prefName, defaultColor));
	colorControl->SetViewColor(bgndColor);
	AddChild(colorControl);

	// resize and place window
	BRect controlFrame = colorControl->Frame();
	ResizeTo(controlFrame.Width(), controlFrame.Height());
	BRect screenRect = BScreen(this).Frame();
	MoveTo((screenRect.left + screenRect.right - controlFrame.Width()) / 2,
	       (screenRect.top + screenRect.bottom - controlFrame.Height()) / 2);

	Show();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~ColorPrefWind()
{
	owner->WindowClosing(this);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"BWindow virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MessageReceived(BMessage* message)
{
	switch (message->what) {
		case ColorChangedMessage:
			Prefs()->SetColorPref(prefName, colorControl->ValueAsColor());
			break;

		default:
			BWindow::MessageReceived(message);
			break;
		}
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BColorControl* colorControl;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
const char* prefName;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ColorPrefControl* owner;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float cellSide = 8;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const rgb_color bgndColor = { 216, 216, 216, 255 };
]]></variable>

</class>


<class mod-time="Fri, 21 Apr 2000 00:25:32 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
FontPrefControl
</name>
<superclasses>
public BView
</superclasses>
<hIncludes><![CDATA[
#include <View.h>
#include <Window.h>

#include "string_slice.h"
#include "qstring.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "FontUtils.h"
#include "Prefs.h"
#include "Messages.h"
#include <Message.h>
#include <PopUpMenu.h>
#include <MenuItem.h>
#include <TextControl.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Fri, 21 Apr 2000 00:25:32 PDT"><![CDATA[
FontPrefControl(const char* prefNameIn, string_slice labelIn, BRect frame, uint32 resizingMode)
	: BView(frame, prefNameIn, resizingMode, B_WILL_DRAW),
	  prefName(prefNameIn), label(labelIn), size(12), sizeEditor(NULL)
{
	const char* defaultFont = "be_plain_font";
	string_slice prefNameSlice = prefName;
	if (prefNameSlice == "listFont")
		defaultFont = defaultListFont;
	else if (prefNameSlice == "extraInfoFont")
		defaultFont = defaultExtraInfoFont;
	FontUtils::StringToFont(Prefs()->GetStringPref(prefName, defaultFont),
	                        &savedFont, &isSystemFont);
	if (isSystemFont)
		FontUtils::FontToString(&savedFont, &family);
	else {
		font_family fontFamily;
		font_style fontStyle;
		savedFont.GetFamilyAndStyle(&fontFamily, &fontStyle);
		family = fontFamily;
		style = fontStyle;
		size = (int) savedFont.Size();
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~FontPrefControl()
{
	// revert to the saved font
	qstring fontString;
	FontUtils::FontToString(&savedFont, &fontString);
	Prefs()->SetStringPref(prefName, fontString.c_str());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Save()
{
	if (isSystemFont && family == "be_plain_font")
		savedFont = *be_plain_font;
	else if (isSystemFont && family == "be_bold_font")
		savedFont = *be_bold_font;
	else if (isSystemFont && family == "be_fixed_font")
		savedFont = *be_fixed_font;
	else {
		savedFont.SetFamilyAndStyle(family.c_str(), style.c_str());
		savedFont.SetSize(size);
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetPref()
{
	BFont font;
	if (isSystemFont && family == "be_plain_font")
		font = *be_plain_font;
	else if (isSystemFont && family == "be_bold_font")
		font = *be_bold_font;
	else if (isSystemFont && family == "be_fixed_font")
		font = *be_fixed_font;
	else {
		font.SetFamilyAndStyle(family.c_str(), style.c_str());
		font.SetSize(size);
		}
	qstring fontString;
	FontUtils::FontToString(&font, &fontString);
	Prefs()->SetStringPref(prefName, fontString.c_str());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"BView virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Draw(BRect updateRect)
{
	// set up
	SetFont(be_bold_font);
	SetLowColor(ViewColor());
	font_height fontInfo;
	GetFontHeight(&fontInfo);
	MovePenTo(0, ceil(fontInfo.ascent));

	// label
	DrawString(label.begin(), label.length());
	DrawString("  ");

	// family
	SetFont(be_plain_font);
	familyLeft = PenLocation().x;
	string_slice familyName = family;
	if (familyName == "be_plain_font")
		familyName = "Plain Font";
	else if (familyName == "be_bold_font")
		familyName = "Bold Font";
	else if (familyName == "be_fixed_font")
		familyName = "Fixed Font";
	DrawString(familyName.begin(), familyName.length());
	DrawString(" ");

	if (isSystemFont)
		return;

	// style
	styleLeft = PenLocation().x;
	DrawString(style.data(), style.length());
	DrawString(" ");

	// size
	sizeLeft = PenLocation().x;
	qstring sizeStr(size);
	DrawString(sizeStr.data(), sizeStr.length());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void GetPreferredSize(float* width, float* height)
{
	*width = Bounds().Width();
	font_height fontInfo;
	be_bold_font->GetHeight(&fontInfo);
	*height = ceil(fontInfo.ascent + fontInfo.descent + fontInfo.leading);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MouseDown(BPoint point)
{
	if (!isSystemFont && point.x >= sizeLeft + sizeWidth) {
		// do nothing
		}

	// size
	else if (!isSystemFont && point.x >= sizeLeft)
		StartSizeEdit();

	// style
	else if (!isSystemFont && point.x >= styleLeft)
		PopStyleMenu();

	else if (point.x >= familyLeft)
		PopFamilyMenu();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MessageReceived(BMessage* message)
{
	switch (message->what) {
		case EditDoneMessage:
			FinishSizeEdit();
			break;

		default:
			BView::MessageReceived(message);
			break;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void PopStyleMenu()
{
	// build the menu
	BPopUpMenu* menu = new BPopUpMenu("Style");
	int numStyles = count_font_styles((char*) family.c_str());	// casting away "const" because count_font_styles() isn't declared right
	for (int i=0; i<numStyles; i++) {
		font_style curStyle;
		get_font_style((char*) family.c_str(), i, &curStyle);
		BMenuItem* item = new BMenuItem(curStyle, NULL);
		item->SetMarked(style == curStyle);
		menu->AddItem(item);
		}

	// pop up the menu
	BPoint popPoint = ConvertToScreen(BPoint(styleLeft, 0));
	BMenuItem* selectedItem = menu->Go(popPoint);

	// get the result
	if (selectedItem)
		style = selectedItem->Label();

	// clean up
	delete menu;
	SetPref();
	Invalidate();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void PopFamilyMenu()
{
	int i;

	// build the menu
	BPopUpMenu* menu = new BPopUpMenu("Style");
	// system fonts
	BMenuItem* item = new BMenuItem("Plain Font", NULL);
	item->SetMarked(isSystemFont && family == "be_plain_font");
	menu->AddItem(item);
	item = new BMenuItem("Bold Font", NULL);
	item->SetMarked(isSystemFont && family == "be_bold_font");
	menu->AddItem(item);
	item = new BMenuItem("Fixed Font", NULL);
	item->SetMarked(isSystemFont && family == "be_fixed_font");
	menu->AddItem(item);
	menu->AddSeparatorItem();
	// families
	int numFamilies = count_font_families();
	for (i=0; i<numFamilies; i++) {
		font_family curFamily;
		get_font_family(i, &curFamily);
		item = new BMenuItem(curFamily, NULL);
		item->SetMarked(family == curFamily);
		menu->AddItem(item);
		}

	// pop up the menu
	BPoint popPoint = ConvertToScreen(BPoint(familyLeft, 0));
	BMenuItem* selectedItem = menu->Go(popPoint);

	// get the result
	if (selectedItem) {
		family = selectedItem->Label();
		isSystemFont = false;
		if (family == "Plain Font") {
			family = "be_plain_font";
			isSystemFont = true;;
			}
		else if (family == "Bold Font") {
			family = "be_bold_font";
			isSystemFont = true;;
			}
		else if (family == "Fixed Font") {
			family = "be_fixed_font";
			isSystemFont = true;;
			}
		}

	// adjust style
	if (!isSystemFont) {
		// see if this family has the current style
		bool haveStyle = false;
		font_style curStyle;
		int numStyles = count_font_styles((char*) family.c_str());	// casting away "const" because count_font_styles() isn't declared right
		for (i=0; i<numStyles; i++) {
			get_font_style((char*) family.c_str(), i, &curStyle);
			if (style == curStyle) {
				haveStyle = true;
				break;
				}
			}
		// if not, use the first style in the family
		if (!haveStyle) {
			get_font_style((char*) family.c_str(), 0, &curStyle);
			style = curStyle;
			}
		}

	// clean up
	delete menu;
	SetPref();
	Invalidate();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void StartSizeEdit()
{
	if (sizeEditor)
		return;

	BRect rect = Bounds();
	rect.left = sizeLeft;
	rect.right = rect.left + sizeWidth;
	sizeEditor = new BTextControl(rect, "Font Size", NULL,
	                              qstring(size).c_str(),
	                              new BMessage(EditDoneMessage),
	                              B_FOLLOW_LEFT_RIGHT | B_FOLLOW_TOP);
	sizeEditor->SetTarget(this);
	AddChild(sizeEditor);
	sizeEditor->MakeFocus();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void FinishSizeEdit()
{
	if (sizeEditor == NULL)
		return;
	size = string_slice(sizeEditor->Text()).asInt();
	RemoveChild(sizeEditor);
	delete sizeEditor;
	sizeEditor = NULL;
	SetPref();
	Invalidate();
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
const char* prefName;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice label;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool isSystemFont;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
qstring family;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
qstring style;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int size;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BFont savedFont;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
float familyLeft;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
float styleLeft;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
float sizeLeft;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BTextControl* sizeEditor;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float sizeWidth = 60;
]]></variable>

</class>


<class mod-time="Thu, 27 Apr 2000 22:31:28 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
"Logger"
</name>
</class>


<class mod-time="Thu, 27 Apr 2000 22:58:30 PDT" wind-frame="142.000000,92.000000,782.000000,622.000000" list-views-height="0.000000">
<name>
Logger
</name>
<hIncludes><![CDATA[
#include "string_slice.h"
#include <File.h>

class NNTPConnection;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "NNTPConnection.h"
#include "FileNames.h"
#include <Path.h>
#include <FindDirectory.h>
]]></cppIncludes>
<method access="public" mod-time="Thu, 27 Apr 2000 22:32:12 PDT"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Thu, 27 Apr 2000 22:41:12 PDT"><![CDATA[
Logger(NNTPConnection* connectionIn)
	: connection(connectionIn), logging(false)
{
	status_t err;

	// figure out where the file should be
	BPath path;
	err = find_directory(B_USER_SETTINGS_DIRECTORY, &path, true);
	if (err != B_NO_ERROR)
		return;
	path.Append(FileNames::logFileName);

	// open the file
	err = logFile.SetTo(path.Path(), B_WRITE_ONLY | B_OPEN_AT_END);
	if (err != B_NO_ERROR)
		return;

	//  start logging
	logging = true;
	connection->AttachLogger(this);
}
]]></method>

<method access="public" mod-time="Thu, 27 Apr 2000 22:58:30 PDT"><![CDATA[
~Logger()
{
	if (logging) {
		Log("");
		Log("");
		connection->DetachLogger();
		}
}
]]></method>

<method access="public" mod-time="Thu, 27 Apr 2000 22:37:54 PDT"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Thu, 27 Apr 2000 22:48:36 PDT"><![CDATA[
void Log(string_slice line)
{
	static const string_slice lineEnd = "\n";

	if (!logging)
		return;

	logFile.Write(line.begin(), line.length());
	logFile.Write(lineEnd.begin(), lineEnd.length());
}
]]></method>

<variable access="protected" mod-time="Thu, 27 Apr 2000 22:31:53 PDT"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Thu, 27 Apr 2000 22:32:02 PDT"><![CDATA[
BFile logFile;
]]></variable>

<variable access="protected" mod-time="Thu, 27 Apr 2000 22:40:35 PDT"><![CDATA[
NNTPConnection* connection;
]]></variable>

<variable access="protected" mod-time="Thu, 27 Apr 2000 22:32:05 PDT"><![CDATA[
bool logging;
]]></variable>

</class>


<class mod-time="Fri, 14 Apr 2000 18:07:55 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
"Utils"
</name>
</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Autodeleter
</name>
<hIncludes><![CDATA[

template <class Type>
class Autodeleter {
public:
	Autodeleter(Type* objectIn) : object(objectIn) {}
	~Autodeleter() { delete object; }

protected:
	Type*	object;	
};
]]></hIncludes>
</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
TextReader
</name>
<hIncludes><![CDATA[
#include "string_slice.h"
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
TextReader(string_slice text)
	: p(text.begin()), stopper(text.end()), start(text.begin())
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool AtEOF()
{
	return (p >= stopper);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice NextLine()
{
	const char* lineStart = p;
	while (p < stopper && *p != '\n')
		p++;
	string_slice line(lineStart, p);
	if (p < stopper)
		p++;	// skip '\n'
	return line;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice NextTabField()
{
	// find the field
	const char* fieldStart = p;
	for (; p < stopper; p++) {
		char c = *p;
		if (c == '\t' || c == '\r' || c == '\n')
			break;
		}
	string_slice result(fieldStart, p);

	// skip the tab
	if (p < stopper && *p == '\t')
		p++;

	return result;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int Position()
{
	return p - start;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
const char* p;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
const char* stopper;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
const char* start;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
ParseUtils
</name>
<hIncludes><![CDATA[
#include "string_slice.h"
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Static public"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static void ParseHeader(string_slice line, string_slice* name, string_slice* value)
{
	// find the header name
	const char* p = line.begin();
	const char* stopper = line.end();
	bool foundName = false;
	for (; p < stopper; p++) {
		char c = *p;
		if (c == ' ' || c == '\t') {
			// not a real header line
			break;
			}
		if (c == ':') {
			// found the end of the name
			*name = string_slice(line.begin(), p);
			foundName = true;
			break;
			}
		}
	if (!foundName) {
		*name = *value = string_slice();
		return;
		}
	p++;	// skip ':'

	// skip whitespace
	while (p < stopper && (*p == ' ' || *p == '\t'))
		p++;

	// trim trailing whitespace and set up the value
	const char* valueStart = p;
	p = stopper - 1;
	for (; p >= valueStart; --p) {
		char c = *p;
		if (c != ' ' || c != '\t')
			break;
		}
	*value = string_slice(valueStart, p + 1);
}
]]></method>

</class>


<class mod-time="Sat, 08 Apr 2000 11:39:13 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
FontUtils
</name>
<hIncludes><![CDATA[
#include "qstring.h"

class BFont;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "TextReader.h"
#include <Font.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Static"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static void FontToString(const BFont* font, qstring* str)
{
	if (*font == *be_plain_font) {
		*str = "be_plain_font";
		return;
		}
	else if (*font == *be_bold_font) {
		*str = "be_bold_font";
		return;
		}
	else if (*font == *be_fixed_font) {
		*str = "be_fixed_font";
		return;
		}

	font_family family;
	font_style style;
	font->GetFamilyAndStyle(&family, &style);
	*str = family;
	*str += '\t';
	*str += style;
	*str += '\t';
	*str += ((int) font->Size());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static void StringToFont(const string_slice str, BFont* font, bool* isSystemFont = NULL)
{
	if (str == "be_plain_font") {
		*font = *be_plain_font;
		if (isSystemFont)
			*isSystemFont = true;
		return;
		}
	else if (str == "be_bold_font") {
		*font = *be_bold_font;
		if (isSystemFont)
			*isSystemFont = true;
		return;
		}
	else if (str == "be_fixed_font") {
		*font = *be_fixed_font;
		if (isSystemFont)
			*isSystemFont = true;
		return;
		}

	TextReader parser(str);
	qstring family = parser.NextTabField();
	qstring style = parser.NextTabField();
	qstring size = parser.NextTabField();
	*font = *be_plain_font;
	font->SetFamilyAndStyle(family.c_str(), style.c_str());
	font->SetSize(size.asInt());
	if (isSystemFont)
		*isSystemFont = false;
}
]]></method>

</class>


<class mod-time="Sat, 08 Apr 2000 11:41:19 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
DragUtils
</name>
<hIncludes><![CDATA[
#include "string_slice.h"

class BList;
class BMessage;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "TextReader.h"
#include "string_slice.h"
#include <Message.h>
#include <List.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Statics"
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 11:41:13 PDT"><![CDATA[
static BList* GetDraggedGroups(const BMessage* message)
	// returns a BList of string_slices
{
	BList* groups = new BList();

	// get the text
	const char* text;
	ssize_t textSize;
	status_t result = message->FindData("text/plain", B_MIME_TYPE,
	                                    (const void **) &text, &textSize);
	if (result != B_NO_ERROR)
		return groups;

	// parse it
	TextReader reader(string_slice(text, text + textSize));
	while (!reader.AtEOF()) {
		string_slice line = reader.NextLine();
		if (line.length() == 0)
			continue;
		groups->AddItem(new string_slice(line));
		}

	return groups;
}
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 11:41:19 PDT"><![CDATA[
static bool HasNewsgroups(const BMessage* message)
{
	// get the text
	const char* text;
	ssize_t textSize;
	status_t result = message->FindData("text/plain", B_MIME_TYPE,
	                                    (const void**) &text, &textSize);
	if (result != B_NO_ERROR)
		return false;

	// parse it
	TextReader reader(string_slice(text, text + textSize));
	while (!reader.AtEOF()) {
		string_slice line = reader.NextLine();
		if (line.length() == 0)
			continue;
		if (!IsGroupName(line))
			return false;
		}

	// it passed all the tests
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static bool IsGroupName(string_slice name)
{
	const char* p = name.begin();
	const char* stopper = name.end();
	for (; p<stopper; p++) {
		if (*p <= ' ' || *p > '~')
			return false;
		}
	return true;
}
]]></method>

</class>


<class mod-time="Fri, 21 Apr 2000 02:52:13 PDT" wind-frame="103.000000,154.000000,743.000000,684.000000" list-views-height="0.000000">
<name>
Prefs
</name>
<hIncludes><![CDATA[
#include "Preferences.h"

Preferences* Prefs();


// defaults
extern const char* defaultListFont;
extern const char* defaultExtraInfoFont;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "FileNames.h"

// defaults
const char* defaultListFont = "Dutch801 Rm BT\tRoman\t13";
const char* defaultExtraInfoFont = "Swis721 BT\tItalic\t9";


Preferences* Prefs()
{
	return Preferences::GetPreferences(FileNames::prefsFileName);
}
]]></cppIncludes>
</class>


<class mod-time="Sat, 08 Apr 2000 09:01:47 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
PrefsChangeClient
</name>
<hIncludes><![CDATA[
#include "string_slice.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Prefs.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
PrefsChangeClient()
{
	Prefs()->AddChangeClient(this);
}
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 09:01:47 PDT"><![CDATA[
virtual ~PrefsChangeClient()
{
	Prefs()->RemoveChangeClient(this);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void PrefChanged(string_slice prefName)
{
}
]]></method>

</class>


<class mod-time="Sat, 08 Apr 2000 11:43:31 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
ColorPrefWatcher
</name>
<superclasses>
public PrefsChangeClient
</superclasses>
<hIncludes><![CDATA[
#include "PrefsChangeClient.h"
#include <GraphicsDefs.h>
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Prefs.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ColorPrefWatcher(const char* prefNameIn, rgb_color* colorIn, rgb_color defaultColor)
	: prefName(prefNameIn), color(colorIn)
{
	*color = Prefs()->GetColorPref(prefName, defaultColor);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"PrefsChangeClient virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void PrefChanged(string_slice changedPrefName)
{
	if (changedPrefName == prefName)
		*color = Prefs()->GetColorPref(prefName, *color);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
const char* prefName;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
rgb_color* color;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
LineEndType
</name>
<hIncludes><![CDATA[
#include "string_slice.h"

enum LineEndType {
	UnknownLineEndType,
	BeLineEndType,
	NetworkLineEndType,
	MacLineEndType
};

extern const string_slice lineEndFor[];
]]></hIncludes>
<cppIncludes><![CDATA[

const string_slice lineEndFor[] = {
	string_slice(""),
	string_slice("\n"),
	string_slice("\r\n"),
	string_slice("\r")
};

]]></cppIncludes>
</class>


<class mod-time="Sat, 08 Apr 2000 11:44:40 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Error
</name>
<hIncludes><![CDATA[
#include "string_slice.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "qstring.h"
#include <Alert.h>
#include <string.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Static"
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 10:08:22 PDT"><![CDATA[
static int ShowError(string_slice msgIn, int err = 0)
{
	qstring msg = msgIn;
	if (err != 0) {
		msg += "  (";
		const char* errStr = ErrorString(err);
		if (errStr != NULL)
			msg += errStr;
		else
			msg += err;
		msg += ")";
		}
	BAlert* alert =
		new BAlert("Error alert", msg.c_str(), "OK");
	alert->SetShortcut(0, ' ');
	alert->Go();

	return err;
}
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 10:08:25 PDT"><![CDATA[
static int ShowError(string_slice msg1, string_slice msg2, int err = 0)
{
	qstring msg = msg1;
	msg += msg2;
	if (err != 0) {
		msg += "  (";
		const char* errStr = ErrorString(err);
		if (errStr != NULL)
			msg += errStr;
		else
			msg += err;
		msg += ")";
		}
	BAlert* alert =
		new BAlert("Error alert", msg.c_str(), "OK");
	alert->SetShortcut(0, ' ');
	alert->Go();

	return err;
}
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 10:08:31 PDT"><![CDATA[
static int ShowError(string_slice msg1, string_slice msg2, string_slice msg3, int err = 0)
{
	qstring msg = msg1;
	msg += msg2;
	msg += msg3;
	if (err != 0) {
		msg += "  (";
		const char* errStr = ErrorString(err);
		if (errStr != NULL)
			msg += errStr;
		else
			msg += err;
		msg += ")";
		}
	BAlert* alert =
		new BAlert("Error alert", msg.c_str(), "OK");
	alert->SetShortcut(0, ' ');
	alert->Go();

	return err;
}
]]></method>

<method access="public" mod-time="Sat, 08 Apr 2000 10:08:43 PDT"><![CDATA[
static const char* ErrorString(int err)
{
	/** specific to Item **/
	switch (err) {
		case 400:
			return "Service discontinued";
			break;

		case 411:
			return "No such newsgroup";
			break;

		case 412:
			return "No newsgroup selected";
			break;

		case 420:
			return "No current article has been selected";
			break;

		case 421:
			return "No next article in this group";
			break;

		case 422:
			return "No previous article in this group";
			break;

		case 423:
			return "Article expired";
			break;

		case 430:
			return "No such article found";
			break;

		case 435:
			return "Article not wanted - don't send it";
			break;

		case 436:
			return "Transfer failed - try again later";
			break;

		case 437:
			return "Article rejected - do not try again";
			break;

		case 440:
			return "Posting not allowed";
			break;

		case 441:
			return "Posting failed";
			break;

		case 500:
			return "Command not recognized";
			break;

		case 501:
			return "Command syntax error";
			break;

		case 502:
			return "Access restriction or permission denied";
			break;

		case 503:
			return "Program fault (on server) - command not performed";
			break;

		default:
			return strerror(err);
			break;
		}
}
]]></method>

</class>


<class mod-time="Thu, 27 Apr 2000 22:33:04 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
FileNames
</name>
<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Public Static"
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const char *prefsFileName = "Item Prefs";
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const char* filtersFileName = "Item Filters";
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const char* groupsFileName = "Item Groups";
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const char *cacheFolderName = "Item Cache";
]]></variable>

<variable access="public" mod-time="Thu, 27 Apr 2000 22:33:04 PDT"><![CDATA[
static const char *logFileName = "Item Log";
]]></variable>

</class>


<class mod-time="Sat, 08 Apr 2000 11:45:06 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
ListColors
</name>
<hIncludes><![CDATA[
#include <GraphicsDefs.h>
]]></hIncludes>
<cppIncludes><![CDATA[
#include "ColorPrefWatcher.h"

static ColorPrefWatcher bgndWatcher("listBgndColor", &ListColors::bgndColor,
                                    ListColors::defaultBgndColor);
static ColorPrefWatcher selectedWatcher("listSelectedBgndColor",
                                        &ListColors::selectedBgndColor,
                                        ListColors::defaultSelectedBgndColor);
static ColorPrefWatcher hilitedWatcher("listHilitedBgndColor",
                                       &ListColors::hilitedBgndColor,
                                       ListColors::defaultHilitedBgndColor);
static ColorPrefWatcher textWatcher("listTextColor", &ListColors::textColor,
                                    ListColors::defaultTextColor);
static ColorPrefWatcher numArticlesWatcher("listNumArticlesColor",
                                           &ListColors::numArticlesColor,
                                           ListColors::defaultNumArticlesColor);
]]></cppIncludes>
<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Public Tweex"
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static rgb_color bgndColor;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static rgb_color selectedBgndColor;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static rgb_color hilitedBgndColor;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static rgb_color textColor;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static rgb_color numArticlesColor;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweak Defaults"
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const rgb_color defaultBgndColor = { 255, 255, 255, 255 };
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const rgb_color defaultSelectedBgndColor = { 192, 192, 192, 255 };
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const rgb_color defaultHilitedBgndColor = { 192, 192, 255, 255 };
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const rgb_color defaultTextColor = { 0, 0, 0, 255 };
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const rgb_color defaultNumArticlesColor = { 128, 128, 128, 255 };
]]></variable>

</class>


<class mod-time="Fri, 21 Apr 2000 01:15:10 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Messages
</name>
<hIncludes><![CDATA[

enum {
	OpenArticleMessage = 'OpnA',
	ViewByScoreMessage = 'VwSc',
	ViewBySubjectMessage = 'VwSb',
	MarkMessage = 'Mark',
	UnmarkMessage = 'Unmk',
	KillSubjectsMessage = 'KlSb',
	HiliteSubjectsMessage = 'HiSb',
	NewFilterMessage = 'NFlt',
	NewGroupMessage = 'NGrp',
	EditDoneMessage = 'EdtD',
	AddGroupMessage = '+Grp',
	ShowFiltersMessage = 'ShFl',
	ShowGroupsListMessage = 'ShGr',
	ShowPrefsMessage = 'ShPf',
	ShowAboutMessage = 'ShAb',
	NumConnectionsChangedMessage = 'nCnD',
	AppendArticlesMessage = 'ApdA',
	SaveArticlesMessage = 'SavA',
	PostArticlesMessage = 'Post',
	RemoveReadMessage = 'RmRd',
	ExtractBinariesMessage = 'ExBi',
	ExtractMultipartBinaryMessage = 'ExMB',
	PrefsCheckboxClicked = 'PCbC'
};
]]></hIncludes>
</class>


<class mod-time="Fri, 14 Apr 2000 18:10:39 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
"Exceptions"
</name>
</class>


<class mod-time="Fri, 14 Apr 2000 18:21:41 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
DisplayableException
</name>
<hIncludes><![CDATA[
#include "string_slice.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Error.h"
]]></cppIncludes>
<method access="public" mod-time="Fri, 14 Apr 2000 18:11:01 PDT"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Fri, 14 Apr 2000 18:11:16 PDT"><![CDATA[
DisplayableException()
{
}
]]></method>

<method access="public" mod-time="Fri, 14 Apr 2000 18:11:24 PDT"><![CDATA[
virtual ~DisplayableException()
{
}
]]></method>

<method access="public" mod-time="Fri, 14 Apr 2000 18:12:29 PDT"><![CDATA[
"Virtual"
]]></method>

<method access="public" mod-time="Fri, 14 Apr 2000 18:12:23 PDT"><![CDATA[
virtual string_slice GetMessage() = 0;
]]></method>

<method access="public" mod-time="Fri, 14 Apr 2000 18:12:34 PDT"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Fri, 14 Apr 2000 18:14:56 PDT"><![CDATA[
virtual void Display()
{
	Error::ShowError(GetMessage());
}
]]></method>

</class>


<class mod-time="Fri, 14 Apr 2000 18:23:17 PDT" wind-frame="192.000000,143.000000,832.000000,673.000000" list-views-height="0.000000">
<name>
OSException
</name>
<superclasses>
public DisplayableException
</superclasses>
<hIncludes><![CDATA[
#include "DisplayableException.h"
#include "qstring.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Error.h"
]]></cppIncludes>
<method access="public" mod-time="Fri, 14 Apr 2000 18:15:48 PDT"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Fri, 14 Apr 2000 18:23:17 PDT"><![CDATA[
OSException(string_slice messageIn, int errCode = 0)
	: message(messageIn)
{
	AppendOSError(errCode);
}
]]></method>

<method access="public" mod-time="Fri, 14 Apr 2000 18:22:04 PDT"><![CDATA[
OSException(string_slice message1, string_slice message2, int errCode)
	: message(message1)
{
	message += message2;
	AppendOSError(errCode);
}
]]></method>

<method access="public" mod-time="Fri, 14 Apr 2000 18:22:07 PDT"><![CDATA[
OSException(string_slice message1, string_slice message2, string_slice message3, int errCode)
	: message(message1)
{
	message += message2;
	message += message3;
	AppendOSError(errCode);
}
]]></method>

<method access="public" mod-time="Fri, 14 Apr 2000 18:20:28 PDT"><![CDATA[
"DisplayableException virtuals"
]]></method>

<method access="public" mod-time="Fri, 14 Apr 2000 18:20:50 PDT"><![CDATA[
string_slice GetMessage()
{
	return message;
}
]]></method>

<method access="public" mod-time="Fri, 14 Apr 2000 18:18:28 PDT"><![CDATA[
"Helper"
]]></method>

<method access="public" mod-time="Fri, 14 Apr 2000 18:22:26 PDT"><![CDATA[
void AppendOSError(int errCode)
{
	if (errCode != 0) {
		message += "  (";
		const char* errStr = Error::ErrorString(errCode);
		if (errStr != NULL)
			message += errStr;
		else
			message += errCode;
		message += ")";
		}
}
]]></method>

<variable access="protected" mod-time="Fri, 14 Apr 2000 18:15:20 PDT"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Fri, 14 Apr 2000 18:15:26 PDT"><![CDATA[
qstring message;
]]></variable>

</class>


</project>
